{"transpiled":true,"noir_version":"0.33.0+61d6f251ea67204af2d17175f120e17f2e9e9156","name":"SchnorrAccount","functions":[{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(noinitcheck)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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ts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Yts9Zts9Zts9Zts9Zts8vVCo7y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/Y5y/YFy/YFy/YFy/YFy/bFhUrlYNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+ZNm+ZNm+ZNm+ZNm+vFCpnCzblyzb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+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGA+cGE+cGE+cGE+cGE+cG8WPmcMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD+YMD9YMD9YMD9YMD9YMD9YFyufC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHC+YHG+YHG+YHG+YHG+YH+2Llc8P8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP8YMP84MD84MD84MD84MD84FysfB6YHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyYHxyWH9SL5QdPPah8PvWg8vnUg8rnUw8qn089qHw+9aDy+dSDyudTDyqfTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPLJ9ZfvDUA8tnlh889cDymeUHTz2wfGb5wVMPK58F5gcF5gcF5gcF5gflYuWzwPygwPygwPygwPygwPygPNwP9o8Xz2U/1/P+xS8fr9RrHefq/kf58lfN6luzHW+vjj96lUW96qJebVGvvqjXWNRrLuq1FvXai3qdPb3qorlJyXPTy8rRfHt1i93oVe3MC291i+ufXv/3fsmz0+/olzw//Y5+fVm/5Dnqd/RLnqV+R78Pv3OxH28XIe/uFB5vzm/UM6x6YOZcYOZcYOZcHm/Ob/z7cVg9AasnYfXA8tlg+WywfH68Ob9RDyyfH23O9UxVr19ZLW/MV/HTD7PR2u/npUcb9bvX71+8/vji9cPeXxz2/uKw95dHm/l/8t/bxFvappS8//f2aGN/9/rli9d/j/e7S97+Es8b9Xe//cQ/0r/+ytrydtXb8dNtwssffPdqv+b1S7v8lG1dH7x49Ho99FGN//hFxV2WDzwP8hykPw/yPgcZz4O8z0Hm8yDvc5D1PMj7HGR/8anji0+t+cWn1vziU2uyb2lu18++pbldv7Nu7WCbUwS2OUVgm1MEtjlFYJtTBLY5RWCbUwS2OUVgm1MEtjlFYJtTBLY5RWCbUwS2OUVgm1MEtjlFYJtTBLY5RWCbUwS2OUVgm1MEtjlFYJtTBLY5RWCbUwS2OUVgm1MEtjlFYJtTBLY5RWCbUwS2OUVgm1MEtjlFYJtTFLY5RWGbUxS2OUWv76So0l4/QWz96bURf/Tqi3r9TnrqVq/fSU7d6pWs0O/dK1mh37tX2Pu4wN7HBfY+LrD3cWH9nKUP3/hyqx7Wz1kqrJ+zVFg/Z6mwfs5SgeWzwvJZYfmssHxWWD4rLJ8Vls8Ky2eF5bPC8llh+QzblqCwbQkK25agBstng+WzwfLZYPlssHw2WD4bLJ8dls+wbQnqsHx2WD47LJ8dls8Oy2eH5bPD8tlh+RywfA5YPgcsnwOWzwHL54Dlc8DyOWD5HLB8Dlg+JyyfE5bPCcvnhOUzzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkqzJkazJkazJkazJnaxcrn85fB6mHls12sfLaLlc92sfLZYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYX7QYX7QYX7QYX7QL1Y+O8wPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPBswPBswPBswPBswPxsXK54D5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wXi4H+wfL57Lfq7n/Yv1yqzXOq78qXz5q2b1rdmOt1fHH736ol5jUa+5qNda1Gsv6vXB7+MvP9m9fuWoG7229uubSNtcf+r0b9U/WqXeuXr50tXrl67evnT1/qWrjy9dfX7p6utLV99fuvov/V7bX/q9tr/0e21/6ffa/tLvtY+W0Xeu/ku/1/aXfq/tL/1eew/RXVe9/eyp8+vq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wPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwvxgwvxgwvxgwvxgXqx8TpgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfTJgfLJgfLJgfLJgfLJgfrIuVzwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgwXzgw3zgw3zgw3zgw3zg32x8rlhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfrBhfnBgfnBgfnBgfnBgfnAuVj4PzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8OzA8Oyw/6xfKDpx5UPp96UPl86kHl86kHlc+nHlQ+n3pQ+XzqQeXzqQeVz6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCpB5bPLD946oHlM8sPnnpg+czyg6ceWD6z/OCph5XPAvODAvODAvODAvODcrHyWWB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGF+UGF+UGF+UGF+UC9WPivMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDxrMDxrMDxrMDxrMD56/DFYPK58N5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcN5gcd5gcd5gcd5gcd5gf9YuWzw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/ygw/xgwPxgwPxgwPxgwPxgXKx8DpgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfDJgfTJgfTJgfTJgfTJgfzIuVzwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwnzgwXzgwXzgwXzgwXzg3Wx8rlgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBgfrBhfrBhfrBhfrBhfrAvVj43zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA82zA8OzA8OzA8OzA8OzA/OxcrngfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBgfnBebQf1Mv89StfNT/X89GLM+vt1Tn19nL5uNkqfauk4+3V8UevtajXXtTr7On10V7zU3uVRb3qol5tUa++qNdY1Ct5bjqT3vyY+lrsRq9qIvZWt7j+6fV/75c8O/2Ofsnz0+/olzxD/YZ+jTxH/Y5+ybPU7+j3DvNURr8WlW03fs4u+/F2EfLjxfZHPQarx2H1xKPrqeutnp+Ggbd6ElZPwepp2L+fYdVzDxd+13oEVg8snx2Wzw7LZw9YPQmrB5bP3rB6hlVPXLB6HpzPKvNaj6rlz/V88JXjp8uQaO3383boF6/fvnj9/sXrh72/BOz9JQpWT6P/vZ18f/vSUvLBv7f52vXn9cXrv8f73fV2H5V+6z6q++3G6Hw4/uuvrC1vHxV0/HQb9fIH373ar3n90i4/ZVvXBy8+H+C+Hvr5zC/+9T980XWPBQHPg3w5SHse5H0O0p8HeZ+DjOdB3ucg83mQ9znI+uJTxxefWvOLT631xafWYt/S3K6ffUtzu35j3drdY7vJXeuBfYpasE9RC3ZLX7Bb+oLd0jfslr4FVo/C6oHlc8PyuWH53LB8blg+NyyfG5bPA8vngeXzwPJ5YPk8sHweWD4PLJ8Hls8Dy+dB5XNcFyqfTz2ofD71oPL51IPK51MPKp9PPah8PvWg8vnUg8rnUw8qn089sHwWWD4LLJ8Fls8Cy2eB5bPA8llg+SywfBZYPgssnxWWzwrLZ4Xls8LyWWH5rLB8Vlg+KyyfFZbPCstng+WzwfLZYPlssHw2WD6zFPypB5bPLAV/6oHls8Hy2WH57LB8dlg+OyyfHZbPDstnh+UzS8GfemD5zFLwcbEU/KkHls8By+eA5XPA8jlg+RywfA5YPgcsnwOWzwnL54Tlc8LyOWH5nLB8Tlg+JyyfE5bPCcvnhOVzwfK5YPlcsHxm+cFTDyyfWX7w1APLZ5YfPPXA8pnlB+Ni+cFTDyyfWX7w1APLZ5YfPPXA8pnlB089sHxm+cFTDyyfWX7w1APLZ5YfPPXA8pnlB089sHy+y9PRr3r7K3Ru1JP5Y4NLxduLpeePgopWUNMKGlZBcpcnpN+1IKEVhHoG76kH9QzeU4/D6kE9g/fUg3pG+qkH9Yz0Uw/qGemnHtQz0kNYz0g/9aCekX7qgeUz6xnppx5YPrOekX7qgeWzwPJZYPkssHxWWD4rLJ8Vls8Ky2eF5bPC8llh+aywfFZYPissnw2WzwbLZ4Pls8Hy2WD5bLB8Nlg+GyyfDZbPBstnh+Wzw/LZYfnssHx2WD47LJ8dls8Oy2eH5bPD8jlg+RywfA5YPgcsnwOWzwHL54Dlc8DyOWD5HLB8Tlg+JyyfE5bPCcvnhOVzwvI5YfmcsHxOWD4nLJ8Lls8Fy+eC5XPB8rlg+VywfC5YPhcsnwuWzwXL54blc8PyuWH53LB8blg+NyyfG5bPDcvnhuVzw/J5YPk8sHweWD4PLJ8Hls8Dy+eB5fPA8nlg+TysfNaLlc96sfJZYX5QYX5QL1Y+K8wPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPGswPGswPGswPGswPnr8MVg8rnw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBx3mBx3mBx3mBx3mB/1i5bPD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/GDA/GDA/GDA/GDA/GBcrHwOmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB9MmB9MmB9MmB9MmB/Mi5XPCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODBfODBfODBfODBfODdbHyuWB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGF+sGF+sGF+sGF+sC9WPjfMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDw7MDw7MDw7MDw7MD87FyueB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cFh+cG8WH7w1IPK51MPKp9PPah8PvWg8vnUg8rnUw8qn089qHw+9aDy+dQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1sPJZYH5QYH5QYH5QYH5QLlY+C8wPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPyqP9oF7mr1/5qvm5no9enFlvr86pt5fLx81W6VslHW+vjj96tUW9+qJeY1GvuajXWtQr5338gxdnXq8vzvpRu/T8UT3nXf/fUT3IsP57qhfwfyWnv/nRa4vd+K9E7XzC8Vb3mU7+9Pq/90ueWH5Hv+Sp5Xf068v6JU8vMiM/3uXO7eQH9X+riST77V06Z/7tu3R8q4nkRq+9qNfZ0+ujRfin9kqejf75nyDM3iqJdz9B5Pe6yfl1r9/rJufXvfqiXr/XTc6ve/1eNzm/7vV73eT8utdvNTfd6PVbzU2/7rW+1dx0o9dFc1Mtmptq0dz06M0Yn9rrormpFs1NtWhuqkVzUy2am3rR3NSL5qZeNDf1ornp0RtrPrXXRXNTL5qbetHc1Ivmpl40N82iuWkWzU2zaG6aRXPTozdJfWqvi+amWTQ3zaK5aRbNTbNnbtJrz9yk1565Sa89c5Nee+YmvXxRr3vmJr32zE167Zmb9NozN+m1aG6SRXOTLJqbZNHcJIvmpkdvXvzUXhfNTbJobpJFc5Msmptk0dyki+YmXTQ36aK5SRfNTY/eiPqpvS6am3TR3KSL5iZdNDfpornJFs1NtmhuskVzky2amx69qfhTe100N9miuckWzU22aG6yRXOTL5qbfNHc9M02cf+610Vz0zfbxP3rXhfNTd9sE/eve100N/miuckXzU2xaG5C7wS/d6+L5ib0LvB79+qLel00N32vfeE3el00N32vfeE3el00N32vfeE3el00Ny3aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXron3humhfuC7aF66L9oXbon3htmhfuC3aF26L9oWfRhb1umduskX7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBbtC/cFu0Lt0X7wm3RvnBftC/cF+0L90X7wn3RvnC/fFGve+YmX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC/dF+8J90b5wX7Qv3BftC49vti+89K2Sft/r95qbft3ro+cmy7ev7KK/7lVi4nr90iklf+r17/XbF6/fyfWnXvNW//mjH9QfX7z+/OL11xevv8n119X+9qVF4lbWZr9lbc68y9rZ0+vD92R/Zq+yqFf0vHDnXtGzxT/b66/n+4fvyf7MXtEzy517Rc83d+4VPQvduddvNTfd6PVbzU2/7lW/1dx0o9dvNTfd6PVbzU03el00Nz18T/Zn9rpobtJFc5Mumpt00dyki+YmWzQ32aK5yRbNTbZobnr4nuzP7HXR3GSL5iZbNDfZornJFs1Nvmhu8kVzky+am3zR3PTwPdmf2euiuckXzU2+aG7yRXOTL5qbYtHcFIvmplg0N8Wiuenhe7I/s9dFc1Msmpti0dwUi+amWDQ35aK5KRfNTblobspFc9PD92R/Zq+L5qZcNDflorkpF81NuWhuqkVzUy2am2rR3FSL5qaH78n+zF4XzU21aG6qRXNTLZqbatHc1Ivmpl40N/WiuakXzU0P35P9mb0umpt60dzUi+amXjQ39aK5aRbNTbNobppFc9Msmpsevif7M3tdNDfNorlpFs1Ns2humj1zU1575qa89sxNyd6Tfede98xNefmiXvfMTcne633nXvfMTfm99oXf6HXR3PS99oXf6HXR3PS99oXf6HXR3LRoX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3gu2heei/aF56J94bloX3h+s33hpW8v7/e9fq+56de9Pnpuuuy1er1qbvQ6Na91yLTYjV7VROytbnH90+v/3q8v6zeW9ZvL+q1l/fayfmdXvw/fJf7Z/cqyfnVZv8vmq0fvFpfxHx2U/dzv3+sJWD0Jq6dg9dzh/f0MCa9/RbbdqKfsx49HIT9ebH/UM6x67rEz+q71CKwehdVjsHocVk/A6klYPQWrp1nvF/XwfK7rrfipd+fTF6wegdWjsHoMVg9sfm7Y/NwPzmeVef1+6bmn//n79cFXjp8u26O13/981PXF6+8vXv987frn+uL1CytPHr0782Y9BqsH9n40sPejgd3n3GPfYl5v9aTfum/sfrsRHOlff2VtqdcXd/x02/jyB9+92q95/dLnU/EfX7rrgxePXq+hNqq3PhT/By4y77HM8XmQLwc5z4O8x0HWPdZQPg/y5SDleZD3OUh9HuR9DtKeB3mfg/TnQd7nION5kPc5yHwe5H0OkvVJdV2sT0LqYt9sTbzde6eUvP/+Cvtm63b98sXr1y9ev33x+v2L1x9fvH72J0u362d/snS7fvYnS7frH9Y88OgtkjfrYX3yU8r65KeU9clPPXqr4c16WJ/8lLI++Sl9+G+K/fI3WUobVg/rN8XKWL8pVsb6TbEy1m+KlbF+U6zusT3trvUErJ6E1QO7vzLY/ZXB8tlh+eywfHZYPjssnx+9penWf18Om58dls8Om58dNj87LJ8Dls8Bu98I2P1GwO43ApbPAcvngN1vBCyfA5bPAcvnhOVzwubnhM3PCZuf77FJ4q71wO43EjY/wzZJVMLuNxKWzwXL54Llc8HyuWD5XLB8Llg+FyyfCzY/F2x+LtjvbzTs9zcadr/RsPuNht1vwDZJFGyTRDXsfqNh+dywfG7Y/Dyw+Xlg8/PA5ueBzc/32Kxw13pg8/PA5ueB3W8M7H5jWPncFyuf+2Llc1+sfO6Llc99sebnvljzc1+sfO6LNT/3xZqf+4Lls8DyWVj3Gy2s+40W1v1GCyyfBZbPwrrfaIHls8DyWWD5rLB8Vtj8rLD5WWHz8z384F3rYd1vtMLmZ2Xdb7Sy7jca5gcb5gcb5gcb5gcb5gcb5gcb5gcb5gfbYPOzweZnY/3+Rjvr9zfaYfcbDrvfcNj9BswPNswPtsPuN2B+sGF+sGF+sGF+sAM2Pwdsfg7Y/HwPP3jXemDzc8Dm54DdbwTsfgPmBxvmBxvmBxvmBxvmBxv2JOqGPYm6YX6wEzY/J2x+hvnBhvnBLtj9RsHuNwp2v1GwfC5YPhfsfgPmBxvmBxv2JOqGPYm6YU+ibtiTqBv2JOq+hx+8az2w+42Gzc8Nu99o2P0GzA82zA82zA82zA82zA82zA82zA82zA/2wObngc3P8+Df39DL/PUrXzU/v1989OZS8+PdpeVHrx8/zy7ttZDWn14b8bde57oW9SqLetVFvdqiXn1Rr7Go11zUay3qtRf1yvq91xHW770OzPUOzPUOzPUOzPUOzPUOzPWOsO4dR1j3jgN7LujAngs6sOeCDuy5oAN7LujAngs6sOeCDuy5oANzvQNzvaOwfDZYPhssnw2WzwbLZ4Pls8Hy2WD5DHsu6MCeCzow1zsw1zsw1zsw1zsw1zsw1zsw1zsw1zsOy2eH5bPD8jlg+Qx7LujAngs6sOeCDuy5oAN7LujAngs6MNc7MNc7AcvnhOVzwvI5YfmcsHyGud6Bud5JWD7Dngs6sOeCTsLyuWD5DHO9A3O9A3O9A3O9A3O9A3O9U7B8Llg+w54LOrDngg7suaADey7owJ4LOrDngg7suaADey7owFzvwFzvNCyfB5bPA8vngeXzwPJ5YPk8sHweWD7Dngs6sOeCzqDyua4Llc+nHlQ+n3pQ+XzqQeXzqQeVz6ceVD6felD5fOpB5fOpB5XPpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KkHls8sP3jqgeUzyw+eemD5zPKDpx5YPrP84KmHlc8C84MC84MC84MC84NysfJZYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYH5QYX5QYX5QYX5QYX5QL1Y+K8wPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPKswPGswPGswPGswPGswPnr8MVg8rnw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBw3mBx3mBx3mBx3mBx3mB/1i5bPD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/KDD/GDA/GDA/GDA/GDA/GBcrHwOmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB8MmB9MmB9MmB9MmB9MmB/Mi5XPCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODCfODBfODBfODBfODBfODdbHyuWB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGB+sGF+sGF+sGF+sGF+sC9WPjfMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDzbMDw7MDw7MDw7MDw7MD87FyueB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cGB+cFh+cG+WH7w1IPK51MPKp9PPah8PvWg8vnUg8rnUw8qn089qHw+9aDy+dQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1wPKZ5QdPPbB8ZvnBUw8sn1l+8NQDy2eWHzz1sPJZYH5QYH5QYH5QYH5QLlY+C8wPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPCswPKswPKswPKswPKswP6sXKZ4X5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYP5QYP5QYP5QYP5wfOXweph5bPB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDB/KDD/KDD/KDD/KDD/KBfrHx2mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB90mB8MmB8MmB8MmB8MmB+Mi5XPAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODAfODCfODCfODCfODCfODebHyOWF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MGF+MB/tB/Uyf/3KV83P9Xz04sx6e3VOvb1cPm62St8q6Xh7dfzRqy7q1Rb16ot6jUW95qJea1GvvajX2dPro+3tp/ZKnpvOpDc/pr4Wu9Grmoi91S2uf3r93/slz06/o1/y/PQ7+vVl/ZLnqN/RL3mW+h393mGeyujXorLtxs/ZZT/eLkJ+vNj+qKdh9Qyrnnu48H+unrre6vlpGHirR2D1KKweg/37cVg9AasnYfXA8tlh+eywfI4LVo/A6oHlcxisHofVE7B6HpzPKvNaj6rlz/V88JXjp8uQaO3383bUF6+/v3j987XrT9j7S8LeX1Jh9Rj639vEW9qmlHzw782/eP3xxeu/x/vd9XYfdX6+uVF/99uN0Uj/+itry9tHBR0/3Ua9/MF3r/ZrXr+0y0/Z1vXBi0ev10Mf1fjX//BF1z0WBDwP8uUg+3mQ9znIeR7kXQ7yHrskngf5cpDyPMj7HKR+7amjvvjUeo/tIJ9a/xefWot9S3O7fvYtze36m3VrV8Oqp2GfojbsU9SG3dI37Jb+HttN7loP7Ja+E1ZPweqB5XPD8nlg+TywfB5YPg8snweWzwPL54Hl88DyeWD5PKx8rouVz3Wx8rkuVj7Xxcrnulj5XBcrn+ti5XNdrHyui5XPdcHyWWD5LLB8Flg+CyyfBZbPAstngeWzwPJZYPkssHxWWD4rLJ8Vls8Ky2eF5bPC8llh+aywfFZYPissnw2WzwbLZ4Pls8Hy2WD5bLB8Nlg+GyyfDZbPBstnmIIvmIIvmIIvh+Wzw/LZYfnssHx2WD47LJ8dls8By+eA5TNMwRdMwRdMwRdMwVfA8jlg+RywfA5YPicsnxOWzwnL54Tlc8LyOWH5nLB8Tlg+JyyfE5bPBcvnguVzwfK5YPlcsHwuWD4XLJ8Lls8wP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP1gwP9gwP9jXd3pKUdprIa0/vTbij16/0xOKbvX6nZ5OdKtXX9Trd3oq0a1ev9MTiW71ynpKc1+spzT3xXpKcwvrKc0tAqtHYfUYrB6H1ROwehJWDyyfBZbPAstnheWzwvJZYfmssHxWWD4rLJ8Vls8Ky2eF5bPC8tlg+WywfDZYPhssnw2WzwbLZ4Pls8Hy2WD5bLB8dlg+OyyfHZbPDstnh+Wzw/LZYfnssHx2WD47LJ8Dls8By+eA5XPA8jlg+RywfA5YPgcsnwOWzwHL54Tlc8LyOWH5nLB8Tlg+JyyfE5bPCcvnhOVzwvK5YPlcsHwuWD4XLJ8Lls8Fy+eC5XPB8rlg+VywfG5YPjcsnxuWzw3L54blc8PyuWH53LB8blg+NyyfB5bPA8vngeXzwPJ5YPk8sHweWD4PLJ8Hls/Dyue5WPk8Fyuf52Ll81ysfJ6Llc9zsfJ5LlY+D8wPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDswPDssPzsXyg6ceVD6felD5fOpB5fOpB5XPpx5UPp96UPl86kHl86kHlc+nHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqQeWzyw/eOqB5TPLD556YPnM8oOnHlg+s/zgqYeVzwLzgwLzgwLzgwLzg3Kx8llgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBgflBhflBhflBhflBhflAvVj4rzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8qzA8azA8azA8azA8azA+evwxWDyufDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHDeYHHeYHHeYHHeYHHeYH/WLls8P8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8oMP8YMD8YMD8YMD8YMD8YFysfA6YHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyYHwyY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ikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzikYzik4zik4zik4zik4zin7BktppRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRtFpRjFoRjFoRjFoRjFoRjEuWFIHzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgGzSgmzSgmzSgmzSgmzSjmBUvqpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFpBnFohnFohnFohnFohnFumBJXTSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSjWDSj2DSj2DSj2DSj2DSj2BcsqZtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFJtmFIdmFIdmFIdmFIdmFOeCJfXQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLQjOLAjKJeMKN4CmIl9SmIldSnIFZSn4JYSX0KYiX1KYiV1KcgVlKfglhJfQqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CaEkNM4qnIFpSw4ziKYiW1DCjeAqiJTXMKJ6CYEktNKMoNKMoNKMoNKMoFyyphWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUhWYUlWYUlWYUlWYUlWYU9YIltdKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotKMotGMotGMotGMotGM4vnbaAXBktpoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtEebRT1Mn/9ylfNzwV99OLMent1Tr29XD7utkrfKul4e3W8Nlubmu1Nzc6iZh9tQj+3WdnUrG5q1jY165uajU3NkieoM/TNjwGwxW40+3IfZW91i+ufXv9Hw+Qp6rc0TJ6kfkvD5GnqdzTs5InqtzRMnqp+S8N3mKwy+rWqbLvxg3fZj3eNkB8vtteCjFaQ0wqKRxdU11tBP40FPwpKWkFFK6hp/4YGVtA97Pl9CxJaQbSkDlpSBy2pI2gFJa0gWlJH0woaWEF50Qp6cFK/PCTn9Sufv/3ngj74yvHTNUm09gczeOpXb8C+egP+1RugvdMk7Z0mi1ZQo//NTbylbkrJR//m5os3UNdXb+Ae73zX221V+q3bqu63+6SR/vVX1pa3jxM6frqrevmD717t17x+aZefIq7rgxePXq+nPqrxr//xa7B7LCF4nuTfTtKeJ3mnk/TnSd7pJON5knc6yXye5J1Osr768PHV59f66vNrf/X5tdk3N/9AA+ybm3+gAYNd5t1jg8p9C6J92tq0T1ubdofftDv8pt3hD+0Of4RWkNIKoiX10JJ6aEk9tKQeWlIPLakHltR+wZLaL1hS+wVLar9gSe0XLKn9giW1X7Ck9guW1H7BktovWlILLamFltRCS2qhJbXQklpoSS20pBZaUgstqYWW1EpLaqUltdKSWmlJrbSkVlpSKy2plZbUSktqpSW10ZLaaElttKQ2WlIbLamNltRGS2qjJbXRktpoSe20pHZaUjstqZ2W1E5Lapq0d5q0d5q0d6cltdOSOmhJHbSkDlpSBy2pg5bUQUvqoCU1Tdo7Tdo7Tdo7Tdp70pI6aUmdtKROWlInLamTltRJS+qkJXXSkrpoSV20pC5aUhctqYuW1EVL6qIlddGSumhJXbSkblpSNy2pm5bUNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKPoNKMYNKMYNKMYNKMYNKMYFyypg2YU4/pOz1NKey2k9afXRrw2+52epXSz2e/0HKWbzX6nZyjdala+0/OTbjb7nZ6ddLNZ2DOmQ2DPmI57WNb7FgR7xnRI0goqWkFNK2hgBelFK0hoBdGSWmlJrbSkVlpSKy2plZbUSktqpSW10ZLaaElttKQ2WlIbLamNltRGS2qjJbXRktpoSe20pHZaUjstqZ2W1E5LaqcltdOS2mlJ7bSkdlpSBy2pg5bUQUvqoCV10JI6aEkdtKQOWlIHLamDltRJS+qkJXXSkjppSZ20pE5aUictqZOW1ElL6qQlddGSumhJXbSkLlpSFy2pi5bURUvqoiV10ZK6aEndtKRuWlI3LambltRNS+qmJXXTkrppSd20pG5aUg8tqYeW1ENL6qEl9dCSemhJPbSkHlpSDy2pB5bUecGSOi9YUucFS+q8YEmdFyyp84IldV6wpM4LltR5wZI6L1pSCy2phZbUNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKOYNKNYNKNYNKNYNKNYNKNYFyypi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUi2YUm2YUm2YUm2YUm2YU+4IlddOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOMYtOM4tCM4tCM4tCM4tCM4lywpB6aURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyYUbQLZhRPQaykPgWxkvoUxErqUxArqU9BrKQ+BbGS+hTESupTECupT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUT0G0pIYZxVMQLalhRvEUREtqmFE8BdGSGmYUz19GS2qYUTx/GS2pYUbx/GW0pIYZxfOX0ZIaZhTPX0ZLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXRkhpmFE9BtKSGGcVTEC2pYUbxFERLaphRPAXBklpoRlFoRlFoRlFoRlEuWFILzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgKzSgqzSgqzSgqzSgqzSjqBUtqpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFpRlFoxlFoxlFoxlFoxnF87fRCoIltdGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotGMotOMotOMotOMotOMol+wpHaaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUXSaUQyaUQyaUQyaUQyaUYwLltRBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4pBM4rxaKOol/nrV75qfi7ooxdn1turc+rt5fJxt1X6VknH26vjtVnb1KxvajY2NZubmq1NzXLe0T94ceb1+uKsH8VLz2v5nPf/f0/5ICf77ypfwP+lnAbnR7MtduO/FDURe6tbXP/0+j8aJs8uv6Vh8vzyWxr2bQ2T5xiZkR/vdqL1UQPfajbJfnu7zpl3b9f5rWaTW832pmZnUbOPVuef2yx5Svrnf54we6sk3v88Ud/rdudGs9/rdudGs76p2e91u3Oj2e91u3Oj2e91u3Oj2W81Qd1q9ltNUDea7W81Qd1qdtME1ZsmqN40QT16+8bnNrtpgupNE1RvmqB60wTVmyao2TRBzaYJajZNULNpgnr0VpzPbXbTBDWbJqjZNEHNpglqFk1QeS2aoPJaNEHltWiCymvRBJWXb2p20QSV16IJKq9FE1ReiyaovDZNULJpgpJNE5RsmqBk0wT16C1yn9vspglKNk1QsmmCkk0TlGyaoHTTBKWbJijdNEHppgnq0dsdP7fZTROUbpqgdNMEpZsmKN00QdmmCco2TVC2aYKyTRPUo7eufm6zmyYo2zRB2aYJyjZNULZpgvJNE5RvmqB80wTlmyaoR29D/txmN01QvmmC8k0TlG+aoHzTBBWbJqjYNEF9s23fN5rdNEF9s23fN5rdNEF9s23fN5rdNEHFpgkqNk1QuWmCQu8dv3uzmyYo9L7xuzfrm5rdNEF9r53kt5rdNEF9r53kt5rdNEF9r53kt5rdNEFt2kmem3aS56ad5LlpJ3lu2kmem3aS56ad5LlpJ3lu2kmem3aS56ad5LlpJ3lu2kmem3aS56ad5LlpJ3lu2kmem3aS56ad5LlpJ3lu2kmem3aS56ad5LlpJ3lu2kmem3aS56ad5LlpJ3lt2klem3aS16ad5LVpJ3ldvqnZRRNUbdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2ktemneS1aSd5bdpJXpt2kvemneS9aSd5b9pJ3pt2kvflm5pdNEH1pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkneW/aSd6bdpL3pp3kvWkn+WzaST6bdpLPpp3ks2kn+Vy+qdlFE9Rs2kk+m3aSz6ad5LNpJ/k8fCe55dtXdtFfNysxcb1+6ZSSPzX7RwPy1RtQcgOp17w1cP7oRw3YV2/Av3oD8dUbSHIDdbW/fWmRuBW52frW78z7yK1NzfamZmdRs4qeHO7dLHrK+GebvTETKnoiuXez6Onl3s36pmbRU9G9m/1WE9StZr/VBHWr2W81Qd1q9ltNUDeatW81Qd1qdtMEZZsmKNs0QT18F/enNrtpgrJNE5RtmqBs0wRlmyYo3zRB+aYJyjdNUL5pgnr4Lu5PbXbTBOWbJijfNEH5pgnKN01QsWmCik0TVGyaoGLTBPXwXdyf2uymCSo2TVCxaYKKTRNUbJqgctMElZsmqNw0QeWmCerhu7g/tdlNE1RumqBy0wSVmyao3DRB1aYJqjZNUP//9u5oR47cShPwKyXJw3PIp1nMDBYLA4a9mPEusBf77hNqd5Vkq6xqpZPVn5y6MSx0RvIwK/gXixkfWc80g6pnmkF9+F7cv2tnn2kGVc80g6pnmkHVM82g6plmUOuZZlDrmWZQ65lmUOuZZlAfvhf379rZZ5pBrWeaQa1nmkGtZ5pBrWeaQe1nmkHtZ5pB7WeaQe1nmkF9+F7cv2tnn2kGtZ9pBrWfaQa1n2kGtZ9nBhW32/PMoK7OPs8M6urs88ygrs4+zwzq6mw8U2efZwZ1dfZ5ZlBXZ59nBnV19nlmUFdnn2kGZe/F/ejOPtMMyt7j+9GdfaYZlL13+KM7+0wzqH+tPcnf6+wzzaD+tfYkf6+zzzSD+tfak/y9zj7TDOqJ9iS/OvtMM6gn2pP86uwzzaCeaE/yq7PPNIN6oj3Jr84+0wzqifYkvzr7TDOoJ9qT/OrsM82gnmhP8quzzzSDeqI9ya/OPtMM6on2JL86+0wzqCfak/zq7DPNoJ5oT/Krs880g3qiPcmvzj7TDOqJ9iS/OvtMM6gn2pP86uwzzaCeaE/yq7PPNIN6oj3Jr84+0wzqifYkvzr7TDOoJ9qT/OrsM82gnmhP8quzHz2DupblX975Vvudzu7aL3W0vdp4p7N9tDZe627R/+b1f+3wh+9L/rt3uD1bh/uzdXg8W4fj2To8n63D+Wwdrmfr8Hq2Dj/bTOuj9y9vOz53ocaXHf61oKYV1LWChlbQA37T51wvbeQa7xRUo3/+c6l9fvF4KWhqBaVWUGkFLa2gjRX0iH2SH1tQ0wrqWkFDKyiwXx3rw5O6bq/V73rjE0qtoNIKWlpBGytoa3Pqrc2p9wcndW/75UfWr5X8L39kb7zzrHqN0bn6euPPpj1+9A7Ej96B+aN3IH/0DpSWKksraFsFtRv2m6ndsN9M7Yat9rRH7OmYt9eCMt5bkVzrdc1wt/Xtd+6r1cuL1/xiPfLThV+9+tOvzV9ffX2F/vmtV73x4t1vL9m2e3/vG/TfsNTZbvHzk3zQJzl/fpIP+iTz5yf5oE+yfn6SD/ok189P8kGf5P75ST7mk3zE9qI/P8lfPsn285N80CfZf36SD/oksW+020fvjPp+QfZq156vK+LZqr31I7ZXu35DB+pH78D60Tuwf/AO9NuP3oH2o3fA/t7pN3TA/t7pN3QgfvQOTGxq8NE7Vb5fEPa9UOvY90Kta98LDe17oaF9LzS074XGhz9b9u2nXtoIrSDs2bI2sGfL2sCeLWsDe7asDezZshY3raCmFdS1grTVrY/eMez9grSkDi2pQ0vq0JI6tKSe2px6anPqqSX11ObUj9iZ6LEFaUk9taSe2urH1FY/prb6kVpSp5bUqa1+pJbUqSV1akmdWlKnNqdObU6d2py6tNWP0lY/SptTa7tVtEfsVvHYgrSkLi2pS0vq0pK6tKReWlIvLamXltRLm1M/YreKxxakPfuxtGc/lrb6sbTVj6Wtfmi7VTRtt4q2tdWPrSX11pJ6a3Pqrc2ptzan3tqcemNz6n7D5tT9hs2p+w2bU/cbtvrRb6EVhCV1v2FJ3W9YUvcbltT9piV1w+bUvWFz6t60pG7YnLo/wqA+tiAtqZuW1A1b/egNW/3oDVv96F1L6q4ldcdWP3rXkrprSd21pO5aUndtTt21OXXX5tRDW/0Y2urH0ObUQ1v9eIRRfGxBWlJrRrFrRrFrRrFrRrFrRrFrRrFrRrGHNqd+hFF8bEHYsx89sGc/emirH6GtfoS2+qEZxa4ZxT611Q/NKHbNKHbNKHbNKPapzamnNqee2pw6tTl1anPq1ObUqa1+fPSJ7O8XpCW1ZhS7ZhS7ZhS7ZhS7dqJ2107U7ppR7KXNqT/+RO33CtKSWjOKvbTVj9JWP0pb/VhaUi8tqZe2+qEZxa4Zxa6dqN21E7W7dqJ2107U7tqJ2n1rqx9bW/3Y2px6a6sfjzCKjy1IS2rNKHbNKHbNKHbNKA7NKA7NKA7NKI4bNqe+WtMKwp79GDfs2Y9xw1Y/xg1b/Rg3bPVjaEZxaEZxNGz1Y2jnZA7tnMzRtKRuWlJrRnFoRnFoRnFoRnFoRnFoRnF0Lam7ltTaOYpDO0dxaOcoDu0cxaGdozi0cxSHdo7i0M5RHJpRHJpRHENL6qEl9dCSemhJPbSkDi2pQ0vq0JJaO0dxaOcoDs0oDs0oDs0oDs0oDs0oDs0oDs0oDs0ojqkl9dSSempJPbWk1s5RHNo5ikM7R3Fo5ygO7RzFoZ2jODSjODSjOFJL6tSSOrWkTi2pU0tqzSgOzSiO0pJaO0dxaOcojtKSurSk1ozi0Izi0Izi0Izi0Izi0IziWFpSLy2ptXMUh3aO4tDOURzaOYpDO0dxaOcoDu0cxaGdozg0ozg0ozi2ltRbS+qtJfXWknpjSR03LKnjhiV13LCkDu0cxbhhSR2aUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRjE0oxiaUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRjE0oxiaUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRjE0oxiaUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRnFqRnFqRnFqRnFqRnHesKSemlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlFMzSimZhRTM4qpGcW8YUmdmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnF1IxiakYxNaOYmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnF1IxiakYxNaOYmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnF1IxiakYxNaOYmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnF1IxiakaxNKNYmlEszSiWZhTrhiV1aUaxNKNYmlEszSiWZhRLM4qlGcXSjGJpRrE0o1iaUSzNKJZmFEsziqUZxdKMYmlGsTSjWJpRLM0olmYUSzOKpRnF0oxiaUaxNKNYmlEszSiWZhRLM4qlGcXSjGJpRrE0o1iaUSzNKJZmFEsziqUZxdKMYmlGsTSjWJpRLM0olmYUSzOKpRnF0oxiaUaxNKNYmlEszSiWZhRLM4qlGcXSjGJpRrE0o1iaUSzNKJZmFEsziqUZxdKMYmlGsTSjWJpRLM0olmYUSzOKpRnF0oxiaUaxNKNYmlEszSiWZhRLM4qlGcXSjGJpRrE0o1iaUSzNKJZmFEsziqUZxdKMYmlGsTSjWJpRLM0olmYUSzOKpRnFpRnFpRnFpRnFpRnFdcOSemlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWlGcWtGcWtGcWtGcWtGcd+wpN6aUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyaUdyYUZw3zCheBVlJfRVkJfVVkJXUV0FWUl8FWUl9FWQl9VWQldRXQVZSXwVpSY0ZxasgLakxo3gVpCU1ZhSvgrSkxoziVZCW1JhRvArSkhozildBWlJjRvEqSEtqzCheBWlJjRnFqyAtqTGjeBWkJTVmFK+CtKTGjOJVkJbUmFG8CtKSGjOKV0FaUmNG8SpIS2rMKF4FaUmNGcWrIC2pMaN4FaQlNWYUr4K0pMaM4lWQltSYUbwK0pIaM4pXQVpSY0bxKkhLaswoXgVpSY0ZxasgLakxo3gVpCU1ZhSvgrSkxoziVZCW1JhRvArSkhozildBWlJjRvEqSEtqzCheBWlJjRnFqyAtqTGjeBWkJTVmFK+CtKTGjOJVkJbUmFG8CtKSGjOKV0FaUmNG8SpIS2rMKF4FaUmNGcWrIC2pMaN4FaQlNWYUr4K0pMaM4lWQltSYUbwKwpK6aUaxaUaxaUaxaUax3bCkbppRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpRbJpR7JpR7JpR7JpR7JpR7DcsqbtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFLtmFIdmFIdmFIdmFIdmFK/WtIKwpB6aURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaURyaUQzNKIZmFEMziqEZxbhhSR2aUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRjE0oxiaUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRjE0oxiaUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRjE0oxiaUQzNKIZmFEMziqEZxdCMYmhGMTSjGJpRDM0ohmYUQzOKoRnF0IxiaEYxNKMYmlEMzSiGZhRDM4qhGcXQjGJoRnFqRnFqRnFqRnFqRnHesKSemlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlGcmlFMzSimZhRTM4qpGcW8YUmdmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnF1IxiakYxNaOYmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSMYmpGMTWjmJpRTM0opmYUUzOKqRnF1IxiakYxNaOYmlFMzSimZhRTM4qpGcXUjGJqRjE1o5iaUUzNKKZmFFMziqkZxdSM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pMaM4lUQltRNM4pNM4pNM4pNM4rthiV104xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi04xi14xi14xi14xi14xiv2FJ3TWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2DWj2CWjeP3j3//zD3/84x/+1//445//49/+8oc//+m/Pl16+/Q/b88CalX/9e3WtU7x+nar3mj7yxdfU+UvX/zpw4jTDczTDeTpBup0A+t0A/twA2//1npkA+10A/10A6dHcj89kvvpkdxPj+R+eiT30yO5nx7J4/RIHqdH8jg9ksfpkTxOj+RxeiSP0yN5nB7J4/RIHqdHcvzzI3mM/TJtHVXt9cUt8o1XX4t642X6PG9/++pP9TSsno7VM7B6AqtnYvUkVk9h9Sysnm3VM7F8nlg+TyyfJ5bPE8vnieXzxPJ5Yvk8sXyeWD4nls+J5XNi+ZxYPieWz4nlc2L5nFg+J5bPieVzYflcWD4Xls+F5XNh+VxYPheWz4Xlc2H5XFg+LyyfF5bPC8vnheXzwvJ5Yfm8sHxeWD4vLJ8Xls8by+eN5fPG8nlj+byxfN5YPm8snzeWzxvL543l8z84AvT3LOhsQv/SxANCt/ZLL8a69a+bGOebiPNNzPNN5Pkm6nwT68FN7K+b2MebaLfzTTxgdK/83ER9/bNo/XwT43wTcb6Jeb6JPN/EA8bF2i/KZuy2vmriAfDg3Sb++Tsqcu5fXxy5xtdNxPkm5vkm8nwT7/6+6F/MW37FL+8/lP/WRfuOi95/eP6ti9o9F/V7Lhr3XBT3XDTvuSjvueieO2Lcc0eM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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"lookup_validity","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"consumer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"field"},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(noinitcheck)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2dB3xURbTGN7sbCBAIvZelg4juTY8NkKZiw4ZdUwGlCUFF7A0VG6AiNlTsDVEQFVERFVGxYQMLFrCADbAr+M6EGXMYbxJIzuzu997b3+9jZ4d7z/2fuZP5br9JgW2fwcmBwPTkbeUkUkh/B0kRq85883Itn+lSfeoa+NQ19Klr7FPXgtTXquvgM13Ep66jT10nn7puuo5/kvR3X/2dEc3OzCzOSS/2Mrz8aHpeQW5WNDOrIDvXy/WycrOK0nMzMopzM3Nz8grycqJ5XmZGsVeSlZdREt32eSRYHitao096oUvOuWKc0ahLzkerzel5do3pZ2HGqtbXVl3uHigvz2X1j+qymW8e/X6M9DhpfnBbvV/seSzGY6z8OCvPt2IvoN9PkBaSnqwk9gIW4wlWXsjKT1qxn6LfT5MWkZ6pJPZTLMbTrLyIlZ+xYi+m38+SniM9X0nsxSzGs6z8HCs/b8VeQr9fIC0lvVhJ7CUsxgusvJSVX7Riv0S/XyYtI71SSWzeT14K7lg/WU6/XyW9Rnq9ktjLWYxXWfk1Vn7dir2Cfr9BepP0ViWxV7AYb7Dym6z8lhX7bfr9Dmkl6d1KYr/NYrzDyitZ+V0r9nv0+33SB6QPK4n9HovxPit/wMofWrFX0e/VpI9IH1cSexWLsZqVP2Llj63Yn9DvT0lrSJ8Fy+vNJ6i/++rvaM0+XreA3Bj6udxY73E/VXEjVjskCbdDWLAdKuOsaewv5Hy/2CXnl9XnzLIr/P62vmB/Q+pjyu1Y+Uvrb2st/V5H+or0tc/fVki4T7UXjLU2KLduvgm62SaTbr/ugrHWCbbft4Lt59e3v2F9+1tW/oqVv7b69nr6vYH0Hel73beTWcyKPn2F2rc2i/mDNqkf9fdP+nuj/t6kvzfr75+Dge13oH72GfBt46vpSkwSTH5jMDY7OdGafbzNQdn2SwmU/9En6RVvOuiPrPyTLmeTfqHyr8FtnTMc8O+c0nn/IvwHaz6/BR0Cq+DScX8Pym7luMj792B5AwvFjcays/3qqLP9EXQI/IeDzvZngnc2lfefDjqbH2tN8/9ds0rH/Ut4l00drg0FfNo000tPz/AycwgtSoxFhbnpxbn5WVn5eVnpRZlFJenR9KzskuIosRXlZeZRdaZXmB+NlkTzC0q8rK12vPzcQso6O1oUpX9KsopyKe3MvKLM3JKMaGZmUTTby4wW5OUWF+V4Ofl5BVkZ6fkl2RnRQi8rI5qT520VXucq96Bf3jVsU2lOFe9vAt2iHFm7cLLFbj7Sf29bHW0lCbd5Om+Lf8wP+7yF+o8tVp0q2A4jvU+0VWBQLS7Z9vlHcoAOuVm50se7JHNOYjl7uRnp6TkZarrcoqiXWVSYnpueXlSQGS2M5hemF+dlenklmemZGYVFhQUUM98riZbkF+aV5G7jiuUWSlLIzRZKMOQQOBiSjxsKJfYWiso7xOxUKK6TLZSAZpWOGxburGawVnFd7r795WBrLTnktg9Ea/Yp26J2kXetBM/b1dZ5beG+X1/nrvqROTZTi5Vr679fpb/Z8ZstrGw2clLouw6pbii2x3J+drR7XS/kELieA/NKTXDzUnmnOjKvijpXTduhvtwfXIZLzgbV58ywK/zOQNRng8Im9sefwuobhLY/A5FGvxuSGpEah9yfuf5ccEu+SUhwoy1QvpGh4kYC5bvYsRgg1zsYIPnJkqaUUzNSc1ILUktSK1JrUhtSW1I7UntSB5U/qSOpE6kzqQupK6kbqTupB6knaRdSL9KupN6k3Ui7k6Ikj5ROyiBlkrJI2aQcUi4pj7QHaU/SXqS9SfuQ+qj1SupH2pfUnzSANJA0iDSYtB9pf9IBpCGkA0kHkQ4mHUI6lDSUdBjp8FAgtsdMmobcDJwBSU4vGuVtcYQe9I+0j5mo//jVqlMTpVhQIYeNWLNjJlHvCEHXPRLkmIlkzkdtF4umzU/PzC7OimYX59LR2ryckqycaGF+SUlRTjSzsCBaUJCZHc3wMkoKctKjBel5tNi84qzCsksuY3rM5ChHx0yGhRwCD3Ow2Xl0gm92qryPdrTZKb0Zd6RmlY57jKNjJipunUBsHbAZoAMeq/vfcbYDHuvjgMfFwAGbCTrgsYIDwHEgDiiZ8/GgDni8Iwc8IeQQ+AQHDnhigjugyvtEEAc8TrNKxz3JkQOeFAcHbA7ogCfr/pdvO+DJPg6YHwMHbC7ogCcLDgD5IA4omXMBqAMWOHLAwpBD4EIHDliU4A6o8i4CccB8zSodt9iRAxbHwQFbADpgie5/w20HLPFxwOExcMAWgg5YIjgADAdxQMmcR4A64AhHDjgy5BB4pAMHPCXBHVDlfQqIAw7XrNJxT3XkgKfGwQFbAjrgKN3/RtsOOMrHAUfHwAFbCjrgKMEBYDSIA0rmPAbUAcc4csCxIYfAYx044LgEd0CV9zgQBxytWaXjnubIAU+LgwO2AnTA8br/TbAdcLyPA06IgQO2EnTA8YIDwAQQB5TMuRTUAUsdOeDEkEPgiQ4c8PQEd0CV9+kgDjhBs0rHPcORA54RBwdsDeiAZ+r+N8l2wDN9HHBSDBywtaADnik4AEwCcUDJnM8CdcCzHDng5JBD4MkOHPDsBHdAlffZIA44SbNKxz3HkQOeEwcHbAPogOfq/nee7YDn+jjgeTFwwDaCDniu4ABwHogDSuZ8PqgDnu/IAS8IOQS+wIEDXpjgDqjyvhDEAc/TrNJxL3LkgBfFwQHbAjrgxbr/XWI74MU+DnhJDBywraADXiw4AFwC4oCSOV8K6oCXOnLAKSGHwFMcOOBlCe6AKu/LQBzwEs0qHfdyRw54eRwcsB2gA16h+99U2wGv8HHAqTFwwHaCDniF4AAwFcQBJXO+EtQBr3TkgFeFHAJf5cABr05wB1R5Xw3igFM1q3Tcaxw54DVxcMD2gA54re5/02wHvNbHAafFwAHbCzrgtYIDwDQQB5TMeTqoA0535IAzQg6BZzhwwOsS3AFV3teBOOA0zSod93pHDnh9HBywA6AD3qD730zbAW/wccCZMXDADoIOeIPgADATxAElc74R1AFvdOSAs0IOgWc5cMCbEtwBVd43gTjgTM0qHfdmRw54cxwcMALogLfo/ner7YC3+DjgrTFwwIigA94iOADcCuKAkjnfBuqAtzlywNkhh8CzHTjg7QnugCrv20Ec8FbNKh33DkcOeEccHLAjoAPeqfvfHNsB7/RxwDkxcMCOgg54p+AAMAfEASVzvgvUAe9y5IB3hxwC3+3AAe9JcAdUed8D4oBzNKt03HsdOeC9cXDAToAOeJ/uf/fbDnifjwPeHwMH7CTogPcJDgD3gzigZM4PgDrgA44c8MGQQ+AHHTjgQwnugCrvh0Ac8H7NKh33YUcO+HAcHLAzoAM+ovvfXNsBH/FxwLkxcMDOgg74iOAAMBfEASVzfhTUAR915IDzQg6B5zlwwMcS3AFV3o+BOOBczSod93FHDvh4HBywC6ADztf9b4HtgPN9HHBBDBywi6ADzhccABaAOKBkzk+AOuATjhxwYcgh8EIHDvhkgjugyvtJEAdcoFml4z7lyAGfioMDdgV0wKd1/1tkO+DTPg64KAYO2FXQAZ8WHAAWgTigZM7PgDrgM44ccHHIIfBiBw74bII7oMr7WRAHXKRZpeM+58gBn4uDA3YDdMDndf9bYjvg8z4OuCQGDthN0AGfFxwAloA4oGTOL4A64AuOHHBpyCHwUgcO+GKCO6DK+0UQB1yiWaXjvuTIAV+KgwN2B3TAl3X/W2Y74Ms+DrgsBg7YXdABXxYcAJaBOKBkzq+AOuArjhxwecgh8HIHDvhqgjugyvtVEAdcplml477myAFfi4MD9gB0wNd1/1thO+DrPg64IgYO2EPQAV8XHABWgDigZM5vgDrgG44c8M2QQ+A3HTjgWwnugCrvt0AccIVmlY77tiMHfDsODtgT0AHf0f1vpe2A7/g44MoYOGBPQQd8R3AAWAnigJI5vwvqgO86csD3Qg6B33PggO8nuAOqvN8HccCVmlU67geOHPCDODjgLoAO+KHuf6tsB/zQxwFXxcABdxF0wA8FB4BVIA4omfNqUAdc7cgBPwo5BP7IgQN+nOAOqPL+GMQBV2lW6bifOHLAT+LggL0AHfBT3f/W2A74qY8DromBA/YSdMBPBQeANSAOKJnzZ6AO+JkjB/w85BD4cwcO+EWCO6DK+wsQB1yjWaXjfunIAb+MgwPuCuiAa3X/W2c74FofB1wXAwfcVdAB1woOAOtAHFAy569AHfArRw74dcgh8NcOHPCbBHdAlfc3IA64TrNKx/3WkQN+GwcH7A3ogOt1/9tgO+B6HwfcEAMH7C3ogOsFB4ANIA4omfN3oA74nSMH/D7kEPh7Bw74Q4I7oMr7BxAH3KBZpeP+6MgBf4yDA+4G6IA/6f630XbAn3wccGMMHHA3QQf8SXAA2AjigJI5bwJ1wE2OHHBzyCHwZgcO+HOCO6DK+2cQB9yoWaXj/uLIAX+JgwPuDuiAv+r+95vtgL/6OOBvMXDA3QUd8FfBAeA3EAeUzPl3UAf83ZED/hFyCPyHAwf8M8EdUOX9J4gD/qZZpeP+5cgB/4qDA0YBHfBv3f+22A74t48DbomBA0YFHfBvwQFgC4gDSua8FdQBtzpywH9CDoH/ceCAqsWlOoOrvMt6hWxcJw64RbNKx00Ku3FAFTfWDugBOmBQ97+QGZ1MA6r/sB1QTeTaAT1BBwwKDgChMIYDSuYcDmM6YDjsxgGTww6Bk8PycWsluAOqvGuBOGBIs0rHre3IAWvHwQHTAR0wRfe/OrYDpvg4YJ0YOGC6oAOmCA4AdUAcUDLnuqAOWNeRA9YLOwSu58ABUxPcAVXeqSAOWEezSset78gB68fBATMAHbCB7n9ptgM28HHAtBg4YIagAzYQHADSQBxQMueGoA7Y0JEDNgo7BG7kwAEbJ7gDqrwbgzhgmmaVjtvEkQM2iYMDZgI6YFPd/5rZDtjUxwGbxcABMwUdsKngANAMxAElc24O6oDNHTlgi7BD4BYOHLBlgjugyrsliAM206zScVs5csBWcXDALEAHbK37XxvbAVv7OGCbGDhglqADthYcANqAOKBkzm1BHbCtIwdsF3YI3M6BA7ZPcAdUebcHccA2mlU6bgdHDtghDg6YDeiAEd3/OtoOGPFxwI4xcMBsQQeMCA4AHUEcUDLnTqAO2MmRA3YOOwTu7MABuyS4A6q8u4A4YEfNKh23qyMH7BoHB8wBdMBuuv91tx2wm48Ddo+BA+YIOmA3wQGgO4gDSubcA9QBezhywJ5hh8A9HTjgLgnugCrvXUAcsLtmlY7by5ED9oqDA+YCOuCuuv/1th1wVx8H7B0DB8wVdMBdBQeA3iAOKJnzbqAOuJsjB9w97BB4dwcOGE1wB1R5R0EcsLdmlY7rOXJALw4OmAfogOm6/2XYDpju44AZMXDAPEEHTBccADJAHFAy50xQB8x05IBZYYfAWQ4cMDvBHVDlnQ3igBmaVTpujiMHzImDA+4B6IC5uv/l2Q6Y6+OAeTFwwD0EHTBXcADIA3FAyZz3AHXAPRw54J5hh8B7OnDAvRLcAVXee4E4YJ5mlY67tyMH3DsODrgnoAPuo/tfH9sB9/FxwD4xcMA9BR1wH8EBoA+IA0rm3BfUAfs6csB+YYfA/Rw44L4J7oAq731BHLCPZpWO29+RA/aPgwPuBeiAA3T/G2g74AAfBxwYAwfcS9ABBwgOAANBHFAy50GgDjjIkQMODjsEHuzAAfdLcAdUee8H4oADNat03P0dOeD+cXDAvQEd8ADd/4bYDniAjwMOiYED7i3ogAcIDgBDQBxQMucDQR3wQEcOeFDYIfBBDhzw4AR3QJX3wSAOOESzSsc9xJEDHhIHB9wH0AEP1f1vqO2Ah/o44NAYOOA+gg54qOAAMBTEASVzPgzUAQ9z5ICHhx0CH+7AAY9IcAdUeR8B4oBDNat03CMdOeCRcXDAPoAOeJTuf8NsBzzKxwGHxcAB+wg64FGCA8AwEAeUzPloUAc82pEDHhN2CHyMAwc8NsEdUOV9LIgDDtOs0nGPc+SAx8XBAfsCOuDxuv+dYDvg8T4OeEIMHLCvoAMeLzgAnADigJI5nwjqgCc6csCTwg6BT3LggCcnuAOqvE8GccATNKt03HxHDpgfBwfsB+iABbr/FdoOWODjgIUxcMB+gg5YIDgAFII4oGTORaAOWOTIAYvDDoGLHThgSYI7oMq7BMQBCzWrdNzhjhxweBwccF9ABxyh+99I2wFH+DjgyBg44L6CDjhCcAAYCeKAkjmfAuqApzhywFPDDoFPdeCAoxLcAVXeo0AccKRmlY472pEDjo6DA/YHdMAxuv+NtR1wjI8Djo2BA/YXdMAxggPAWBAHlMx5HKgDjnPkgKeFHQKf5sABxye4A6q8x4M44FjNKh13giMHnBAHBxwA6ICluv9NtB2w1McBJ8bAAQcIOmCp4AAwEcQBJXM+HdQBT3fkgGeEHQKf4cABz0xwB1R5nwnigBM1q3TcSY4ccFIcHHAgoAOepfvfZNsBz/JxwMkxcMCBgg54luAAMBnEASVzPhvUAc925IDnhB0Cn+PAAc9NcAdUeZ8L4oCTNat03PMcOeB5cXDAQYAOeL7ufxfYDni+jwNeEAMHHCTogOcLDgAXgDigZM4XgjrghY4c8KKwQ+CLHDjgxQnugCrvi0Ec8ALNKh33EkcOeEkcHHAwoANeqvvfFNsBL/VxwCkxcMDBgg54qeAAMAXEASVzvgzUAS9z5ICXhx0CX+7AAa9IcAdUeV8B4oBTNKt03KmOHHBqHBxwP0AHvFL3v6tsB7zSxwGvioED7ifogFcKDgBXgTigZM5Xgzrg1Y4c8JqwQ+BrHDjgtQnugCrva0Ec8CrNKh13miMHnBYHB9wf0AGn6/43w3bA6T4OOCMGDri/oANOFxwAZoA4oGTO14E64HWOHPD6sEPg6x044A0J7oAq7xtAHHCGZpWOO9ORA86MgwMeAOiAN+r+N8t2wBt9HHBWDBzwAEEHvFFwAJgF4oCSOd8E6oA3OXLAm8MOgW924IC3JLgDqrxvAXHAWZpVOu6tjhzw1jg44BBAB7xN97/ZtgPe5uOAs2PggEMEHfA2wQFgNogDSuZ8O6gD3u7IAe8IOwS+w4ED3pngDqjyvhPEAWdrVum4cxw54Jw4OOCBgA54l+5/d9sOeJePA94dAwc8UNAB7xIcAO4GcUDJnO8BdcB7HDngvWGHwPc6cMD7EtwBVd73gTjg3ZpVOu79jhzw/jg44EGADviA7n8P2g74gI8DPhgDBzxI0AEfEBwAHgRxQMmcHwJ1wIccOeDDYYfADztwwEcS3AFV3o+AOOCDmlU67lxHDjg3Dg54MKADPqr73zzbAR/1ccB5MXDAgwUd8FHBAWAeiANK5vwYqAM+5sgBHw87BH7cgQPOT3AHVHnPB3HAeZpVOu4CRw64IA4OeAigAz6h+99C2wGf8HHAhTFwwEMEHfAJwQFgIYgDSub8JKgDPunIAZ8KOwR+yoEDPp3gDqjyfhrEARdqVum4ixw54KI4OOChgA74jO5/i20HfMbHARfHwAEPFXTAZwQHgMUgDiiZ87OgDvisIwd8LuwQ+DkHDvh8gjugyvt5EAdcrFml4y5x5IBL4uCAQwEd8AXd/5baDviCjwMujYEDDhV0wBcEB4ClIA4omfOLoA74oiMHfCnsEPglBw74coI7oMr7ZRAHXKpZpeMuc+SAy+LggIcBOuAruv8ttx3wFR8HXB4DBzxM0AFfERwAloM4oGTOr4I64KuOHPC1sEPg1xw44OsJ7oAq79dBHHC5ZpWOu8KRA66IgwMeDuiAb+j+96btgG/4OOCbMXDAwwUd8A3BAeBNEAeUzPktUAd8y5EDvh12CPy2Awd8J8EdUOX9DogDvqlZpeOudOSAK7UD2s4nvQ7XB+X4IzrOu8T+Hul90gekD0mrSKtJH5E+Jn1C+pS0hvQZ6XPSF6QvSWtJ60hfkb4mfUP6lrSetIH0Hel70g+kH0k/kTaSNpE261GKt+W72vh43Xs+de/71H3gU/ehT90qn7rVPnUf+dR97FP3iU/dpz51a3zqPvOp+9yn7gufui996tb61K3zqfvKp+5rn7pvfOq+9alb71O3wafuO5+6733qfvCp+9Gn7iefuo0+dZt86jb7bGSZIbKv/o7W7LPd32xNx693w3IbbO8J+lW3ZDcbbPa6qEnOal28L9J+29brBzWPla7bz/tQcF10T+R1kfkvp7eqZjlHWc7e6prESt+u/byPBNdFj8RcF1GL0/u4mjlnl/wnZ++T6sXK9Wk/71PBddEz0dZFri+nt2bnc86pIGfvs52NlVNh+3mfC66LXRJnXaRXwul9sTM551Sas/fljscqrKL9vLWC66JXIqyLnCo5vXU7lnN0B3L2vtqRWNEdaj/va8F1sWt810XWDnJ631SVc+YO5+x9W2mszJKdaD9vveC66B2vdZGzU5zehopzzt3JnL3vKoiVV7LT7ed9L7gudov9uohWg9P7wS/naLVy9n78byyvmu3n/SS4LnaP5booqjant3H7nDNqkLO3icVKL6lR+3mbBddFNEbrIlqzjyd4fMAT3L/1+P5ZTdeFB7IuBPeDPMHteK+X4LpIB1kXgtt7nuD2ireb4LrIAFkXgr7mCY7Lnie4LjIdrQvpCxME/349wf7nSbafOv9QO6DPddA5gq26/CMrHxkqP2dxHCvns/JwVh7NyhNYeRIrn8fKl7DyVFaexsozWflWVp7Dyvez8lxWXsDKi1h5CSsvY+UVrLySlVex8hpWXsfKG1h5Iyv/xspbWDnEzgfVYeU0Vm7Gym1YuSMrd2fl3qycwcp5rNyHlQey8hBWHsrKw1j5BFYuZOWRrDyWlSey8mRWvoCVp7DyVaw8g5VnsfJsVr6blR9k5XmsvJCVF7PyUlZezsrmwqdIYNuHn6ezz+Px83z8PCA/T8jPI/LzjPw8JD9Pyc9j8vOc/DwoP0/Kz6Py86z8PCw/T8vP4/LzvPw8MD9PzM8j8/PM/Dw0P0/Nz2Pz89z8PDg/T87Po/Pz7OY8/M/GaNn6UJ+++jtas4/3s+D+kLrwSXlRMFDxR4o7ibWF9DLyC2gnM78o0ze4vQJq2mi/hOWAFVuLQPnGmfr9CDM0tSxTnsvqH9VlM9+vVPiN9Dvpj3D51Wx27F9ZvN9Y+XdW/iO8few/qfAX6W/Slkpi/8li/MXKf7PyFiv2Vir8o35QT0xKrjj2VhbjH1ZW85lyUvL2sYP0O6RikpIriR1kMUKsHGblZCt2Lfpdm5RCqlNJ7FosRm1WTmHlOlbsuvS7HimVVL+S2Lyf1E3esX7SgKZLIzUkNaokdgMWL42VG7JyI4u7Mf1uQmpKalZJ7MYsRhNWbsrKzazYzel3C1JLUqtKYjdnMVqwcktWbmXFbk2/25DaktpVErs1i9GGlduycjsrdnv63YEUIXWsJHZ7FqMDK0dYuaMVuxP97kzqQuqaXF5vPvbVuxIXWZpY0Zp9vB4BNztW0jknCebcEyTnoGDOu4DkHBLMuZejnKU3JHcNyI4NFa2baM0+Xm9Bzk+CsemP0Zp9vN0Ec+6UjNEfdw9gcEZBOD0QznRhTmm+FDKH1JD8fuSAZLd515RP5ZzmIO+BICc4MgRzTpG7/dIT7Deeq3Uh7YeZguvi8yDGuJgVwODMBuHMAeHMBeHMA+HcA4RzTxDOvUA49wbh3AeEsw8IZ18Qzn4gnPuCcPYH4RwAwjkQhHMQCOdgEM79QDj3B+E8AIRzCAjngSCcB4FwHgzCeQgI56EgnENBOA8D4TwchPMIEM4jQTiPAuEcBsJ5NAjnMSCcx4JwHgfCeTwI5wkgnCeCcJ4EwnkyCGc+CGcBCGchCGcRCGcxCGcJCOdwEM4RIJwjQThPAeE8FYRzFAjnaBDOMSCcY0E4x4FwngbCOR6EcwIIZykI50QQztNBOM8A4TwThHMSCOdZIJyTQTjPBuE8B4TzXBDO80A4zwfhvACE80IQzotAOC8G4bwEhPNSEM4pIJyXgXBeDsJ5BQjnVBDOK0E4rwLhvBqE8xoQzmtBOKeBcE4H4ZwBwnkdCOf1IJw3gHDOBOG8EYRzFgjnTSCcN4Nw3gLCeSsI520gnLNBOG8H4bwDhPNOEM45IJx3gXDeDcJ5DwjnvSCc94Fw3g/C+QAI54MgnA+BcD4MwvkICOdcEM5HQTjngXA+BsL5OAjnfBDOBSCcT4BwLgThfBKE8ykQzqdBOBeBcD4DwrkYhPNZEM7nQDifB+FcAsL5AgjnUhDOF0E4XwLhfBmEcxkI5ysgnMtBOF8F4XwNhPN1EM4VIJxvgHC+CcL5Fgjn2yCc74BwrgThfBeE8z0QzvdBOD8A4fwQhHMVCOdqEM6PQDg/BuH8BITzUxDONSCcn4Fwfg7C+QUI55cgnGtBONeBcH4Fwvk1COc3IJzfgnCuB+HcAML5HQjn9yCcP4Bw/gjC+RMI50YQzk0gnJtBOH8G4fwFhPNXEM7fQDh/B+H8A4TzTxDOv0A4/wbh3ALCuRWE8x8QThUQgTMJhDMIwhkC4QyDcCaDcNYC4awNwpkCwlkHhLMuCGc9EM5UEM76IJwNQDjTQDgbgnA2AuFsDMLZBISzKQhnMxDO5iCcLUA4W4JwtgLhbA3C2QaEsy0IZzsQzvYgnB1AOCMgnB1BODuBcHYG4ewCwtkVhLMbCGd3EM4eIJw9QTh3AeHsBcK5KwhnbxDO3UA4dwfhjIJweiCc6SCcGSCcmSCcWSCc2SCcOSCcuSCceSCce4Bw7gnCuRcI594gnPuAcPYB4ewLwtkPhHNfEM7+IJwDQDgHgnAOAuEcDMK5Hwjn/iCcB4BwDgHhPBCE8yAQzoNBOA8B4TwUhHMoCOdhIJyHg3AeAcJ5JAjnUSCcw0A4jwbhPAaE81gQzuNAOI8H4TwBhPNEEM6TQDhPBuHMB+EsAOEsBOEsAuEsBuEsAeEcDsI5AoRzJAjnKSCcp4JwjgLhHA3COQaEcywI5zgQztNAOMeDcE4A4SwF4ZwIwnk6COcZIJxngnBOAuE8C4RzMgjn2SCc54BwngvCeR4I5/kgnBeAcF4IwnkRCOfFIJyXgHBeCsI5BYTzMhDOy0E4rwDhnArCeSUI51UgnFeDcF4DwnktCOc0EM7pIJwzQDivA+G8HoTzBhDOmSCcN4JwzgLhvAmE82YQzltAOG8F4bwNhHM2COftIJx3gHDeCcI5B4TzLhDOu0E47wHhvBeE8z4QzvtBOB8A4XwQhPMhEM6HQTgfAeGcC8L5KAjnPBDOx0A4HwfhnA/CuQCE8wkQzoUgnE+CcD4Fwvk0COciEM5nQDgXg3A+C8L5HAjn8yCcS0A4XwDhXArC+SII50sgnC+DcC4D4XwFhHM5COerIJyvgXC+DsK5AoTzDRDON0E43wLhfBuE8x0QzpUgnO+CcL4Hwvk+COcHIJwfgnCuAuFcDcL5EQjnxyCcn4BwfgrCuQaE8zMQzs9BOL8A4fwShHMtCOc6EM6vQDi/BuH8BoTzWxDO9SCcG0A4vwPh/B6E8wcQzh9BOH8C4dwIwrkJhHMzCOfPIJy/gHD+CsL5Gwjn7yCcf4Bw/gnC+RcI598gnFtAOLeCcP4DwhkIYnAmgXAGQThDIJxhEM5kEM5aIJy1QThTQDjrgHDWBeGsB8KZCsJZH4SzAQhnGghnQxDORiCcjUE4m4BwNgXhbAbC2RyEswUIZ0sQzlYgnK1BONuAcLYF4WwHwtkehLMDCGcEhLMjCGcnEM7OIJxdQDi7gnB2A+HsDsLZA4SzJwjnLiCcvUA4dwXh7A3CuZsjzqDFmRHNzswszkkv9jK8/Gh6XkFuVjQzqyA718v1snKzitJzMzKKczNzc/IK8nKieV5mRrFXkpWXUaJjdxPMefcY5Ryt2ceLBuXar0kIoz96IH836SCcGSCcmSCcWSCc2SCcOSCcuSCceSCce4Bw7gnCuRcI594gnPuAcPYB4ewLwtkPhHNfEM7+IJwDQDgHgnAOAuEcDMK5Hwjn/iCcB4BwDgHhPBCE8yAQzoNBOA8B4TwUhHMoCOdhIJyHg3AeAcJ5JAjnUSCcw0A4jwbhPAaE81gQzuNAOI8H4TwBhPNEEM6TQDhPBuHMB+EsAOEsBOEsAuEsBuEsAeEcDsI5AoRzJAjnKSCcp4JwjgLhHA3COQaEcywI5zgQztNAOMeDcE4A4SwF4ZwIwnk6COcZIJxngnBOAuE8C4RzMgjn2SCc54BwngvCeR4I5/kgnBeAcF4IwnkRCOfFIJyXgHBeCsI5BYTzMhDOy0E4rwDhnArCeaUjzqDFWdP7oJMFc74KJOdagjlfDZJzbcGcrwHJOUUw52tBcq4jmPM0kJzrCuY8HSTneoI5zwDJOVUw5+tAcq4vmPP1IDk3EMz5BpCc0wRzngmSc0PBnG8EybmRYM6zQHJuLJjzTSA5NxHM+WaQnJsK5nwLSM7NBHO+FSTn5oI53waScwvBnGeD5NxSMOfbQXJuJZjzHSA5txbM+U6QnNsI5jwHJOe2gjnfBZJzO8Gc7wbJub1gzveA5NxBMOd7QXKOCOZ8H0jOHQVzvh8k506COT8AknNnwZwfBMm5i2DOD4Hk3FUw54cFc1bXA4R1rB4s/yTdBiH9/+r8uTqfrM6vqvON6vybOh+lzs+o8xXq+L06nq2O76rjner4nzoepo4PqeMl6viB2p9W+5dqf0vtf6jtcbV9qrbX1PaL8nPlbxGSGv/UeKD+PlR/Ue2nngXfnTFeGizn7knahdSLtCupN2k30u6qjUgeKV2tR1ImKYuUTcoh5ZLySHuQ9iTtRdqbtA+pj15v/Uj7kvqTBpAGkgaRBpP2I+1POoA0hHQg6SDSwaRDSIeShpIOIx1OOoJ0JOko0jDS0aRjSMeSjiMdTzqBdCLpJNLJpHxSAamQVEQqJpWQhpNGkEaSTiGdShpFGk0aQxpLGkc6jTSeNIFUSppIOp10BulM0iTSWaTJpLNJ55DOJZ1HOp90AelC0kWki0mXqPYnTSFdRrqcdAVpKulK0lWkq0nXkK4lTSNNJ80gXUe6nnQDaSbpRtIs0k2km0m3kG4l3UaaTbqddAfpTtIc0l2ku0n3kO4l3Ue6n/QA6UHSQ6SHSY+Q5pIeJc0jPUZ6nDSftID0BGkh6UnSU6SnSYtIz5AWk54lPUd6nrSE9AJpKelF0kukl0nLSK+QlpNeJb1Gep20gvQG6U3SW6S3Se+QVpLeJb1Hep/0AelD0irSatJHpI9Jn5A+Ja0hfUb6nPQF6UvSWtI60lekr0nfkL4lrSdtIH1H+p70A+lH0k+kjaRNpM2kn0m/kH4l/Ub6nfQH6U/SX6S/SVtIW0n/kNRgkEQKkkKkMCmZVItUm5RCqkOqS6pHSiXVJzUgpZEakhqRGpOakJqSmpGak1qQWpJakVqT2pDaktqR2pM6kCKkjqROpM6kLqSupG6k7qQepJ6kXUi9SLuSepN2I+1OUoOcR0onZZAySVmkbFIOKZeUR9qDtCdpL9LepH1IfUh9Sf1I+5L6kwaQBpIGkQaT9iPtTzqANIR0IOkg0sGkQ0iHkoaSDiMdTjqCdCTpKNIw0tGkY0jHko4jHU86gXQi6STSyaR8UgGpkFREKiaVkIaTRpBGkk4hnUoaRRpNGkMaSxpHOo00njSBVEqaSDqddAbpTNIk0lmkyaSzSeeQziWdRzqfdAHpQtJFpItJl5AuJU0hXUa6nHQFaSrpStJVpKtJ15CuJU0jTSfNIF1Hup50A2km6UbSLNJNpJtJt5BuJd1Gmk26nXQH6U7SHNJdpLtJ95DuJd1Hup/0AOlB0kOkh0mPkOaSHiXNIz1Gepw0n7SA9ARpIelJ0lOkp0mLSM+QFpOeJT1Hep60hPQCaSnpRdJLpJdJy0ivkJaTXiW9RnqdtIL0BulN0lukt0nvkFaS3iW9R3qf9AHpQ9Iq0mrSR6SPSZ+QPiWtIX1G+pz0BelL0lrSOtJXpK9J35C+Ja0nbSB9R/qe9APpR9JPpI2kTaTNpJ9Jv5B+Jf1G+p30B+lP0l+kv0lbSFtJ/5DUhkASKUgKkcKkZFItUm1SCkm9l1698129T129q1y9B1y9Y1u9v1q9G1q9d1m901i9L1i9i1e951a9Q1a9n1W9+1S9V1S9s1O9D1O9a1K9x1G9I1G9fzBCUu/NU++kU+97U+9SU+8pU+8AU+/XUu+uUu+FUu9cUu8zUu8KUu/hUe+4Ue98Ue9TUe8XUe/uUO/FUO+cUO9zUO9KUO8hUM/4V8/PV8+mV899V89UV88rV88CL3vONkk9H1o9e1k911g9M1g9j1c961Y9R1Y9o1U9/1Q9W1Q9t1M9E1M9b1I9y1E9J1E9g1A93089O089l0498009T009q0w9B0w9Y0s9v0o9G0o9d0k900g9L0g9i0c95+Zkkno+i3r2iXquiHpmh3oehnrWhHqOg3pGgnr+gLq3X903r+5JV/d7q3up1X3K6h5gdX+tundV3Req7rlU9zOqewXVfXjqHjd1/5i6N0vd96TuKVL366h7YdR9JueT1P0R6t4DdV2/umZeXY+utr/UddTqGmV1/a+6tlZdt6quCVXXSKprBtU1dOqaMnWNlbrmSF2Do65JUddoqGsW1Dl8dU5bneNV5zzVOUB1TkydI1LnTNQ5BHVMXR1jVsdc1TFIdUxOHaNSx2zUMQy1T6/2cdU+n9oHUvsEahtZbQOaTztWbqu/80tLi0ePK42Ujo3kFxVFzhhZOiIy9vTi8SWjxqrNorLtUfPZW38PmjimsHTk2DERmm5kyaSTxo0feXp+afFJ+RNLR1CASGH+mMjYMaMmRQqKqTxqVHFRZEJpfulIVVbbWNttwHbT3weNnDA6v7RwRGTM2NLiyIji/KLi8ZHCsWNKx+cXliq28cUTJqit2e020TtVNveE0rHj84cXRyaMGltaNufgnWwA9XffVU83ks3bSn/3Gz8+f1Jk5Jii4jMjYyeWRsaWRArGThxTNIHPOL66M15U3RmvqO6M06o7443VnXF2dWe8p7ozPlzdGedXd8b32Iwd9TfrdaMnjiodOY7+WirseqtZgJ3ttp9Wl3pdDRb6bXUXuqkGC1Vb1NVaaJvqztipujN6bMZq9Yjs6i5536TqN/Cg6i70sBos9KjqLrSgBgstqe5Cx9dgoadXd6EX1mChl1Z3odNrsNAbqrvQO2uw0Huqu9Ana7DQF2ow78vVBX69ujOu2lnaWnqizXpGdVA0qOtUlTpo2lf/jtbs46WUs8nGzs0sUHn0TymPzT/qwG5Il8006gBwffb/A3R9iNUN1HVhVjdI1yWzusG6rhar248tx9Ttn1LexqbuAP2jjq5rzFjMvCkstvA6SU9luQTYMvgnzMq1GFOKG6bcVLacHWFKYd+13TB5qWw5hq2O1QZJAdkTGilWvuZ30Gf5gf9f9v8v+//AsoX/rstu5DDjHx+/zfKS2XKr4kxjdXzs5uxBQXYVt56jdkkNlHtSgC0jYLWB+dRj+dZ1w1S2/VDfTeyyfOvtRL71Wb6pDvNNcxM7mspy2JF801i+DRzm28hN7LJ803Yi30Ys34YO823iJnZZvo12It8mLN/GDvNt5iZ2Wb5NdiLfZizfpg7zbeEmdlm+zXYi3xYs3+YO823lJnZZvi12It9WLN+WDvNt4yZ2Wb6tdiLfNizf1nj5lsVu6yZ22XZSOxY7KMzd3gm3l6Nid3QUW/WvDoEd718dWf+KuFlPHs83EJBd/50ctWMSi23azPw27avaurNVp+brosvJej4zTSfW1l3Z9ILHFzy+fBPbLKsLy8WUT9bfaYyT901TF7ByCbIcj2F5dWPzSvdrvj7MMgIWn/l0Y0ydnTBFvXqB8n3A4cWlB9P57QlJbFmGt4XFmxT4L7uZpiGrC7Ey39f023/z28fx2w/w21b225702+by2y7x827b39SnDSu3ZWV+4QMfb83fk1+78GUFA/9tT1PPf0v+f8BhbOn/N3XhCsr2OYHK+uaOjAeqn3a3YvbVv6M1+mwbk3voWGZsNX2pO2My05yiv+3+bdh6WLmYv1cTU+0Pm3GkB8vTLMse64JsOn4dTdAnjpnHdXv11LFMe7Wx+MJsmgn6u6L26sl+8/YyMRuw/My0qYHy/taWsZyhy7YXSm4fJll5hhlLV1ZvpnmV8U1mOYVZvcmpllWXFNj+3EaY/Q6yWGZM5+dbHJ0Dijo8b5LLj5smW/nWZm1gprlYf1fUt+xjsGGrnRoEyts6FueFzE0krtqurtV2Jo86rA3MNFOraLu6FbRdbdZ2ps3qsrZzlF+6w+PXZW2XarWdyaMeawMzzfQq2i61grarw9rOtFkqaztH+WU4PBZe1nYNrLYzedRnbWCmmVVF2zWooO3qsbZLZWXTdo7yy3R4XL2s7RpabWfySGNtYKa5vYq2a1hB29Vn7WXarCFrO0f5ZTk8Rl/Wdo2ttkuz2ifMprnX+r8A+/BY6sPbzsRU7WbazEzrML9sh8f7y9rOHMc2bWfyaMLawEzziP6uqO2aVtB2jVjbmTZrytrOUX45Ds8dlLVdc6vtTB7NWBuYaRZYbWG3XfMK2q4JazvTZs1Z2/H9LeljPSHGkxQo30YKs28zzaJK8ku1mE2daSfugS1Y2Xy3ZG1g6sxxgIaszhzDbszqzP5DU1ZnmJuzOpNTM1Zn8uVMZpuxJasz20KtWJ3JszWrM75vmFTefD/C9CPDYvbr+H7ECjbtfL0zrZbVRddLj938GF/Q4jPLdHh8t2w/qyNrhzBbFj/maKZ5n3GYYz7mRm77WCU/FmRit2e/zXcHK7ZfH3d33D2q7t38N2c7364++daypomw+cw0H1WRi6vzE7zNTX+P6N+87c00ayrh5LHMfJ2snNWYYdqog/P8to2bNlPEyk9NY45N1rKm4f3RTPNVJW3g7hzYtnVlxiqzrgxfW8ZppllfCSePZeazz3k0YDmbaYOs3M7KM8jm5bGDbNoO1jyVrZ+OPqyVrR8zzWb9XdH6cXT+s+w63Ii1vCTrd5iVY3C+N4N77o4wtWZMjs7lenzbwLDVYXWBgKxftbZyNb+D/4uXrfaPIlYb83Y3/7cjjGmszvQJh3227LoJs31llqHGu9ps+8qRt6tnMvznnK5h4ds9ZppFSeXT1tPlBmyeiP5ODfzX//m2lIlrfvPjyF2s5XNGm4efm3HURmXHmju4iZ3Bt5uSrTbhY72Zpplu84o8rr3VTva6VO0b0eX2rO0c5efyGpmMnd0+aFtF27WpoO349oFpM+5ljvJLd+mTKl4rq+1MHq1ZG5hpOlfRdq0qaDt+vtG0WStWx8ce9Um1uCqKb37zcaO7Fd9h++UmWQx8v5RvU7i6llLFa8naI8yWxdefmSY9qZzDHGMIWW3J26q5FZsfUzLfza3YFW1/8jaQPEbk8LpQ32OTpp1425hpcippg7JjPvqADN/3T07Zvo1N/+WeFk5xk586ZvRZUjmf6Se1UsqX7ejYpcfb1uRvlm/aOI1Nw/tPd2s+M73fNWq1rGn4+XIzTf8q+q6j66x9j98avqaM00wzeAf7F79u2O5fZn3Go3+ZdcD7l6Njhh5vW5O/3QfS2DQRxhGx5rO3Afj4WcuaJsLmM9McXkX/cnSdt2//iujf3DfMNMN2sH/xa+Xt/uW3TR6r/mXWQazGL7t/2X2A9y9+3K2LNZ+Znvevf/9WAhUfbzbTFFbRvxwdZ/TtX12sfHn/Gr6D/YtfL5ZI41dEx+X9y9F9I779yyzftDHvX/z4nr0PY6avbPzqYsXhbT2hiv7l5vo+//7ld32fmeaMHexfEcZr9y97nyKW/evfbZY4jV92H+D9qwfjsPfDzPS8f0VMLtY0rdh8ZpqLquhfLrfv7fOeftv3ZpopAtv38Ry//j2fwPpXJOBk2R5vW5O/3QfS2DT8HGIza76d2b7n+6hmmhlV9C9H1+f69q9mVr68f83cwf7Fx3q7f0X0//1f2L6vaD/QtDHvXyHGEbHmM9Pz/mWfezPTRNh8Zpo5cfRH04/s7Xvuj2aae8G37//dZmH9y9V9nbxtTf52H0hj07RjdeaYJb+Ox8zDj2dGrPgRq239zmfZ19w4Grt8/77CusyXaY/DZhq/4yxPVdH/7Hn5fRT8OHGEzdPeqksK/Pf8h/nNjxN31OX2lcznt99vjmXb+/18f8dMs7SKccFN3912zQQ/h8jbgG/fm2mWVcLJY5n5Olk5Nwj897yBw79N3/MW3X3yM9OsENhuM/0lBuNehj3u/XtNFRv3XN0rz9vW5G+Wz4+bmWn4ufGODpnaWkz2OU2/scg+/8THotWV9Ak+7prc+f5ZxGeZdnw+hps6fh2mzcbP9as4pv99kVT+/2tZnzB9wfRd9f+bfP4/wFgDFuu/ZdavUtz06bJzVXUYa5gtiy+/Llt+UkC2D9WxYptl1WF/66a8Mal82rop27ebaXPDr8a/2rrM+e35alnzpbFparP5Uqz5zG9+T/rXrF+Y9a6u5T02UN6W9r2vffXvaM0+Lp+HmV2d52Hy67l35HmY/FmVfDxPdtJe6Q7vU9wWO8VJ7G3XrO3M8yxNjup6+GZsHaiZTJwID5RiBTK/+UpxdBOfxzsTZ6oouTo+TAE5nrKL10I+y3J0I15Z/vzGSrOMivI3HGlsPs7p6mFyO/uAu1QfpoAgTxrj4cty+YA/k59ZhhqoIs7b3ttm2myZfAcvlbW9maYXm9Zs9DRg/x9idabMb7yx+xW/iYUP6H7zhll7mP/zW3ZS4L832IbZbxODPyxQekOE34zKeRqwejONp78r2jmrX0EutX1iZe5gLDNfLVY2fIbVTBsMbP9A6oDPtPzvN62K+ThDHWsePkbyG0lN2f3N39v+JvhDZnib82WanOwDI/xmWjNNP/1d1U3c9s2lfIOlIYtbUZ8y0wysYnkNK1hebZ9Y++1gLDOf6VP8ZlbDaqYNsv/fkT5V1Xx8fdW35uF+xpnSrOWkBLbPpa/+jtbk421762l9H37OZ9/EnhJwdqO05zcO2H23sv7NxzYzzdH6u6oDf37+1o7ljLdDk5tZnR0a/lBTJzsluZllDxNw82CWTJc7Jb7bJGZZ/KEz/GHO4gcSrNj2dgvfJuIPpbUfZBJivOpTdiBBl+tWMl+yNR8fw/iOZlX7V8msju8U92Xx3azHzO22awNsGQGLOcBYzLebHfVtD7wzfjm8uLTfxNIRw0aWjimesN1j7wxVX4s6KfDfDOxp1CfkU6c+fGuXb2Xz3m7q7J7DW9NMr3oEf/w14OGgLD56BgPbf4Ls//pbhy39RtaUQHkbuRhNXfVKdyP1tr1rvlUXCGzfl/jrAFzlx19po0ahgdah63qB8i2gcfmFpx5WXDpx/JgJ/M+HD3r8w7tMiNXZO3x8OpNe0CdeXbasWtY8/JNixeyrv6M1/PA8kn3y5KbCzTBJnsVjIcuWabdBY5/2qWV9c/ZABfnYMXg5GNh+WLP/368u1Wc5jX3q/gdRfPeGl0cEAA==","debug_symbols":"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d+SrO/LVHfnqjnx1R766a766a766a766a766a766a766a766a766a766a766W766W766W766W766W766W766W766W766W766W766e766e766e766e766e766e766e7668/eqaf5eNc3fq2b5e9Usf6+a5e9Vs/y9ajZYfgjPDxH5IWp+iJYfIl/d+XvVLH+vmuXvVbP8vWqWv1fN8veqWf5eNcvfq2b5e9Usf6+a5e9Vs/y9apa/V83y96pZ/l41y9+rZvl71Sx/r5rl71Wz/L1qlr9XzfL3qln+XjXL36tm+XvVLH8jmeVvJLP8jWSWv5HM8jeSmaHODrKrH+14Jh1npROsdK5+stL0vcoheppOY6XTUelc/TjHM+lc+zDHmPDuEDtNR1jpKCsdY6XjrHSClQ7qvDtz1Hl35qjz7ixQ591ZFFY6wkpHWekYKx1npROsdFiuzDqF1FinkBrrFFKrLFeuLFeuLFeuLFeuLFeuLFeuIFcef5L7lvMf2NnhTUw5OmH04Wtj5z9/e/aK8t1XyHdfod93xfiDPjz/7HWl7o9yk+FwXdE2Xjj++N/3v9++//Hjh8/jJff/+sfdT19uP93tfvzyv9++/svY+P8="}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000aad5fd6b"},{"kind":"string","value":"PublicKeyNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"signing_public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"field"}},{"name":"signing_pub_key_y","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::constructor_parameters"}}],"kind":"struct","path":"SchnorrAccount::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_abi"}]}},"file_map":{"102":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_data_tree_index\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"104":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr","source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n"},"105":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"108":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"110":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n"},"111":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash,\n    hash::{\n    pedersen_hash, compute_siloed_nullifier, sha256_to_field, pedersen_commitment,\n    poseidon2_hash_with_separator\n}\n};\n// Note: pedersen_commitment is used only as a re-export here\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"118":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions, note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<N, M>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N, M>(self) -> Note where Note: NoteInterface<N, M> {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<N, M>(self) -> Note  where Note: NoteInterface<N, M> {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"120":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"130":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"134":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"136":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"137":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"138":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<let N: u32>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"139":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"140":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"142":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n"},"143":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"144":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage,\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, public_data_tree_index: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"146":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<let N: u32>(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<let N: u32>(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n"},"148":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr","source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n"},"149":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\npub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"151":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"155":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n"},"159":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n"},"160":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr","source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        /// 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        /// the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        /// implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        /// 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"},"161":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"},"162":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"163":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n"},"167":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result = pk.x.to_be_bytes(32);\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result.as_array()\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"},"174":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"177":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"189":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"190":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"192":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"193":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"198":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"2":{"path":"std/array.nr","source":"use crate::cmp::Ord;\nuse crate::option::Option;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"200":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"217":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n"},"22":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n"},"23":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"234":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"248":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\nuse sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"280":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"282":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n"},"292":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"293":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"294":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"316":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"318":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"32":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"5":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"53":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"64":{"path":"/home/lima.linux/aztec/aztec-starter/contracts/account/src/public_key_note.nr","source":"use dep::aztec::prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext};\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal PUBLIC_KEY_NOTE_LEN: Field = 3;\n// PUBLIC_KEY_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal PUBLIC_KEY_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// Stores a public key composed of two fields\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[aztec(note)]\nstruct PublicKeyNote {\n    x: Field,\n    y: Field,\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NoteInterface<PUBLIC_KEY_NOTE_LEN, PUBLIC_KEY_NOTE_BYTES_LEN> for PublicKeyNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl PublicKeyNote {\n    pub fn new(x: Field, y: Field, npk_m_hash: Field) -> Self {\n        PublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}"},"65":{"path":"/home/lima.linux/aztec/aztec-starter/contracts/account/src/main.nr","source":"mod public_key_note;\n\n// Account contract that uses Schnorr signatures for authentication.\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\ncontract SchnorrAccount {\n    use dep::std;\n\n    use dep::aztec::prelude::{AztecAddress, FunctionSelector, NoteHeader, PrivateContext, PrivateImmutable};\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys;\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness, auth::{compute_authwit_nullifier, compute_authwit_message_hash}\n    };\n    use dep::aztec::{hash::compute_siloed_nullifier, keys::getters::get_current_public_keys};\n    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;\n\n    use crate::public_key_note::{PublicKeyNote, PUBLIC_KEY_NOTE_LEN};\n\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage\n        signing_public_key: PrivateImmutable<PublicKeyNote>,\n        // docs:end:storage\n    }\n\n    // Constructs the contract\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {\n        let this = context.this_address();\n        let this_keys = get_current_public_keys(&mut context, this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n\n        // docs:start:initialize\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_keys.npk_m.hash());\n        storage.signing_public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note_with_keys(&mut context, this_keys.ovpk_m, this_keys.ivpk_m, this));\n        // docs:end:initialize\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update default_entrypoint.ts file\n    #[aztec(private)]\n    #[aztec(noinitcheck)]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload);\n    }\n\n    #[aztec(private)]\n    #[aztec(noinitcheck)]\n    #[aztec(view)]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // docs:start:entrypoint\n        // Load public key from storage\n        let storage = Storage::init(context);\n        // docs:start:get_note\n        let public_key = storage.signing_public_key.get_note();\n        // docs:end:get_note\n        // Load auth witness\n        let witness: [Field; 64] = get_auth_witness(outer_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature of the payload bytes\n        let verification = std::schnorr::verify_signature_slice(\n            public_key.x,\n            public_key.y,\n            signature,\n            outer_hash.to_be_bytes(32)\n        );\n        assert(verification == true);\n        // docs:end:entrypoint\n        true\n    }\n\n    /**\n    * @notice Helper function to check validity of private authwitnesses\n    * @param consumer The address of the consumer of the message\n    * @param message_hash The message hash of the message to check the validity\n    * @return True if the message_hash can be consumed, false otherwise\n    */\n    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> pub bool {\n        let public_key = storage.signing_public_key.view_note();\n\n        let message_hash = compute_authwit_message_hash(consumer, context.chain_id(), context.version(), inner_hash);\n\n        let witness: [Field; 64] = get_auth_witness(message_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n        let valid_in_private = std::schnorr::verify_signature_slice(\n            public_key.x,\n            public_key.y,\n            signature,\n            message_hash.to_be_bytes(32)\n        );\n\n        // Compute the nullifier and check if it is spent\n        // This will BLINDLY TRUST the oracle, but the oracle is us, and\n        // it is not as part of execution of the contract, so we are good.\n        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);\n        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);\n        let lower_wit = get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);\n        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;\n\n        !is_spent & valid_in_private\n    }\n}"},"67":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n * \n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\nunconstrained pub fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"69":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::poseidon2_hash_with_separator\n};\nuse dep::aztec::{prelude::Deserialize, context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties \n * (e.g. protocols or other users) to execute an action on their behalf.\n * \n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be \n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few \n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can \n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be \n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n * \n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer. \n * \n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is \n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n * \n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline \n * how this would look in private, and then in public later. \n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX). \n * `Alice` would make a `deposit` transaction, that she is executing using her account contract. \n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token` \n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to \n * convince the `Token` contract that it is allowed to do so. \n * \n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the \n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to \n * execute that call.\n * \n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her \n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n * \n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n * \n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts. \n * \n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *  \n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store \n * the messages that we have approved. \n * \n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `keccak256(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a colission and we return \n *      a success flag.\n * \n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be \n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the \n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n * \n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains. \n */\n\nglobal IS_VALID_SELECTOR = 0xabf64ad4; // 4 first bytes of keccak256(\"IS_VALID()\")\n\n/** \n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/** \n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n * \n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n * \n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize  \n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\"),\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/** \n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n * \n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/** \n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n * \n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the \n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n * \n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        FunctionSelector::from_signature(\"consume((Field),Field)\"),\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness \n * \n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n * \n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n * \n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n * \n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/** \n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n * \n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n * \n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n * \n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n * \n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n * \n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\"),\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n * \n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise \n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        FunctionSelector::from_signature(\"set_reject_all(bool)\"),\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"72":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\n\nuse crate::entrypoint::function_call::{FunctionCall, FUNCTION_CALL_SIZE_IN_BYTES};\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u64 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u64 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u64 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\nstruct AppPayload {\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n    for call in self.function_calls {\n      fields.extend_from_array(call.serialize());\n    }\n    fields.push(self.nonce);\n    fields.storage\n  }\n}\n\nimpl Hash for AppPayload {\n  fn hash(self) -> Field {\n    poseidon2_hash_with_separator(\n      self.serialize(),\n      GENERATOR_INDEX__SIGNATURE_PAYLOAD\n    )\n  }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_slice(self.nonce.to_be_bytes(32));\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"73":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: Field = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: Field = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS = 2;\n\n// docs:start:fee-payload-struct\nstruct FeePayload {\n  function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n  nonce: Field,\n  is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n    for i in 0..MAX_FEE_FUNCTION_CALLS {\n      fields.extend_from_array(self.function_calls[i].serialize());\n    }\n    fields.push(self.nonce);\n    fields.push(self.is_fee_payer as Field);\n    fields.storage\n  }\n}\n\nimpl Hash for FeePayload {\n  fn hash(self) -> Field {\n    poseidon2_hash_with_separator(\n      self.serialize(),\n      GENERATOR_INDEX__FEE_PAYLOAD\n    )\n  }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_slice(self.nonce.to_be_bytes(32));\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"74":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::constants::GENERATOR_INDEX__COMBINED_PAYLOAD,\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\nstruct AccountActions<Context> {\n  context: Context,\n  is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"83":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n"},"84":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"85":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"87":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"}}}