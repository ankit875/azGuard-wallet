{"noir_version":"0.33.0+2d702155f9341cac08a960f271e3ed5450740729","name":"Main","functions":[{"name":"triple","is_unconstrained":false,"custom_attributes":[],"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/62QsQ2AMAwEE8RAdmwndscqRDj7j4CAFFEKGjjp9cVLV3wMD7FnZum99SbIzF6SI+EOyaoKsNSsqCgqR1IiV9Zi1QoYMjk2MfJ246MLvoHxPxdcrnX4Yia+bOEEaGtyMUUBAAA=","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ=="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"quadruple","is_unconstrained":false,"custom_attributes":[],"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/62QsQ2AMAwECWIgO7YTu2MVojj7j4CAFFEKGjjp9cVLV3xYHkLPzNp7702QmD1HR8IDohUVYClJUVFUalQiV9ZsxTIYMjk2MfJ2U0cXfAPDfy64XNvwxUx42ZYTntruj0UBAAA=","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ=="},{"name":"double","is_unconstrained":false,"custom_attributes":[],"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/62QsQ3AIAwEIcpANrbB7rJKUMz+I0QRFIgiTXLS64uXrvgYOnFkZRt9jCbIzF6SI+EJyaoKsNSsqCgqV1IiV9Zi1QoYMjk2MfLWmV3wDYz/ueBx7dMXK/FlCzczv6YpRQEAAA==","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ=="}],"outputs":{"structs":{},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]}]}},"file_map":{"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"contract Main {\n    fn double(x: Field) -> pub Field { x * 2 }\n    fn triple(x: Field) -> pub Field { x * 3 }\n    fn quadruple(x: Field) -> pub Field { double(double(x)) }\n}\n","path":"/Users/satyam/web3/noir/sample-counter-2024/contracts/counter/src/main.nr"},"67":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"110":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"145":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"201":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"271":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"288":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"306":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}