{"noir_version":"0.33.0+61d6f251ea67204af2d17175f120e17f2e9e9156","name":"Counter","functions":[{"name":"increment","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"7Z3djiO3tYXfZa59wZ/Nv7zKwSBwEicYwLCD2DnAgeF3P+qeqZK6tVtyWaRILq6bZDphkZvrE8VVq0pVv336xw9/+++//vrlp3/+/Munv/zPb59+/Pnv3//65eefTn/99snK6//2y7+//+nlz19+/f4/v376i/nu0w8//eP0379/9+mfX3784dNfovz+3VUzl0r61tJlW/bG1hqltbgSv7UWn+61tsb58K356d+Sz+1L0tqH6LfmIbu9tXdq52lvbN2bxp+/+2QDNbnSJFKTK00SNbnSJFOTK00KNXmviTPU5EoTS02uNHHjapLcWZMc72jicrZbLcWYhzTxz9PEl7JpIikM/DkRanKlSaAmV5pEanKlSaImV5pkanKlSRlXk157sX/Ex/oSt5an+V5Unfxr37Zh34/4Kuv85pSsS/bct/dK6yJuI19E5E0lChtv7ab36d/irir301YuWuXe7Uf506fxbv374nf5vC78y/fAdf37x7y8rINvbZ3asd/NrxUrl41fKg/TVh6nrTxNW3metvIya+Vipq3cTlu5m7ZyP23l0+6hMu0eKtPuoTLtHirT7qEy7R4apt1Dw7R7aJh2Dw3T7qFh2j00TLuHhmn30DDtHhqm3UPDtHtonHYPjdPuoXHaPTROu4fGaffQOO0eGqfdQ+O0e2icdg+N0+6hado9NE27h6Zp99A07R6apt1D07R7aJp2D03T7qFp2j00TbuH5mn30DztHpqn3UNzhT3UW9kG8N49rXKZtvIwbeVx2srTtJXnaSsvs1ZezLSV22krd9NWPu0eWqbdQ8u0e2iZdg8t0+6hZdo9tEy7h1oz7SZqzbS7qDXTbqPWTLuPWjPtRmrNtDupNdNupdZMu5daM+1mas28u6mddze18+6mdt7d1M67m9p5d1M7725q591N7by7qZ13N7Xz7qZu3t3Uzbubunl3Uzfvburm3U3dvLupm3c3dfPupm7e3dTNu5v6eXdTP+9u6ivspjFt1dhY8r3S/fasoRIvHvFzmsZrOX6scmSscsJY5cSxytF3HHHbLXFe4r2nrPm4P9nMX5Rz+nJSWqf9IWtF/LmtsdpE+z1jzX7wQCEK88HziijMB49DojAfPG2pnTCnK2t5n2spb6R5LciNVpAfrSAZraAwWkFxtILSaAXl0QoqgxUUzGgFPf+b2u1W9rTGrwtyoxX0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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2dS2xk2VnHb7nKdtld4/K73e4eyYjhsYrKLnd3RiKSR3kJJJhoAmQTSDy2JzTMtGfc7kyGTWbFQ0gsMhIDYQdSJkgEkFhNIBK7JAs2QUKQKGJAIRISCyC8NoT0se+/61efTz3urfvV7Z7ylUp169Q553ucc77vO993HpXk/Kk++FTS9+n0u5ZcfJRnL/1ujfZsF1hXyxPPymOC59RjgmfVA88KOm3NIB8YU00uPu8xBIbnR/F+Lf1+5uRk/7WtO3cPjz6zdXz/dOv4ha3nj+/fPbzHgp/A+430e//09Oill0+3To+39g8Pt169c/pLW8efPjp54cXjV1n2l/MCfSVvwc/kLfjZvAV/LW/BP8B7VsZ+IS/QP85b8O0RsP1mJSfQ/8CPH7oI9N79509P9g9Oe0P+n7yQ/20qZ8FXqiOi/Fo1J+TP5i34Jgpmbdq38gL9Ut6CXx4B22/kBfp3eQv+8wjY/l9eoLO1nAUX8ha8XstP5k/kBfqzIwB9Pi/Qz+Ut+Kd5C/7lCGQ+NZ0T6LPT+YH+Ql6gB3kLvjwCtr+RF+jn8hb8vbwFvzACmV/NC/QfMgJ9aHVWZs6/68m5pXqWlpxbsXvp79Zoz3YdiBZa93t3bwf0358CsNPGQM8H0v/0XUk/jaRjlat8A3V8AGni7QeRlrIt+VCaNvvgM5+mLT/4fJhEp/xd8ODBA/4GfJ7oBtc1q7C8ER5NlKs+Jnjq/ysPPovp+/6nX3r25YPjw6NnDg9Pju51DYxaDzj2CXQv+dB9KyvdS8DJqy0C/25Y/n346PT9x3fPTN+fvHvvdP/uwVEF8EXDjKGhklykx+YhjZUILxZMPv2eKjiPYzvvUH6QtsTgpIftvOyD09mYW8qAE/EYhpcrPni3Qt2rPnXfCvWtpXVNp3WLjlXQqzw/ln5bPgq3NcMnjRPVuQC+roF3az70bTeBK2FYWWLbs5l0+oJoaBieqLzSlL4aqWsV9IvmdZTbK4beMzecYIX2FK/XI/j9FfLtJhd5o/yxvu40Rs/kRjPpfoYZo45j5GYDcIbBaRU4OcmEbfZF4TaXdPfFgmC1hunjl7DfPbDD+NMYVN9if9N/WWUfx8IgGTMO+etkT7YCnosGXpCxzwH2Ez6wb1YMzBpw4bxBeX4HeX8eOC8ib3gaycV5B+1gpev3FOpaMPAX8E67z0lWnvFkuQeehKk+MmPyLKOc8nzS4M+HNscyaF7G/+EhTzmmhuGp6mc/GmTTOPY7Txv1ZsxGFR0xG/VX0u9hbdRlw8vAN7UHbVQn+rZpC3rw7qrhneigTag8JwN4d7UH7yhfxbOr4J0TfTuh7g1H3l0zvBMdG+CB8rw2gHfXevBuHbwTz66Bd070tUPdm468u254Jzo2wQPleX0A76734N0GeCeeXQfvnOjbDXXfcOTdk4Z3ouMGeKA8vz6Ad0/24N0meCeePYlyWebIshfoY6GdsGRwWIrUtQR8wmNttPDZS3+3RnvO5k+zBl4jhSl8lDaXvq8hTf7tq0i7kr5fQ1ojfedY+Drg0q+rMtZOiNkv+k2bwNortDlox+WxoUNd1i+0gHf6Edd61LWIPJJ5MybPGsopzx8aGHwcdcutmO4UfjHd+VYfPPvpTtVJflJ3OvlaoraB2mg5Qt+X+tB3FkOqd+gQvtOIR8Vs2fB3re5DXxjf/zTdwU98nql3YHv5Z2LtLfjicRN56DNystG3Y+Pczg0p92dMHsoN5fly+t1rHmTt6EZyUeYN6w9Q2grqsrjZeTZlXIH6o0X9UQM8zt2KhCW9RF/IXCRtPpJ2JZLWMGnUS7YPFql31afFtwr4SP+C8vx1+h3rX4Eu6dqHcbsP3b97cHrn+O5Hj148Ojg9PqGjdhZEJXivRSqfQvos0h0dRzsNA8vimiTxoHDAqemI00IGnJrAadEHp+2sQYJF4OQU8NymMBoGpzE4vtpZA54rwMkzCLtieDCHtKQ4WIcVUy+Dm1O+sFtlwg5jY9bwmHynHByEYxNpDLY5BWx3GwYnwUgMnnrG4aCj8Sjc5pLuiU5BsFqxCdSaaZNL2CPBbtuEXsYlJ2bhGQbHJtJo1HsucIg5qzkpLtLwDbCk5wQjGI/fx/v/A4+6D91tGrEJYCSmfRLgou95p7agoS7c5pCWJMXqtrqhVb+nfGG3yoRN3dbAt2BRtw3CsYk09QlH22e3YXASjMTgqYf61tNuJZzwzCXdDseCYLWGcWRewh4Jdl/dRtlEJ3F4hsGxibQxLNhsMUAuGEG/bFU6sJ1k+U4l6cgXG3SeB4+U52O1Tt6nKh3eqgxl1rxJqyBN9eo3HfANA584WnzYZtbBkheHJtIawGse7/qvZtKsn4VOHtJYx/8qN4wcF5z5EXFgUKuO8jbQFdKqKKP8XmOBQTThLfiEWQU9pJdlled9aT8NffanKh1aYv3F+sKy8rKBNM+2sk7fItuAtjbhVgHPy9YWDLZVrF9aW6Fo562l1QZ72b+eRf/6RqVTLq/MUr3sg1VTVzVSVxV1qFxemUK5l4UepbGfOs2NWhxPghHa4OPQmw0f2O1QH4MKHLcN8Eh5fhx685P++HXZFNTvB/42RTurTfGv1U7eT2HM63/aFHnmP9Td1HV2EcQg/Ue9n8eu5IJGzkW85mGh7qtOdWf1XzLQ77nA0IvexZTeqqFnxdDKthxmwXZsjq8+wj6eZWHRPNJi/j5rx2a1iblAnjah0uyiakcdkHkDHvWSZzwqi/+D8ShP3z7hhOfdGBMqOx5l7RHynfZ6lnjUGDZaddkLghH08ZuPoL3wVdgLvx+xF2iH5Zln97IX7Nwwr61O26MawavSBy9PW4R6RjhYPTOsD8cu7qSuY/uMGqul3hH9nAex/VR/Fn/5EtLsZjFruxU5B6UeHYN/vGv8C0YYX29j/Dv5G9psEzv+a5F2+jzG/1fG5IP09v/F5h7e/oHHeO7fHtb2pE/Ge07p6ZOz/reixx/HPPtsFTxQnm+l/Oy1ANzOVaxeZv9nfMUzXm3tiUDnO4+gbfMJyLbvlCzbrK0xrG1j+w7tFvpVqFvD471Q3fpZBL/f5li7ho/z+O/1GQd1k75XDB0tu+al6L5qN0rEDtZQnv/tQz83SnCRtd0oYfWI40aJtt0o8bCtsVHCa/0SeSv67cEW3CjRz+6MxUsqEdxja7YkKwSb63kpRxYNrouRupRm4fI9FsuK2Rx2k1ol6V4jXsPvGD3W5gpPaGptCqCOtrG9vfR3a6RnZ4cyOQGMJIJbAjwc19p3bQAUbnOGB1OFwdt9eph284N/66hk+CXTf3t3sum/tV0y/IMJ73/7k93+Ez/+Xphs+b/TKpn+9074+GtPNv9L739ly7+y5c/Nye7/pfe/su3/kvtf2fZH6e1/eGl/lkp/6fqXPqfDFKCfX2+n3TD0CkZieKCHB4TofRZ8IZ7TheE53L5Tv/VH574x+YO71sPXL/JFPuJV8Oe/pv1x7McjHgCl9vph5GX8eg55wxN8kPLhPjzA46NHdw+Puo7tuAKyBj21CDiWp9uT4cxeS/KKXLpAN3Atgo++fdyw7RbPjEkAI8a/JOl2w3q5/ykm5vB96YZ1gX/phk0m2Qy6dMNO+DR4Z8KnQWWPv7Ll3+5k979Jd0NNvBusbP1z6YYsF/6lG3Ki6S89DHhzwsd/2W7QCQ/Dlz3+Srf/yrb/y7b/Jj0MVrb+KXv+UTb/y/Y/lW3/le1/LN3/xDDkt1OAfqGr9nbWMCSX/zPMJr4Qz6LDkIOOxfA7Uv08NqQw5Bx4UKtf5IvCkNwewTCkF479eCSYDENug29XUG6vEHzO7x6bdaH1PC7GfikYiaE/QRuIVs+jMmYNbG41SbvAGa8VL+yEdU+PT/Y/dfSxkzunR4l5pvB+xSCvd5tP6ZVImhgxjfS9EZnQfv7p/YP980vTZgusV8x1PPMq890E3K/stLd2O7SzOqrtJM8d7R9WAHfR4MzvXu3PvsJ+MBv5n0+g2fOSTKdzmM4mNjyPuwY6BLOGPP+eMqDXXmVeTs59brwkU/2EeXlOof7nXmYf+s/XG2Xp42O4nPJs3AmOcJszPCjOuLrZtU9V9Or3lDv8c+daifC3y4V/7twokf6bJcPfLRf++eKeEuk/nGz4t0vuf7d3J1v+3Cpb/hxMtvw7d25OcP87uNS/E93+Jcvf209P+Pgv2/45mmz6S7c/ym7/Cdc/pfe//UmffwZ48j/9dPoS/DsbgFegz2m3YegVjMTwQI/waOD9KvhCPIsOLm0YnDZMuwQ+XfPhU5vBpUXwQMEl8kXBJeFig0teOPbjkWAuob2eAt98+te5/5DniwpGYvDUswGcvPz27Lu845C8KwLW4YMYwEiBpGkwgIEVm0/p/QJJRRP34DkLJG0Clpfj2dKjhx1nE7T6DLBznARHuDWRNpN+j9ToHInUMjaf0ns1ekBi0SLxzOHhydG9eywzY8r1ekJ967a+D7505/Rn7r/44p0X7hydJD0w6Qcl7BdmHIZ3wPM8V8aCeOas8hzgbNU30vdeZwLXTFol6e5KXOAhjvMc1RrS+K76l0xaJRl8xwfPUWV5e44qz1/nfVleAfNQnz23Ve1AmOruOltV//Gsb+U5qXbTyWchubh3nqKAbTbITgt1qccyVuak6870r0SP7bMbwFN5frUPH1iXyokvjF+Krmugz0n8ddkXom/FwKfN8Xof+mhPUbXZM2TtGcfjPENWfWdcZ8ha203wxeNmctHm5uKVdfA2z3jhGbVrSFtAGdU/6r3ivHdSso2yzt6PQLnueZ44TS3RYc/0pr6YSXrrJuX53QHjIHaX2zupouR56pSHee8mEU6x87s97h2J3RcS0tSnqcOcxla737qSNdCjPF8cIJftuhK1G+Wy9N866PNZNxKXy7F1M8rzJ0PKZR4iYuWytY8mUS6Lx5TLvM+p5oiTXURq71SpJJ32szJqFXmV5y/69IleOibP3Rq8fyemY3iPyag6Zthz1nl/nuUR78kZxz1UfFf9Rc0n7J1GBfbJXc4TrAxaBp7K8zcDZKy9J0p8oYy1dzw43jHRpv6z9PEOOOX5+8fc9lXfoYx1uu9nO2ZbCD5lrPKwP3utN6b/QThZO43j0MpY+gqU57sDZKy1zTj2axGYtn7KQPJIdcXuyXkzIttoZxZ1f1Iv2eZxDw3tTPGBd9MsR/BYjeAxaDML7VjqfSdbZDerHfv9jHas+NLPjiXN7CfrJi1Wv36Tf/YOGu95gOzhfvx76CtKO1kv/tn5tPhC/ln/U5J0y7rYPMFJh+32o38lQn+zD/2P4Dxh1+qw2B1AXuvkY/3B+kDpX+G9j57zBKtXs8wTaLcpz40+faLXndejzhNid15zM9+od16vI026g7qEG/ME0/IodLsD6FK2uXCyd8WpDZTX+rXCZy/93RrtOesLT5i6eVar+KQ876l1cP1I7SJdbOdH9a469Z+sNgLnSeHZS79bIz7j9nGpf8Vsg/cNKdsf1fvdpK8o2z1jYNaWsfd+N5GHPgaNCfoYrJ1N2ZD04C3vYF1FWuy+tTy2bDPptmGVNow8pIzwnpM9kXTTQT+MYIoXM0lczlIe/dyAcWDLBlo/XunQ6nRnc+b75jjf85qncz5KnTzqHLUK3L342c9/Q/yV52CA7W/tKvEjtrc0Fguh/sxzT3rM/zUs32cNXnlx4F3t9FGu4F315/Hlcv5JvTmMLBOclRFxoD+ZclVptBkY3ynadls3dds4LXHinbueax0YWyLvNiL8nUq6fQIsqzxfh835OmzO+Qiv1xx5XTd1C1bMTiWvPe/uXTO8tnMX7/5n5yW2/8Xa2s7f2NZ/hLb+rT5tTVp/G2W+CHvDaS3A2O9jtm1KX8wbQ9rrjO9Ye93qgnHa6w99DGOK2VpfTMyXcBX8UxoPodF/o9rrsTinh17ynANxLkB4tD0KlDmtWHyW4z68fy0iNzivVxvS9z9uHWnXA1odWUOeP3vMx3hsXYbTmpdt8lb0Cz7b+Br4J5w856d23FofWyxmOG/wZjt+ZUh/K9dl5PHH0R/KtYUxeaX/Ka+yrC2k/0LjkG1GOy88HOvh/enpDty8851RfdKcp+adj+RZ18F58xjkfov9iWti/hb2l9Ocvc02sTYS5+zK8+fTnbzfBH5O/pAu3hDPbz+CvHkVvPlH6M3Y2lLro4j5O4pc+8l5Pn0G6yYt5oeNxZQlSzg3crLjd0Pd153qzroF6jro9drP50lv6A+hb6waeq4aWtmWg/aE9rLp7R6TrDY31xYuGDyLkO0bSBtm7aLj2r4d+gcTwEgMPYnB09H+a1NODYPTGPb/dG1ZFG7cK54UByvzOR3vFtj0OdOeEyzOR7PYpNx37NRnu+wF+n6WsDfc016w8Y+YvaA8z8FeWEvfOc+mvbBk0oaRdbQ9SLO11WJrC61spXyivB0mhiJ62W+sHI3ZOrH9K142uKccpQ5VvxAdsb0jP5L2hUE+CvpkrY/Ctuk4fRQP96mOaU2YtU+sz457R2J+SN6dPKofkuucNE64pimPvR1b9+Boi2wPaw/RT+C9ttnGR3r5VzzXxvVaO2XXXA9LI/1lKmf9ZrG+FluPkgcH0khcyt732WutZCNCy0cGyMrYvs+t1IiN6SbyciWCk4Uf05mD1uMXFaf3nHNnjZ39Yp92GCZWRJ8C5xGeOnm9B33UycpzOKROflTjBrF12l5rmGI6TfAZQ7KxBE+dFrOXhQth2jM2Yva78rzSp09wDsV11Cq7EoFp64/5RCivLW6c54zT7+ixx4fyjn5NuyaI+z+Ix0YEj0F+LJ71wbmq01kfZzJWxxpZGcSzPpTnNwfI2E1Dn/hCGSu6NiM0s59smrRY/fpN/q2b+h35dybD5b/sxz/leWMA/64b+sQX8k90MS9l3UaEficdttuP/qsR+j9fgA6z83tHHXZhr5F4Sx3mdTRarD8IPnWY8oxhb1lUrwqXmG/F6jDabcrz1gAdFvPr59Ehsb3FnMtwfj6qX38TaXY9DeexnPdbHjHGSF3ajOBkx14d3xxLRa8XrJu6LX9pZ78NX+O3JsxG4DwpPHvpd2vEx1u3ZbENvjakbGefeZTmJ9JXlO1eMaSYLWN1PY+cpE9PYyIWh8zim+8Vh9SYYNwljy1LnyfPNhtGHlJGOMZLtmN+FTun6afP6iinPO8MGAextSRaZxO+NCa+A3n5XfRT9U+Np/DXf0b+T4A/nxrfORf3GWdnccQ54FoDLMKfB/yi9dScqVuw5iB/9P49rDubr3fz7aEMS7/DeJhVLKTeu9yMKddEnlmUq5ty+q0xFVD7F/QLtft8ysNZxzasmzYUrGm04ZxjG9ZN3XOGp+SXDqJlPuWpGr6HNpwx/SFWrmbKNZFnBuVmTbnZSBv+N9rtB8G58e1UAwEA","debug_symbols":"7Z3djiS3kYXfZa51kSSDf36VxcKQbNkYQBgZkrzAQtC7b033ZFa3yGW40YwZ1jm8sSU7lRXn00TxS1Zm5O8f/v7jD//+518/fvrHz79++Mt//f7hp5//9v1vH3/+dPu73//47sMPv3z86aeP//zry//5w/H5P9zxdPyv//r+0+e//fW373/57cNfju8+/Pjp77f/vv2z//j4048f/pLkj//+7oNzbzrav+no8Kaj5U1Hxzcdnd50dH7T0eU/Pvq75jAXnftypIvBXQe7EDpHi3Pxy9HivNyPzr5zdPJSvhydfHp99Oe667vqjnLVXYpS963WcB7tS3pxdOwcXeKJpFT/6thb1f54yKrdQ1btH7Lq8JBVy1esOrh71fldVceHrDotUfXnSvIylZRlKqmrVBKOZSpxy1Til6nkK37Ph+P0Lhec9j3vc/5ysK/3qmN4KlpWLVpO1j6F61hfn1QxxIesOj1k1fkhqy4PWXV9xKrleMiq3bJf16fD+1Kbqv1DVr3u0jiqetm1cVj1smvjsOpl18Zh1cuujcOqv+ba6PNVdWiUWeoqlcSv+b1ar0rEReXfpIupnkcndy/EPf+7jGHRuos//7gWOV79Cewc68J1bPOnNQp8wgifMMEnzPAJC3zCip4wHfAJHXzCVU1lXkJ4p0kCnxDeaRK80yR4p0nwTpPgnSbDO02Gd5oM7zQZ3mmywCeEd5oM7zQZ3mkyvNMUhNXivq0f89EkRFgtxgkRvmliOY+NVZqECN8044QI3zTjhAhXT8OEFeHqaZwQ4eopXff1p9ishxVhPRwnRFgPxwkFPiHC1dM4IYLTjBMiOM04IYLTjBMiOM0woTsQpEaJCG817lhWa/7fzYnemcP5zPPtZC+epz5DLms2M0MKQ8hl/WZmyGUVZ2bIZS1nZshlRWdmyGVd5y0h5TjuZw5NSLes7cwMuazvzAwJYTxaSAjj0UIKQ0gI49FCQhiP5OvhMXlZxxkSwni0kBDGo4XEMJ5xSI9hPEpIDONRQmIYjxISwniiv9fx8vnZM6QwhIQwHi0khPFoISGMRwsJYTxaSAjjUUIGCOOJNZ1nTkdtQ0IYjxYSwni0kBjGo4QUhpAYxqOExDAeJeTjGc9T2Y/nME9lP56VfC5bHs8znsp+PHP4XHaEuPl69JiHiwj3KSkR4R9HchBTxpSIgh8R4Q5sJSLEY2XjiBDPlY0jQjxYNo4IcRf2cZ44ed9EhBg2pkSEuAt7HBHi4bJxRAi7qfeIoY0o+BEh7GYcEcJuxhEh7GYcEcJuxhHhn5t3EGPHlIgQezfjiBB7N+OIEHYzjij4ESHsZhwRfiSQg5g+pkSEHwrkMr7dFHy7Kfh2gzEobxwR326K4EfEtxv8gYcOf+Khwx956PBnHvp5w3NqVCLmeP4KmPP9l4fndy/7eRNu3llHWKQOWaSOdy1HKV5vCU8pK3VIyGchEuqLhsnd37Hi9QbyFGN+dfRT4e9aZG47uVfhKkCfwvWKyVstytHlekKuvOzH5J7Lzl+v7FivsrNTv6AO5/x58sPF+58UV/Nz6eVxS68PW/r7Rp5829Ld45buH7f08Lily+OWHh+39PS4pT/uauoedzV1C6+msdxLz+5V6Z3j7652uxa81xKeFdMvvPROzbnwOj0158KL+tScCxvA1JxCknNht5iac2ERmZpzYWuZmnNhxZmak8SHAokPBRIfCiQ+FEh86H1TOh4oJ4kPBRIfCiQ+FEh8KJD4kJD4kJD4kJD4kJD4kAhJThIfEhIfEhIfEhIfEhIfiiQ+FEl8KJL4UERZP71L19ldkiYnyvqp5URZP7WcKOunlhNl/VRyJpT1U8uJsn5qOVHWTy0nyn6CllNIcpL4UCLxoUTiQ4nEhxKJD2USH8okPpRJfCiT+ND7ZlE9UE4SH8okPpRJfCiT+FAm8aFC4kOFxIcKiQ8VEh963/SqB8q57rriXzy66r28yvlU+rpLhVZ6Xffb4nZldy+9JOVP1/j4p6jrfmFMj7rud8b0qOteRk2Puu6V1PSo615MTY+68Lo3O+rC6+TcqOFY96pqetR1L6ymR6WxpXDQ2FI4hCcqjS2Fg8aWwsLjH6dHpbGlsPB4ydlRFx5HOT0qjy0tPO7ybVG9r+fUYH/7F/jH653LsPBszLk5BSZnPu45fZMTZTn1MZzj4W9/WZqcKGuplhNlIVVyLjxZcm5OlCVUywmzfio5YdZPJSfM+qnkRNlk0HKi7DBoOUl8aOHJklNzLjxxcW5OEk9YeOLi3Jww60op13V2PY6XOduDg7hzzEAQaS5WFx7n9w2hwKxYM6HALG8zocDsDUyEsvAIwm8IBcYmZkKBUY+ZUGD2M2ZCkQ2lhUK5JBd/vme0+EbyFx5r962QLDxJzBBJvX6LrM1wtbDw0LFvhoSycdzhjvu5w5+hLDz86htCoTRZDQqlyWpQKE1WgyIbSguF0lE0KJSWokGh3JvVoFBeCGpQSI02X4U732wZLDy+7BtCITXaMRRSox1DITXaMRTZUFoopEY7hkJqtGMopEY7hkJqtGMo22hbKAsPoPuGULbRdqBso+1A2UbbgSIbSgtlG20HyjbaDhROo/X3wl/OSjyhcBqtAoXTaMdQKqfRKlA4jVaBwmm0ChROo1WgyIbSQuE0WgUKp9EqULbRdqBso+1A2UbbQBGYcbZToWyj7UDZRtuBso22A4V0SY53KDE3UEiX5CEUmJmZb4RyP7cvroFC+kU7hkL6RTuGIhtKC4V062AMhXTrYAyF1FPGUEg9ZQyFdOtgCAVnKu1MKNtoO1C20XagbKPtQJENpYVCYLRPOQkk9SkngXc+5SRQyaecBHb4OSfOeGElJ4HDPeUk0LKnnASm9ZRTSHKS+BDDBOinnCQ+hDNotqZ05cxtTph1RckJ8z1US/1yeDgO3+SE+R5ScsJ8Dyk5Ya7LlJww12XjnBHmukzJibN+jnPirJ/jnDDXZUpOAcmZT7vNscmI4kKjjCgeNMqI4kCjjCj+M8qI4j6DjDAzwEcZUZxnlBHFd0YZUVxnlFEIMhI4AMwg51FGAgeAGbM8yAgzNTncn6kKPqQmJ4oHaDlRXEDLieIDWk4hyYmy/6HlRPEfJSfM7NLgY7lypmZvEmYcqZYT5nsouCtnCI0PwYyC1HLCfA8pOVGuxbScKNdjWk6UazIlJ8ykRC0nzPqp5IS5LlNywlyXKTkFJme5v4j7aHPi+NA4J44PjXPi+NA4J44PjXPC+JC4e0758/VnhJmzp+WE8SElJ4wPKTlhfEjJKSQ5YXxIyQnjQ0pOGB9ScsL4kJKTxIcciQ/BTLjUcpL4EMwcSi2nkOQk8SGYAZBaThIfghnTqOUk8SGYYYpaThIfghl5qOUk8aH3DSbMx/lbnMsxvKr86eTR8uTJ8uTZ8uTF8uTV8OTvm5SmndxZntxbnjxYntyyQ4NlhwbLDg2WHRosOzRYdqhYdqhYdqhYdqhYdqhYdqhYdqhYdqhYdqhYdqhYdmi07NBo2aHRskOjZYdGyw6Nlh0aLTs0WnZotOzQaNmhybJDk2WHJssOTZYdmiw7NFl2aLLs0GTZocmyQ5Nlh2bLDs2WHZotOzRbdmi27NBs2aHZskOzZYdmyw7Nlh1aLDu0WHZosezQYtmhxbJDi2WHFssOLZYdWiw7tFh2aLXs0GrZodWyQ6tlh1bLDq2WHVotO7Radmi17NBq2KHpOCxP7ixP7i1PHixPLpYnj5YnT5Ynz5YnL5Ynt+xQZ9mhzrJD33dfa7nuKXBFjlcn790Nkc7zuvRi0pkr5bmUd/VzSVfO8vJmiG4p4vN5tLy6dSL3Xl+YQj3HXydx8urop8Lf9V1RJN8L1+76kHqOios+tQTj+/5lyr2Q2v5JSZYnz5YnL5Ynr4Ynf99dc9rJneXJveXJg+XJxfLklh3qLTvUW3aot+xQb9mhwbJDg2WHBssODZYdGiw7NFh2aLDs0GDZocGyQ4Nlh4plh4plh4plh4plh4plh4plh4plh4plh4plh4plh0bLDo2WHRotOzRadmi07NBo2aHRskOjZYdGyw6Nlh2aLDs0WXZosuzQZNmhybJDk2WHJssOTZYdmiw7NFl2aLbs0GzZodmyQ7Nlh2bLDs2WHZotOzRbdmi27NBs2aHFskOLZYcWyw4tlh1aLDu0WHZosezQYtmhxbJDi2WHVssOrZYdWi07tFp2aLXs0GrZodWyQ6tlh1bLDq2GHZqPw/LkzvLk3vLkwfLkYnnyaHnyZHnybHnyYnlyyw51lh3qLDvUWXaos+xQZ9mhlvcUZct7irLlPUXZ8p6ibHlPUba8pyhb3lOULe8pypb3FGXLe4qy5T1F2fKeomx5T1G2vKcoW95TlC3vKcqW9xRly3uKcv+eIhfi9U+FHJSP8Nf9sy64fP8IXztHx9uu+pej4+0S+3509y7hGP11b26M2j3F5bY39eXokv3ro5/CClPYyBQ2MYXNTGELU9hKFLZ/DyFqWNcPW8+KnHgtbDiug4N/Ofj06JUfcjrLDzVrYb2/jvZRQ1OinI8olViPNqxnChuYwgpT2MgUNjGFzUxhy1cPm66VU5xWvqtyhnU13s/tc34uvz50+fF47PLdY5fvH7v88Njly2OXP2P9T+F+NVNelf/0Ecn+I7L9RxT7j6jmH5EO+49w9h/h7T8i2H+E2H+EfXcn++5O9t2d7Ls72Xd3tu/ubN/d2b67s313Z/vuzvbdne27O9t3d7bv7mzf3cW+u4t9dxf77i723V3su7vYd3ex7+5i393FvruLfXdX++6u9t1d7bu72nd3te/uat/d1b67q313V/vurubdXY7D/iOc/Ud4+48I9h8h9h8R7T8i2X9Etv+IYv8R9t3t7Lvb2Xe3s+9uZ9/dzr67nX13O/vudvbd7ey729l3t7fvbm/f3d6+u719d3v77vb23e3tu9vbd7e3725v393BvruDfXcH++4O9t0d7Ls72Hd3sO/uYN/dwb67g313i313i313i313i313i313z7ibNcp1u31M+dVHdG7G+Xa325cZd7M+TtjMFLYwha1EYWfcKfs4YR1T2AlrdDquezVT8CuHDUxhhSlsZAqbmMJmprCFKWwlCvuuifLxuL8FT16EDJ1jxV3vKBT38uj+q/68nC8GTD5JW/Z7pqfEEO4AtbIP78+yD9GewsuxnGXn5I+27HcNN0r+ulpPVSvcx3oe7bPT3mfoDp/PnLe/fvkqxs+PHjbHBx/PoMGn+x/Z8CWnwOQsx5Wz1iZnJslZSHJWjpzve0vBA+V0JDk9SU6c9XOck2T9fN/LNR4oZyLJCeNDt3RnzhCkyQnjQ0pOGB8a5ywwPqTkhPEhJSeMDyk5YXxIySkkOWF8SMkJ40MhXPtgIbomJ44PjXPi+NA4J44PDXNWHB8a58TxoXFOHB9y95whNjlxfGicU0hy4vjQOCeOD41z4vjQOCeOD41z4vjQKGc9cHxonBPHh8Y5OXyoHhw+VA8hycnhQ/Xg8KF6cPhQPTh8qB4kPuRIfMiR+JAj8SFH4kOOxBMciSc4Ek9wJJ7gSDzBo6wrvqbzgR5f89HkRFlXtJxCkhNl/dRyoqyfWk6U9VPLibJ+ajlR1k8lZ0C5ztZyolxnazlhrrOP43yaN9z+0SYnzHW2klNIcsLsJyg5YfYTlJww+wlKThwfKtf91Mfhm5w4PjTMKTg+NM6J40PjnDj7Q+OcOPtD45xCkhNnf2icE2d/aJwTZ39onJPEh4TEhyKJD0USH4okPhRJfCiS+FAk8aFI4kORxIciiQ9FEh9KJD6USHwokfgQzFxYLaeQ5IRZP0s5Rzz7erz6Pbtzch+vwn1sfoyBGSI7FQrMyjwRCsx42qlQYNb8mVBgBGEmFBibmAlFNpQWCsy+zdugXO/EcL62UGA2eWZCITXaMRRSox1DITXaIRSYAcNToZAa7f3cvrgGCqnRjqGQGu0YimwoLRRSox1DITXaMRRSox1DITXaMRRSox1CgRkRPRXKNtoOlG20HSjbaDtQZENpoWyj7UDZRtuBso22A2UbbQfKNtoGijtgpnzPpbKdtkdFGKncLnC+HFtrbJlQmorChFJUFCaUnqIwodQUhQmlpYyZwEzensmE0lAUJpSbbgoTyj03hYlsJg2T7bEtk+2xLZPtsS0Tzu22m5fdzx1aKpz7bQoVz7nfplHh3G/TqHD+iKxR4fwVWaMim0qHCufvyBoVzh+SNSqcvyRrVEjd1ufr3HK0VEjddkwF580NU6mQuq1ChdRtFSqkbqtQEfqVuUdlu23HV2DeZjGXynbbHpW9b9ujsvdtO1Rw3sIxlcret+1R2fu2PSp737ZHRTaVDpXttj0q2217VLbb9qhst+1R2W7boYLzRpWpVLbb9qhst+1R2W7boyKbSofKdtsele22PSrbbXtUttv2qGy37VDBeTvOVCrbbXtUhJFK8ee82uJLy4TSVoqkk0lKLRNKV1GYUJrKmAnnK10UJpQrj8KEck9FYUK5o6Iwkc2kYbL9pGWy/aRlsv2kZUK5j6IwodxFGTPhfJFLKfFkUtvrYs73uChMOD12zITTY8dMZDNpmHB67JgJp8eOmXB67JgJp8eOmXB67JAJ5+tbFCbbY1sm22NbJttjWyaymTRMtse2TLbHtky2x7ZMtse2TLbH/pmJ43xni8Jke2zLZHtsy0Q2k4bJdraWyXa2lsl2tpbJdraGycrvJpF6ZxLLKybPtS+8Zqq1L7xHo9a+8Lqs1r7w+qnWvvA6p9a+8Hqk1r7wuqHWvvA1uVb7yu9fUGt/4HV15XcZqLU/8Lq68nsB1NoXXldDvNcur2vv1XLca3EvbrB0Z9KFV+HJSRdesycnXXiFn5x0YR+Ym3TlCfeTky7sGpOTLmwmk5Mu7DGTkwpNUhpHWnmy++SkNI608gT2yUlpHGnlSemTk9I40soTzScnpXGklSePT05K40grTwifnBTGkeS4Xn4l4dXv7s9BYRRJCwpjSKGEe1DXBF15hPIbmzS6q5bo26A4a6kSFGcpVYLirKRKUJyFtJ6jPVx2tQ2Ks9egBMXZalCC4uw0jIOuPNr3jUHvd2pm35pRgllHS74OLy9quYKifOt6d00a9q6dNOxWnpY6NyjKt64aFOVbVwu68lDbuUFRdnfVoCjXo2pQlHVUDSosQVGuR9WgLGa08pzWuUFZzGjliapvDJqus7vP1f4p6MpjUucGxTEjJSiOGSlBccxICSosQXHMSAmKY0ZKUBwzUoLimJESlMWMVh68OTcozi/e458kVh59ODcozi/eSlCYX7yLv342LLG9Hl158uDcoDC/eGtBYX7xHgf1Kw/+mxsU5s56LSjMvYBaUJx7GJSgwhIUxoy0oCRm5Fee7zc3KI4ZDW+o8geOGY2DOhwzUoLimJESFMeMlKAkd3f6lUc8zg2KY0ZKUBwzUoLimJESlMWMVp5hOTXoygMv5wZlMaOVR2nODQqzjsbrZ0MXy6unDduDg7jz3EHEt1RgFt2pVGBW6KlUYJbzqVRg1v6ZVHBmW06lAmMVU6nAKMhUKjA7OVOpyKbSoUK5MhcvX44tvrRMKNflMROc2WVvYVLrOZ2ldq4LcaacTWRC2TvuuJ49+/w5DZVI6bQqFUqnValQOq1KhdJpVSqyqXSoULqKSoXSVlQqlPu1KhXKq0KVCqnb5uvg2551QwVn/N1UKqRuq1AhdVuFCqnbKlRkU+lQIXVbhQqp2ypUSN1WoULqtgqV7bYdKjBDRudS2W7bo7Ldtkdlu22PimwqHSrbbXtUttv2qHC6rb8X7r20VDjdVqPC6bYKFZgxsXOpcLqtRoXTbTUqnG6rUZFNpUOF0201Kpxuq1HZbtujst22R2W7bYcKzKDfuVS22/aobLftUdlu26NCujLHO5WYWyqkK/OQSsCZHfs2Kvfx3rfNlJYK6betQoX021ahIptKhwrpToJChXQnQaFC6isKFVJfUaiQ7iSMqeAM9J1KhcBtn4Pi6GotVy2u828Ux0CVoMISFMcTlaA46qcExbE5JSiOoClBcZxrHBRn+q8WFMeMlKAsZuRZzMgLS1Ccd2lGd9US26sXnBHNWlAYM9KCwpiRFhTGjJSgOOOOtaAwZqQFhTEjLSjOW8aVoMISlMWMAooweHdtYN/+UtqgKMKgBkURBi2ooAiDGhRFGNSgKMKgBkURBjWosARFEQY1KMpWihqUxYyExYxgRvJrQWGm7KtBWcwIZha+GpTFjGAm1qtBH9OMnmt/TNl5rv0x/eW59sdUkufaH9MynmonHUutPMBGOpZao4KygM2lQvpQkkKF9KEkhcp+iLpHZT9E3aNC+lDSmArpWGpf5KJSO1RIH7hXqJC6rUKF1G0VKrKpdKiQuq1CZT9w33kwlnUstUJlP3Dfo7IfuO9QYR1LrVDZw6R6VPYwqR6VPUyqR0U2lQ6VPUyqR2W7bY/Kdtsele22PSrbbTtUWMdSK1S22/aobLftUdlu26Mim0qHynbbHpXttj0qlL5S6/mQbH1R9hcmclDaisKE0lUUJpSmojCh9BSFiWwmDRNKR1GYUBqKwoRy701hQrnzpjDZHtsw4RzhrjDZHtsy2R7bMuHcbzvccT93aKnIptKhwrnfplHh3G/TqHD+lqxR4fwtWaPC+VuyQgVoov5MKpy/JWtUOH9L1qiQuq3P17nlaKnIptKhQuq2ChVSt1WokLqtQoXUbRUq2207VHDeiTDTV3BeoDCVynbbHpW9b9ujIptKh8ret+1R2fu2PSp737ZHZe/b9qhst+1QgXl9x1wq2217VLbb9qhst+1RkU2lQ2W7bY/Kdtsele22PSrbbXtUttt2qMC8gGUule22PSrbbXtUttv2qMim0qGy3bZHZbttjwqlrxR/jrAtvjRMEqWtFEknk5RaJpSuojChNBWFCeXaozChXHkUJpR7KgoTyh0VhQmnnwyZcL7lRWGy/aRlsv2kZUK5j6Iwkc2kYcLpseU8dantdTHnm10UJpweO2bC6bFjJpweO2TC+UYXhQmnx46ZcHrsmAmnx46ZyGbSMNke2zLZHtsy2R7bMtke2zLZHtsw4Xx7i8Jke2zLZHtsy2R7bMtENpOGyfbYlsn22JbJ9tiWyXa2PzOJnO+wUZhsZ2uZbGdrmWxne8Xkj9vf/c/3v3z8/oeffvz19k98/j///elvv338+dOXv/3tf//1/P/cDv4/"},{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"5Z3hjlu3EYXfZX/nxx1yyBnmVYqicNokMGA4QeIUKIK8exXvXmkd3WiyDLl7jvinhdtL6ozNOd9IK5799eE/337zy/f/ev/xux9+fvj6H78+fPjh3+8+vf/h4+lPv/721cM3P73/8OH99/96/j8/bL//h31+/Ocf3338/U8/f3r306eHr7evHr79+J/Tf5+Wfvf+w7cPX1f97aurx1za04Oe7fyoWD14tqTy9Gwpl21F02///OrB/44I2x/0lgIRmnfBWv2PItrfENHEnh5sWQIRddv/JmqqfxQh299RUfad2/PyjlX4vqltV/8eIkcqpG3+tEaatL/8N1KfnY3fl11vXLbzvhfdydphjSntGxd/9nfd7PDpfef2xc6fi0wrFJlXKFJXKLKsUGRdoUhboUhfoci2QJFpW6HIFSae9PcnHtl0FyNba0GZf3FurXV/sNrlby4n+Sw6M4pWRtGFUXRlFG2Mop1RdCMUnTdG0cIompGImZGImZGImZGImZGImZGImZGImZGIykhEZSSiMhJRGYmojERURiIqIxGVkYjKSERlJGJhJGJhJGJhJGJhJGJhJGJhJGJhJGJhJGJhJGJhJGJlJGJlJGJlJGJlJGJlJGJlJGJlJGJlJGJlJGJlJKIxEtEYiWiMRDRGIhojEY2RiMZIRGMkojES0RiJ6IxEdEYiOiMRnZGIzkhEZySiMxLRGYnojER0RiI2RiI2RiI2RiI2RiI2RiI2RiI2RiI2RiI2RiI2RiLKxohE2RiZKBsjFGVjpOLpFSlVM3JRNkYwysZIRtkY0Xh6GUbVQslGoWSjULJRKNk4IELoLVRTslEo2SiUbBRKNgolGxMlGxMlGymjbIQyy0Yow2yEMs1GKONshDLPRigDbYQy0UYoI22EMtNGKENthDLVRihjbYQy10Yog22EMtlGKKNthDLbRijDbYQy3UYo422EMt9GKANuhDLhRigjboQy40YoQ26EMuVGKGNuhDLnRiiDboQy6UYoo26EMutGKMNuhDLtRijjboQy70YoA2+EMvFGKCNvhDLzRihDb+RPUm/c5az62a8GPHyB5PuvJ8xpe/YC+vgCdfYL2OwX8Nkv0Ca/wJ8kqgx8AZn9Amn2C+TZL6CzX2B2J9vsTrbZnWyzO9lmd7LP7mSf3ck+u5N9dif77E722Z3sszvZZ3eyz+5kn93JbXYnt9md3GZ3cpvdyW12J7fZndxmd3Kb3cltdie3yZ2ctm32C8jsF0izXyDPfgGd/QKTOzkdf6Fda3lao7Ver0kda3LHGu1YUzrWHLpZkf3vrWi+XmMda7xjTXv5muOvjwZrpGNN6liTO9Zox5rSsabjHOSOc5A7zkHuOAfacQ604xxoxznQjnOgHedAO86BdpyD4y9nFKv7mqZfrLn2aT//RmzPF48qj7v71N3bzN2Pv5QwbHeZunuaunueurtO3b1M3b1O3X1qr5apvVqm9mqd2qt1aq/Wqb1ap/ZqndqrdWqv1qm9Wqf2ap3aq3Vqr9rUXrWpvWpTe9Wm9qpN7VWb2qs2tVdtaq/a1F61qb3qU3vVp/aqT+1Vn9qrPrVXfWqv+tRe9am96lN71af2apvaq21qr7apvdqm9mqb2qttaq+2qb3apvZqm9qrbWav5m2burtM3T1N3T1P3V2n7l6m7l6n7m5Td/epu0/tVZnaqzK1V2Vqr8rUXpWpvSpTe1Wm9qpM7VWZ2qsytVfT1F5NU3s1Te3VNLVX09ReTVN7NU3t1TS1V9PUXk1TezVP7dU8tVfz1F7NU3s1T+3VPLVX89Re/ZPvg9T9O2vFSrC7ip6/sCV++baFJD94WrbTP8bT47JZu1w383r0hbiWnx5Oz8p8kp55pSuv9MIrvfJKN17pziu90Ur/k29yUUgXXum8NC28NC28NC28NC28NC28NC28NC28NK28NK28NK28NK28NK28NK28NK28NK28NK28NK28NDVemhovTY2XpsZLU+OlqfHS1Hhparw0NV6aGi9NnZemzktT56Wp89LUeWnqvDR1Xpo6L02dl6bOS9PGS9PGS9PGS9PGS9PGS9PGS9PGS9PGS9PGS9NGS1PdaGmqGy1NdaOlqW60NNWNlqa60dJUN1qa6kZLU91oaaobL02Fl6bCS1Phpanw0lR4aSq8NBVemgovTYWXpsJL08RL08RL08RL08RL08RL08RL08RL08RL08RL08RL08xL08xL08xL08xL08xL08xL08xL08xL08xL08xLU+WlqfLSlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5CUNwtJebOQlDcLSXmzkJQ3C0l5s5AKbxZS4c1CKrxZSIU3C6lstDQtvFlIhTcLqfBmIRXeLKTCm4VUeLOQCm8WUuHNQirgWUg5t/0XumczuWyu5ahQkXOlp+nsi6c/F4vN38HFYhN7cLHYjB9cLPZUMLhY7DlicLHYk8fYYsGTpgYXiz3dDC4Wex4aXOxKExR4YtbgYleaoMBTuQYXu9IEBZ78NbjYlSYo8HSxwcWuNEGBJ5gNLnalCQo8JW1wsStNUOBJbIOLXWmCAk97G1zsShMUeKLc4GJXmqDAU+sGF7vSBAWejDe42JUmKPD0vcHFrjRBgSf8DS52pQkKPEVwcLErTVDgSYWDi11pggJPQxxc7EoTFHji4uBiV5qgwFMdBxe70gQFnhw5uNiVJijwdMrBxa40QYEnYA4udqUJCjxlc3CxK01Q4Emeg4tdaYICTwsdXOxKExR4IungYleaoMBTTwcXu9IEBZ6sOrjYlSYo8PTWwcWuNEGBJ8QOLnalCQo8hXZwsStNUOBJt4OLXWmCAk/THVzsShMUeGLv4GJXmqDAU4EHF7vSBAWePDy42JUmKPB048HFrjRBgScoDy52pQkKPKV5cLELTVAVPAl6cLELTVAVPG16cLELTVB105WKXWiCquCp2YOLXWiCquDJ3IOLXWmCAk//HlzsShMUeML44GJXmqBWyiSvK2WS15UyyetKmeR1pUzyulImeV0pk7yulEleV8okrytlkteVMsnrSpnkdaVM8kqcSf5ZPvhMZOdfgpV9S9fywaecQD56EngkH3wSieSDzxaRfPBpIZKv3PLBif6F/HYtH5zRkXxw6kbywanr9SLfDs4+OHUD+ejp0ZF8cOpG8sGpG8kHp24kH5y6kXxw3/e2K8lN/Fo+uu/flg+eo6q1tH3z+nzzXT6284TysZ0nlI/tPKF8pHn/s6BXn+A9bWdBnq8FGZogRxPUwAS9foZlJEjQBCU0QRlNkKIJKmiC0Jy6ojl1RXPqiubUhubUhubUhubUhubUhubUhubUhubUhubUhubUhubUjubUjubUjubUjubUjubUjubUjubUjubUjubUjubUDc2pG5pTNzSnbmhO3dCcuqE5dUNz6obm1A3NqRuYU9sG5tS2gTm1bWBObRuYU9sG5tS2gTm1bWBObRuYU9sG5tS2oTm1oDm1oDm1oDm1oDm1oDm1oDm1oDm1oDm1oDm1oDl1QnPqhObUCc2pE5pTJzSnTmhOndCcOqE5dUJz6oTm1BnNqTOaU2c0p85oTp3RnDqjOXVGc+qM5tQZzakzmlMrmlMrmlMrmlMrmlMrmlMrmlMrmlMrmlMrmlMrmlMXNKcuaE5d0Jy6oDl1QXPqgubUaHcUDe2OoqHdUTS0O4qGdkfR0O4oGtodRUO7o2hodxQN7Y6iod1RNLQ7ioZ2R9HQ7iga2h1FQ7ujaGh3FA3tjqKh3VE0tDuKhnZH0dDuKBraHUVDu6NoaHcUDe2OoqHdUTS0O4qGdkfR0O4oGtodRUO7o2hodxQN7Y6iod1RNLQ7ioZ2R9HQ7iga2h1FQ7ujaGh3FA3tjqKh3VE0tDuKjnZH0dHuKDraHUVHu6PoG5hTO9odRUe7o+hodxQd7Y6io91RdLQ7io52R9Hf4AZeKRdBz4Lfd0EFTdCrd1lLF0EtlytBDUzQ698viwQJmqCEJuiF89DnNYdWUdWf1tQq12v85WuO75ycfsT3tOb0mfb1mhSsae16TelYUzvWHM4NXvY1bvl6jXesaS9fc/w19mDN4b/P6Yyf1+j1mtSxJnes0Y41pWNN7VhjHWu8Y017+ZrjL8kGazrOQek4B6XjHJSOc1A6zkHpOAel4xyUjnNQOs5B7TgHteMc1I5zUDvOQe04B7XjHNSOc1A7zkHtOAe14xxYxzmwjnNgHefAOs6BdZwD6zgH1nEOrOMcWMc5sI5z4B3nwDvOgXecA+84B95xDrzjHHjHOfCOc+Ad58A7zkHrOAet4xy0jnPQOs7B8Q/KTh/P3FpTOtbYi9e040/zq+1v6Grbrtdox5rj9z+y/xZxy9GbUhfb68j1/Gx53L1O3d2m7u5Td28zdz/+yHPY7jJ19zR19zx1d526+9Relam9KlN7Vab2qkzt1eMPTm3bXdv0mg7Hn20Ga3LHGu1YUzrW1I419vI1bxCt4/XyEex24e/jR7DtDaJ1AkEJTVBGE6RoggqaoIomyNAEOZqgBiZI0Zxa0Zxa0Zxa0Zxa0Zz69YNjTl58EVSuBTmaoAYm6PWDYyJBgiYooQnKaIIUTVBBE1TRBKE5dUFz6oLm1BXNqSuaU1c0p65oTl3RnLqiOXVFc+qK5tQVzakrmlMbmlMbmlMbmlMbmlMbmlMbmlMbmlMbmlMbmlMbmlM7mlM7mlM7mlM7mlM7mlM7mlM7mlM7mlM7mlM7mlM3NKduaE7d0Jy6oTl1Q3PqhubUDc2pG5pTNzSnbmBOLdsGZtUnRWBefVIEZtYnRWBufVIEZtcnRWB+fVIEZtgnRWCOfVIEZtknRXCeLXCeLXCeLXCeLXCeLXCeLXCeLXCeLXCeLXCeLXCeneA8O8F5doLz7ATn2QnOsxOcZyc4z05wnp3gPDvBeXaG8+wM59kZzrNf/47ejWS7Fz7+WICyF1DYC6jsBRh7AUgRp10FIEWiHjxefQ+jkfosIbI8qlek/NSXq0cKW325eqRk1perB6dvoB4cvYF6cO4G6sGhG6gHJ26gHhy3gXpq1hZq1hZq1hZq1hZq1r7BReSR6qlZW6hZW6hZW6hZW6hZW6lZW6lZW6lZW6lZ+wZXyUeqp2ZtpWZtpWZtpWZtpWatUbPWqFlr1Kw1ata+QRjASPXUrDVq1ho1a42atUbNWqdmrVOz1qlZ69SsfYM4h5HqqVnr1Kx1atY6NWudmrWNmrWNmrWNmrWNmrVvEMgxUj01axs1axs1axs1axsza2UDZ63lvD9tpVypB2dtoB6ctYF6cNYG6sFZG6gHZ22gHpy1gXpw1gbqwVkbqAdn7W31Qs1aoWatULNWqFn7Bik4I9VTs1aoWSvUrBVq1go1axM1axM1axM1axM1a98gvWikemrWJmrWJmrWJmrWJmrWZmrWZmrWZmrWoidJBeqpWYueIRWop2YtenpUoJ6atei5UbfVo+dGBeqpWYueGxWop2Ytem5UoJ6atei5UYF6atai50YF6qlZi54bFainZi16blSgnpq16LlRgXpq1qLnRgXqqVmLnhsVqKdmLXpuVKCemrXouVGBemrWoudGBeqpWYueGxWop2Ytem5UoJ6atei5UYF6atai50YF6qlZi54bFainZi16blSgnpq16LlRgXpq1qLnRgXqqVmLnhsVqKdmLXpuVKCemrXouVGBemrWoudGBeqpWYueGxWop2Ytem5UoJ6atei5UYF6atai50YF6qlZi54bFahnZm2izo1K1LlRiTo3KlHnRqWNmbWJOjcqUedGJercqESdG5Woc6MSdW5Uos6NStS5UYk6NypR50Yl6tyoBJ8bZedUW/Nr9eisva0enbW31aOz9qZ6+Nyo2+rRWXtbPTprb6tHZ+1t9eisva0enbW31SPR6lEREoEeFSFR5bMiqNSjR0VI7v+o6NVdJWc9K7Jmt/syt7z3ZW56kXJ6zSf9Bq1fT29P982T5gP9Tq6/cet//bSWwfqFXH8i15/J9WP7f6y/kOuv2PrF22394PwN9YPzN9QPzt9IfwHnb6gfnb/1ot/9QD86fyP96PyN9KPzN9KPzt9IPzh/Q/3g/M3nn2Fp1iP94PwN9YPzN9Jfwfkb6gfnb6gfnL851Yv+dqAfnL+hfnD+hvrB+RvqB+dvqB+dv5F+dP4+01/qgX50/gb6DZ2/kX5w/pa0K9GSj/SD8zfUD87fUD84f0P94PzVtl302xf6DzZPl29BnE7W5enTO8/HasFpPbhacLYPrhZ8EhhcLfjcMLZaB58yBlcLPpMMrhZ8ghlcLfi8M7haXarapWYpX2qW8qVmKV9qlvKlZqm21CzVlpql2j0RqJjtsv3yyW9q+anWe+JPVOs9OVTd9ofrVq9qzds9+VNU6z25U1TrPb3Pi2rlfZf3qF/BP9Wu55/q1M0jauZdtjz7CWJO+78VODOH1grOzKG1gr9jG1or+Pu1obWCz0IjaxXwWWhoreg/iX9RrZc3am07qBX9p/Yja0X/Cf/IWnWhWu9qbgpqvau5Kaj1ruamoNZ7mpuS7F/VTlkOar2nuSmoNd3T3BTVek9zU1TrPc1NUa33NDdFtepCtYLPTTWdb/zXo88GE/gsFOoHn29C/eAzS6gffA6p5Xxjtfr1jfmcwWeLUD/4vBDqB58BQv3gXA/1g7M61I/O30g/On8j/ej8jfSj8zfST85f9MS7UD85f9ET70L95PxFT7wL9ZPzFz3xLtRPzl/0xLtQPzl/0RPvQv3k/EVPvAv1k/MXPfEu1E/OX/TEu1A/OX/RE+9C/eT8RU+8C/WT8xc98S7UT85f9MS7UD85f9ET70L95PxFT7wL9ZPzFz3xLtRPzl/0xLtQPzl/0RPvQv3k/EXPsAv1k/MXPWcu1E/OX/QsuFA/OX/R89pC/eT8Rc9UC/WT8xc99yzUT85f9GyyUD85f9Hzw0L95Pxt5Pxt5Pxt5PxFz4gL9ZPzt5Hzt5HzFz1LL9Cv6Pl4oX5u/ip6jl2on5u/unHzV9Hz5kL93PxV9Fy4UD83fxU9vy3Sj57JFuon5y96dlqon5y/6BlnoX5y/qJnkYX6yfmLnhkW6ifnL3q2V6ifnL/oGVyhfnL+omdlhfrJ+QuffxXpJ+cvfP5VpJ+cv+T5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qeH6Xk+VFKnh+l5PlRSp4fpej5Rdq2ffPyh9//df10Mdtl++V3gqeWn2oF99qhtYK/LxpaKziDhtYKzqsX1VrPv9uypnxdK3o209BawTk4tFZwZg6tFfz94ctq3dq5Vj2oVReq9Z7mpqjWe5qbolrvaW6Kar2nuSmq9a7mpm1/uG71ulb0TK2htd7V3BTUeldzU1Drfc1Nt2vVhWq9r7npdq33NTfdrvW+5qbbtd7X3HS71nXmpoKehTa01nXmpoKesTa01nXmprLpQrWuMzcV9Ey4obWuMzcV9Ky5obUuMjf9dvrjf9/99P7dNx++/fm05Pf/95eP//70/oePT3/89L8fH/+f08P/Bw=="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+y9CXxkW1XofdKppJN7+/aYnqdKOt33XsZTqcrEmIugXBBklBlM0mm4glyEy6gMKjKJAr7HpFwHBEdEQORTZnmgPhUEEUVAQBn0PR6igIiA+nWla6X+tbLOtM9ZlaS7z+/XXZVTe581nL3XtNdeeyC6cF11/t9A5/tQ53M4Wn9Jm4XOZ1zualT4rNgTz4Etgue2LYLn4BbBs1Yhnm3chqLeq2p8hxz4WjWOw1sAx+1bAMeRLYDjaFTt/BEca53vV5z/d+X5fzuiCzps3Y8krC0cBzu/tydKeyC2X3SbkaNom/Twm2rdZ8n1anw/3Pm87olPXHx6/YbHn115Wv3GJ99Uv/FcfenGJz/+7JPY8Zfw/Wjnc3nxcY+r33RjffFJT1p54k2P+qHFpz1q6YabHvWkG56xwq6/GQrzzaEd/3UgsON/bwvseHCw+32887l4000rP/SEm9ocetKTl2564uLyTfWn3nDTY+o3PmXlieced+NT+YBjg4GQb18L7Hj/WkmUHxwK+dVDgR3fMBzY8f3DJWn936GQv1oW8rdCIa/KipCOh9Dx2HqUF8+eTcb2mlCgtwntePsS2N4/FOhDQjueK4Hts0KBviC040tCO76mBJnvCgX6sRJAPxcKdN9IYMc4tOMdR8LJfH0o0A+XAPrpUKCfD+34ryWwHR0NBLovtOOR0I5Xj4aTefdQoD9QAuhTrggE+jPoGKRF/0co5HeWhfz+UMh/GtrxH9Cx6Bv6aijQb4Z2HLoyHNvjVwYCPRXaMS6B7d1Dgd4vtONDQjueK0Hm80OB/mIJoL8dCvTvQjt+K7Tj9h3hZN64IxDoz5UA+uuhQN8Y2vEdJbD9aCjQvwvt+PnQjv9agsy9VwUCvcVV4UDvsDMQ6APQMUiLPiQU8tN2BXZ86a6SKL88FPK7y0L+o1DIfx7a8fPoWHRQfT0U6LdCO27fHY7tyd2BQE+Hdpwqge09QoE+ILTjw0I7PqYEmS8MBfrLJYD+TijQz4R2/E5ox9E94WT+8J5AoK8pAfQ3Q4G+KbTju0pg+7FQoJ8J7fjF0I5fK0Hm2N5AoLfaGw70OvQNUobXh2L9faEdH12C3KeGAn1maMcXlcD2taFAfz204++VwPaDoUD/JrTjp0M7fqkEmTv2BQKd3BcOdCoU6FJox2eHdnxxCTK/Hgr05Fg40FuPBQJthnZcKIHtg0OBLoV2vCG041NKkPnKUKC/UwLoH4YC/Yv9gR3/ER2D1O//C4V89YGSkG97IBDydGjHe6Fj0Vf7iFCgy6Edn1AC2xeEAv2Z0I4/XwLb3w0F+q7Qju8P7fiREmR+NRToFQfDgR46GAj07qEdV0I7PrEEmZ8IBTp0KBzovkOBQA+HdjxTAts7hQK9e2jH7wvt+PASZD4zFOjLSwC9GX3FBL0+I2EzFM/fLoHnm4vj+dZQPN9fAs8/L47nX4Ti+akSeH62OJ6fC8XzayXw/HZxPP8rFM8rD4fjuetwYTz3Hg7Ec6IEnrcojuetQ/G8XQk871Qcz+tC8bxvCTzPoe/4+r7ZzsTjQ7G+KbTji0uQ+5pQoK8N7fg7JbD941CgHwzt+IkS2H41FOh3QjsOHgnsuPtIOJmNUKDXlwD6oFCgzw/t+LrQjm8uQebho4FA73o0HOj9QoE+OLTjSglsnxkK9PmhHX8mtOPPlyDznaFA/6oE0P+DvkHK8F9Dsf730I67joWTe/JYINDToR2nSmB7j1Cg9wnt+IgS2D45FOizQzs+L7Tj/yhB5ltDgf55CaCfCAV6xfHAjleHdmwdDyfzNaFA/7gE0I+FAv1kaMd/KoFtdCIQ6BWhHfeEdjxxIpzMO4cCfVAJoI9C35we7FIonjeWwPNJxfF8SiiezyuB588Ux/NloXj+Qgk8X1scz9eH4vl7JfB8V3E83xuK5wdL4PmR4nj+VSieny+B5/8rjudXQvH8Tgk8o5OF8Rw8GYjnvpPheB4PBXoqtGNcAtsHhgJ9eGjHhXpgx+tDOz4gtOPDQju+PLTja0I7/kpox7eEdnzPeGDHv0HHIG/7U6GQvz0R2HHfqZIoHzoVCHnbZGDHK0M7HgjteDy044NCOz4ytONKaMebQjs+/3Rgx19Ex6Ch97pQyB8sC/ljoZA/Gdrxa+hYVBMOngkEOhra8cCZcGxvEwq0FdrxuhLYPiQU6HJoxx8M7fjUEmS+KhTom0oAfXco0H8O7Xjl1YEdD10dTuZzQoH+VgmgfxAK9D2hHf+8BLafDwX6z6Ed/y2047Zrwsk8dU0g0NuXAHrfawOB3oCOQVr08aGQX1kW8i+GQn59aMd3oWPhzUyhQD8a2vGzJbD9ZijQ/wrteOUtwrE9dYtAoLcO7dgK7XhdCTKXQoE+owTQF4QC/f3Qjh8L7fgPJci8xy0DgT75luFAfyIU6AtDO76iBLZvDAX6+6Ed3xPa8c9LkPnlUKBDtwoHevDWgUBvi45BWrQVCvn+twns+NjblET5CaGQX10W8i+HQv610I7vQceig+ovQoF+LLTjP5TA9luhQKPbBna86rbh2J4OBXrb0I4zoR2/qwSZZ0OB/mgJoC8KBfr20I5/E9rx8yXI/N44EOhT43CgPxkK9KdCO76qBLZvCgX69tCOfxja8UMlyPxKKNDtjXCgx9A3SBlONgKxvkVox7uUIPd+oUAfHNpxpQS2zwwF+hOhHV9aAttfDwX6ltCOfxDa8Y9KkPmPoUD/uwTQq6YCgd4xtONDQzs+eiqczL8IBfqtEkBHmoFAd4Z2PNoMx7YZCvSOoR3vGtrxviXIfGIo0BeVAPqaViDQt6JjkBb9g1DIXy8L+TuhkLdNB3Y8go6Fd9iGAo1DO96xBLYPDAX6sNCOjymB7XNCgb4otOPLQjv+Qgky3xMK9G9KAP1cKNB9M4Ed49COd5wJJ/P1oUA/XALop0OBfj6047+WwHZ0NhDovtCOR0I7Xj0bTubdQ4H+QAmgj0HfnNnXjw3F82kl8PzR4ng+OxTPl5TA83XoG2RcvCEU67eEdvzTEuR+IhToZ0M7frkEtkNzgUCvDO14aC4c2zgU6O1CO14X2vHeJci8MRTo80sAfXko0A+EdvyH0I5fKUHmg+YDgf74fDjQl4YCfUVox18pge07QoF+ILTjn4d2/NsSZH4rFOje24UDvRp9g5ThbW8XiPV0aMd7lSD3EaFAl0M7PqEEti8IBfozoR1/vgS2vxsK9F2hHd8f2vEjJcj8aijQK24fDvTQ7QOB3j2040poxyeWIPMToUCH7hAOdN8dAoEeDu14pgS2dwoFevfQjt8X2vHhJch8ZijQl5cAejP65q1sGornb5fA883F8XxrKJ7vL4Hnh0KB/lVox78vge3IHQOB7grteCC0Y3SnwI6joR3HQjseDe34wNCODw/tuBza8YmhHZ9958COr0TH8c5nIbP9NaGQ37EQ2PGjCyVR/ngo5A9cF9jxQ6Ed/za042dDOx65S2DH8dCO14R2nA3teI/vCuy4hI5BQ+/RoZBfWhbyq0Ih/0Jox7ehY1EV+kehQP88tOPflsD2X0OB/ntox9pdw7E9dtdAoGdCO946tOPtSpD5sFCgTyoB9MdCgb45tOOHQjt+sgSZ33W3QKCPv1s40B8NBfrjoR1fUgLbXwsF+ubQjr8f2vEDJcj8YijQ/yoBdOx7AoHeCh2DtGgjFPJDy0JeCoX8mNCOz0HHwutCoUBfEdrxV0pg+45QoH8Y2vFDJbD9YijQfwnt+O+hHWt3Dyfz9N0Dgd6xBNB7hgL9kdCOrwrt+PoSZF51fSDQuevDgX53KNDvDe34kBLY/nAo0B8J7fjjoR1fUoLMN4UC/ZMSQD9xj0CgX0XHIC3676GQD3xvYMfbfG9JlJuhkB9eFvLZUMg/GNrxx9Gx6KD62VCgrwrt+PoS2L4rFOj/Cu344RLY/lMo0K+GdvyP0I7D9won8+p7BQK9cwmg9woF+szQjj8X2vHXSpC5696BQG9373Cgdw8Feu/Qjg8rge2TQoE+M7Tjc0M7vqwEmW8JBfqnJYB+Bn2DlOE/hmL95dCOQ98XTu7+7wsEejS04zUlsF0IBfrdoR3vXwLbx4YCfXJoxx8N7fjCEmT+ZijQ95UA+uFQoNF9AjseD+14i/uEk/mzoUDfVQLon4UC/Uhox0+XwPYboUCj+wZ23B7acey+4WROhwK9VwmgjwoF+kP3C+z4k+gYpH5fFAr5A2UhfzAU8kdDO34JHYu+2m+HAh24f2DHnfcPx/ZMKNBbhXacL4HtfUOBPiy041JoxxtLkPnSUKC/XgLo20KBfjG04+ADAjvufkA4mU8LBforJYC+ORTo/xfa8f0lsP1UKNAvhnb8cmjHb5Ug8+gDA4E2HxgO9PbomzPf+06heN6zBJ7fVxzP+4XiuVQCz6eib5Bx8exQrH8ytOPNJcj97VCgvxva8b0lsP14KNBPh3b8UglsB78/EOhVoR3HQjuOf384mXcJBfrQEkAfEwr0VaEdfy+04/tKkHmLBwUCfeCDwoEuhwK9IbTjU0pg+zOhQF8V2vEXQzu+oQSZHwwF+oUSQL+FvkHKcNuDA7EeCe1Yf3A4uXEo0JnQjt9VAtuHhQJdDO34+BLYPi8U6EtDO74ytOPrSpD5gVCgf1cC6JdCgR59SGDHudCOd3tIOJm/HQr04yWAfjEU6P8L7fgfJbDd89BAoEdDO06EdrztQ8PJvE8o0MeUAPoE9M3pwT4pFM/nlMDzucXxfH4onq8sgecvhwL9tdCOby2B7Y6HBQK9OrTjHDrmfI+3D4V1XWjH+4V2fHxox2cXZ8uPh8J6QWjH3wjt+CsPD+z4/tCOHwzt+PHQjp8J7Xj4EYEd66Edrw7tOBPa8bseGdjxYeg43vks5Kv9QCjkZz8qsOMrH1US5deEQv7ZHwjs+OrQjn8Q2vF9oR0/GNrxr0I77lwM7Lg/tOOx0I63DO14p6XAjt+PjkGD/WGhkJ9bFvKLQyH/bGjH30THopba20OBvje04wdLYPuFUKBfCu34zRLY7l4OBHoktON4aMfbLIeT+X2hQB9dAuiTQ4G+PrTj+0I7/kUJMmfPBgJdOhsO9AmhQJ8S2vEnSmD786FAXx/a8Q2hHf+gBJmfCAX61RJAR84FAq2jY5AWPR0K+d5lIX9/KOSHh3a8CR0Lx69Cgb4otOMrS2D7O6FAfy+04/tKYPuJUKCfD+34pdCO3yxB5uFHBwJtPDoc6J1Dgd4Y2vHFoR1fXYLMgccEAr3VY8KB3i4U6EJox3uVwHYlFOiNoR2fEtrxJ0qQ+bpQoO8sAfRDNwQC/SI6BmnRL4VCvuKxgR0nHlsS5atDId+nLOQHh0J+ZGjHp6Bj4eSEUKAvDu346hLYvjkU6P8X2vH9JbD9VCjQL4Z2/HJox2+VIPPo4wKBNh8XDvS6UKA/HNrxZ0I7/nwJMgd/KBDobX4oHOgdQoHeJbTj95XA9tGhQH84tOPTQjv+ZAkyfzUU6LtLAP0o+gYpw0+GYv33oR3/owS5o48PBLortOOxx4dj2woFervQjt9TAttHhQK9IbTjE0I7PrMEmb8QCvRtJYC+PxTo10M77rkxsOOJG8PJfF4o0DeXAPqeUKAfCO34lyWw/b+hQL8e2vHboR1HnhBO5rVPCAR6XQmg9w8FuvjDgR2fjo5B6vdZoZDfURby/wqF/L9DO/49OhaueR8K9N9DO9aeGI7tsScGAp0I7XjbEth+TyjQ+4Z2fHBox5USZD4vFOgvlAD6hlCgnwrt+B+hHYefFE7m458UCPTVJYD+WijQ3w7t+PYS2P5lKNBPhXb8XGjHfylB5p6bAoFee1M40Bh9g5RhKxTrhdCO9y1B7kPQN2ea+cND8byhBJ4/VBzPJ4Ti+ZwSeL687PC5ORTrXwnt+I4S5P5ZKNCPhHb8dAlsvxEK9DuhHUefHI7t+JMDgd4ytONUaMc7lyDzB0KBPq0E0OeFAn1baMePhnb8bAky7/6UQKBPeko40B8LBfr80I7/swS2bwgF+rbQju8K7finJcj8UijQwaeGAz2EvkHKsP7UQKzPhHa8Uwly7x0K9AGhHRdLYPv0UKDPDu344hLYvi4U6BtDO/5eaMf3lSDzc6FAv10C6OjTAoHOh3b8/tCOy08LJ/PPQoF+owTQ2tMDgV4R2vHg08OxvW0o0PnQjguhHe9VgszHhwJ9XgmgP42+QcrwZaFY3xza8Y0lyH0b+uZ02P8gFM8/KoHnnxbH84OheP5dCTz/qUTfLxen8V9CafxGaMernhFO4N5nFCZw/zMC8Twa2rER2nE2tONdC7I0ks7P7nQcOf9vW+de+7fa+X8Lnb/jcldjBIhW+uy56cbw+Wd8VwfAFVHv1abnezq/yedA59+O8/8GO+2k/44ObqsMxb2hzr274d5w59534972qBfWSOdf9XS35trPHfV49vn3tQO8FPx34Lv81qb3GNoN+dB6dgT8rpjWlts7On8N4B0NdZ4tsIbBtysAf6DC9zigxsgAYMn9Gr4fRVvOpXabQeDbvnZG3fF+RUq/IdVvV9Q7fqTfiOonf4tMaj9nT+f73vP/7jXSbSvPvwrPWOh8xoHXfDyzvDS/3Gw/YwdwkPd2FXCV39/x0G67OvDaVSFes43WVKM1O9t+xk4Dr13AS37/pzt0200Crz0V4tVcmW+uxCurW9x2G3jtAV7y++zJbrtrgNe+CvFaOXtuarbVWq0QsNfAax/wkt+fjna3Al6UExXO07j93O0+z+6RAbWod65tB201wK9OBjZa1JURYPCqGd/d9ElHvwkcwW1U8WBbZfCmpwcMGuXvbe7wZ1Y2GP7SJU7/uY2FPzt7afN/Kr48/jZ0/LU2mP7pS3v8bTT/Z+c3GP5Gz/9LfPy1Nvj9t1r0cX+w89m2LwcBr0Kbd3qHoldgRIoHcgkejEnVwBfiOVQZnhfiE4MKp0H1Xtp82uvDp1XfYLDjjAyDB7WR9XwZ6twTXNq+yz2f4Y9jGo8E5p6o+772g281F5ziVb6NRr1XXp/KZ8z3+lSj+CQeFcEqLM8uwy4Pu/1+dwNG+2rfk7iOjKu2fNp74MJ3xnIqHm9Tbdh7o94rbQ4IHm2c9vvg1NwR9causnCirBjzwWl1Xu5XPBjFvSiqdnzuV7TK39suYtjtmOtexWPynbopC8dduCdjwnHMxozPCYz2HP5pwHYam80B8EvWR4YV7TW0OYB48cs693ZG3Xim8JnzkLzn3ORzt+FZOi7sKMNib97uV7zdZ/BW2vxc55NrAhFw0+N2RPGpzTvhNce0ngPC0zH8vZCT5nMZV/sZHdWzah/uN+iV3385hV4Lb7G9t+F5+1U/ztG9CvYIYBehWV0NfYM4DgKHA4B7EHhVqVvazz7k8+zV8SsZEDJ+hQ6BWUOb3+p8Jo3fw/ib41eeuRO8OwzeOdE31X72EUfeHVW8EzqOgAfS5i0ZvDuawLtD4J3w7Ch457Su3ii6pjSCz6OOOI0UwIl8choHqzgdLYDTEeB0zBGnIwVwYn7JcUecjhXA6ThwOuGI0/ECOJ0ATicdcTpRAKeTwKnuiNPJAjjVO59tO1vbmrui9bZk+57Mof24J2P4MO7JGBrEveMKh/Y94eEQ7gkN+wxctwEf2hC0qcZUHz+eT63areOOz55wefaFsUK7U2Dw4lgRGttxj/3k98B6fq8+aEI9SP5mMHXSkbhTUX7iJg2coqhap/iUAeuMI/2no/z0Cx670I94Xu2I55kCeF5t4BRViM8u4CPPZ4CZDvqXgYuPYdxYDeRMAiYXb2j4S5t/PNFt+6+de22DVObeKdyT76dBRz2qnqfkT4XPjenMlXiu6UTWO8/ahu+ElfW71fYQ+owb7drXaaPNqYTnTqg+/L4aeFZ9avj9vzuflpPj5yRfUGinHZ/t5KA2igbYhUZRlvvRSZ5T54MOqQdxsMhLOeBIXD3KT9wBA6coqlZZ1g1YTpHHwpaQ4LEL/Yin506EIisqowZOUVStstxnwHIyalaj86LoBEZb0B0c6ML2mSMXFPE4YFLpHgDvpc3vQxEf7eDXVroyr+tR9558rzg6uo6IqrPJ5WLGQYnnmopY+LAN3wkr63erLVc6Dhrt2teY0aae8NxDqg+/t9+/jp7X8Pu1nbGRpIh9MjmmHFdbLjzbU1brlYY0GSg0iiI+jE7ynDoflLUs5i3gOfEFRhJxzgJ+VREfMGD5WHAX6Kf3LTCS6Bc8dqFfHxRRsHdNnKKoWkV82oDl5LWvKmJRdAKjLeiugyL2mSMXFPFBwKTS5dYeafNCKOK7QRHL7zK+d+I7Ix8hS7NZRGxFRUyFKN+tkGvS71ZbylZrabx9TRptksK+B1Uffm+//8OqD424+2coYunroSwnHZ/tqYiLeMRCoyjiIXQyPeKNVsRFPMJ+KOIxA9ZmDh8Tz0s5fNyGdY0P/T2KWGC0J9Zj+6SIdU6VpYilzUOhiG+EIhbBION7J74zNH3Y4X0xl7DC58YVKXhTEQsftuE7YWX9brVljtq40a59WaHpsYTnTqo+/D4UdYU/95vL78/MUMROzsdy0egax6bn3uzTilehY7YZt6ZmVmZaiysrzXhlfn5uudFcnlteWVk+u9hcnJ0NnWNz8ezZpZXFs9NTS8tT55pL5+KVxZW56cZSa2m2ES83PI3SrNzKrN+ttpw/e4121HGMznCsczzTXgnhQ6PRbEzPLMYzc+dmzr/EqeZUK16en1lqnV2cbs22ZkLf28z519ZcmpttNJanpxrLs625qcbUYmN6aTlutlYWZyqSjak5muQxYWX9brXle9tvtON7Y25q1nsbjXplzkBUnZ7IO25C3sPU3NT08uz88vLM4vTy0tLKyrnZszOLc+caSzOLjamlZui4OT9IFpvNuVYrXlw5t7LUas7PNFpzy3PzjdbsctyavzzfL1zB831qfunc2UZ7di/NxjNTZ2eWplutldmV5szSfDwb/N5mmtPxuZlzS4vnIUzNLbfOT/mpeH5+Op4/Nz0bN1Yuz/cL11ad7/HK2aXGytR8c7m5vDLfWDp3fjKunP+6uDgdn51ang4dN63GucX5s/F8e7ycn+5xc+XcUmP53OLU8lKzOT177vJ8v3AFz/dmq3F2Znb63OJ57b6yvNI8r/DPW1PN5cVm67wcCJ7vS435pZmV+dmZqbg1M3v+Wa3zYnqqtdw6rwXOrjSnL8/3C9eWne+t83K8eV7pLs3MxXPn5/jy3NTK3OL09OL89NTZC3UCQ8bNual4anrm3Eo8Pd88O9+aP/+487pi8fwP8eLSucb05fl+4Qrmw+JcW5LOxGfj8/+dmz47F7emW/NnW3Pnzrto4e8tPm+GxUvzcytnZxuzi/NL082pxXMzzfMe2HQznp1vXJ7vFy7P+e63UBDPFY3Jct+W037Z1fiEwOFirNybAFy954zvV/c7FdjvUGC/emC/g4H9DgT2mwzsx8wip1h8c4fCSWBECk+5GB/3yXK5EN91onfZMa4/114kuzLqxvyEBpljAlf4zTomexW/KXuF3xM+ePekZFc9vtrPq3eeJesNQgdTnKXNV1PiyHyW9NMyiwkBdfDOSb4XruFB+V53xKnInK4DJ6991kWzlQ8CJ8+6IgcL4ER57LP4f0EeF1nDZtKLZxq9Xu8bjVy2XK3Ki0lFK5NJHGHHGwmb9VeEx+Q7dW0WjkyskzHRHh/X4hkVjo9W0QTAa4HTKR+cVseswGGS4bXAoyJYq+PmWkXrteqdXIZdCnZT37Dsa75z6vssHHfhnoxHx/nS4E4ZzoVbAF6V/m0bnug5gdG2xU5t636f3NbFwyn5rFk0C5xr5542gMAR3EYjl0TPnlpRQqvOj3OCHW8kbOo24XFofSvuXqI95pTL0SqaX8KzQjzzHHUuzijuRVG142ZI0Tqk3sll2KVgp+o21uITWNRtWTjuwj3mdjrNl9XcRrE5h/B5N+gXJ1k+ZeU26l1ezG38i2Pdttd38ONuP9bi08nxA1Gvn1aLepPp5Vm6fhtx1PjwnQmcQyVxYA7yfuAl9w7j+aPq3kDUmxddw9+kUe8mzSvHdZwzFIdd0fpSDztxj/XRZEzWO59+dWB6a93Wot75SZics6SXfaXNEmy2G7d16bfGizyH46UIL1kryPNdOerKnl3pSfLPy9am/LsR8kWPy5Go+64rxqcxYNBaU/zg+LoJ4+vft3X7hcosea6uQRkZsC2dxTWwUJmi15Tz0qNrDjv6RnFSuZofg970qvncfh51NuftfvBI2vwS9OZP+uPXY1NQv7/A36ZoFrUpzoI3L8ac13kPZer76o141MF13EvTf9T74+reAO4JHuMGHiJH5DdHXdpy3De16uNNRL1Xmo/Hzbpe8UtPetvrlO3xMqTomVC08l2eUryQvy35Tx9fnqXXivmsmvEsuce6hnqtjzYxx24Rm/gU7tU731kpRuYObQfP8wBoPwmMSNETKTwd14YLnwcwAZw8Y/sTigejUe8crgjWqg0/oWiVv7ddxLAtO518p72eheOuaH0pO898BtoLAqMt6965Ce2FO8NeeK9hL/CckhA/O8le0L5hqK1O22PIwGsgBS9PW4R6Rr5rPZM3hiPPrHc+qev4fmSskX9F5gb1DuvGy/Pld/KmSLy8hnv1zvck261KH5R6lPD0+6kIXs/8r4GPn8b8d4o3mOeBCC6jxnvai/n/D32KQXrH/yzfwzs+sIV9/2Ze25MxGW+f0jMm57j+0KTc17GMIfBgzWbtJGEm5RtqX0XrZY7/GnjnuV6t7YnVvfmD7rAL2zZ/c7TbdnSwy6+NkG0ha2eUY0O4J98ZV5F3X+98Otq3DdpE2rYhTLG1h6Ne24PrCtLmUMo8oK6OomrlwGkfHq2OVVYbpd14GvRLm+Mp9POMT+ZYynmewn+tR1b5NuJDX/tsqAc9o4vf2rse6cKe9OFtg7wV+gW+8Jg1ddLsTmu9ZMDAfVLxlvaEwGY+L+XIQYXrQeNZuggZbR/BwVrLsmwOvRdqIMrO77d8Cs+18qKxJubaeObSF8l9Zi69116Uorn0e4GT1/wLLeLmuc+jaA4w1z4944R6Xo9GlRw/oK9WHjnjBDveSNiMEwqPyXfK0CJymHFCbessVIN7q+j+D8YuPGtHCRzykDGwimD1VEcXWnVs7TLsUrDN3D7RcfJ++c6p77Nw3BX1VreXe3qdzDG215PbS1weNdj9/gPwTb38/qJzmXm6nvusta/olK/ayuPPXox5utQ/nE865zU0rui4T7O1Q+EkMCKFp1x14OQUO+/Zp0ke1oFHRbBWx01d0Sp/b7sMuwrYqfqHa0sCi/onC0f684x91vGMCsdmz7pOHTT8GPSLkyyfov2qY5/MkZM233uk2/Ynjdgn1w11TJlxVnmuji2xGD5pzmNjC5xDJXHgOol1BjVjIjV1byCKMvOAGGulvMsjx3XOeygOzEViDFju7cU9qefAuIST79IjQwRvgU+Yg6CH9LKvtPkF2Gy/Ndil3xov8hwdI4sUTgJbniX3uC7o+a4815lpa1P+sa6Hl609CDp/C/JFj0stjyvEpzFg0FpX/OD4ehPGV7PW7Rcqs+S5HIOD6lmDxrPkHmNhoTJFnsFxWiTOwXHquSdLz4v257ugNz3rv+jcci0DqEuPQ2/+oT9+PTYF38n7/W2KZlGb4u8Pd9v+Cea8jrWF+j/U3dZ652HcS9N/1PshcQ2erseYm1cc8HJuefW55YOKHr32zHeZJ7fc8vHrne8c43X1rLrxLLnH3KExhSdt4qJ7N+Uec8t1Ph91OW0HJx0wRR0QAUak6IkUnt655UXiH4xn9iO3nDKUc7giWJd0brm2R8h32utZOG6W3PJvbkJ74Z2wF75j2AvCZ87DIn52kr2gfcNQW522x6CB10AKXp62CPWM4FBX/fLGcOSZoh+o6/h+ZKyF7rug3hH6B/F8+Z28KRIvr+Oe0JJku1Xpg1rrTxsRgzxS68J2ijc0+U70/K8Z7+klmP8nOg28Y5De8T/L9/COD2xh37+Z1/ZkTMbbp/SMyen4W9Xzrw5aOGYHwQNpc4fOj3lr2Wq9nFSvxHO92tpnf13NHXZh2+YBkG13yxi3IbHqnQqu3NNyLHTtjDZKHffkO+Mq2kbw9H9oV8izBT5hTna+S265zv+toc0DUuYBbYMoqlYOOMU4VscqD9Cm7cWcZ2nzkBT6mVveE4/eRLnla+8aueWnfXjbIG+FfoEvPN6FNuO4d9hopw8pHjBwP614m5TTqPOzB6Jied2Eq3WUZYdwT43gIM8YM+iJUuiRe9RT2zvfn9gB0B7LN0LWe+SLJsXbBztF2ynDh6PuPfk+gnvy/SjuyfcjuCffj+GefD+Oe/L9BO7J95OA73Uei8DYBnoJaxjfDxp4yfdq5+SFA8nHHJ/tmbsfUt9dDjsfRid5Tp0PynNow3ZH4ops4Nhu4BRVh09PIh5hORnjjaIBbcGDwUfiWXfEc7AAnnUDp6hCfOjgEta4D/0xN9AIjLbAfzkUjc8csQ87F1y2g/fS5jScilenOBXcGMrFmzGH90UBWeFz44rkgKnIuFF3TPE7z+9WW8rW/Ua79lUz2owmPFc72/zefv/Dqg+dxF/LcGikr4eyrDk+21MR63eVJgPluyjiEXSS59T5oDyK2FMRFdm1OGjgFEXVKuIxA1bdkf6TUX76653PXehHPJ0UUeETiKzViyiqVhHXDVieK5faQ24LuvdAEfvMkXRFTI9U2nzjULft/4IiTqv2QE/IwcBtULBX+Ny4ouoKpiIWPmyLehWZXFm/W22H0Wev0a59nTTajCU8d7/qw+/t9z+i+tTw+0cyFLGnsvRU8p5OYxFZLTSKIj6KTvKcOh+0XT2IA0xeSt2RuE3kacVJnpaTgO/ZOpyHfoZJxw08+5FilQfPUwZOUVStIrZSiCZ96O9RxAKjLej+DxSxjyXeiK0lTMGFwlza/DEU8ZehiLXhxuUsGjMOnmvDK4JVkYLPfdQ2YWX9brWlbD1stGtf40abwYTnnlR9+L39/o+qPlwa/PYGesTjjs/2VMRHFZ/yOCOiiI+jkzynzgflUcQ+1lHx+jQ1A6coqlYRW7nWm03BURERTydF1GDdsDx4Tho4RVG1iviUActprTlmREBgtAXdvqEubJ85ckERMy+LSpeejrR5FRTxwQ5+Sfki8n0CPGQNq4VKaNiailj4kKQ0s3632lK2HjXata8Jo83ehOfWVR9+b7/646oP809Od8ZGkiJ2cj6WdwCvCDB4Wc6Hn3HQK4ePA17ImG3GramZlZnW4spKM16Zn59bbjSX55ZXVpbPLjYXZ2dD59hcPHt2aWXx7PTU0vLUuebSuXhlcWVuurHUWpptxMuNrRYd4vypGe0sHcecM7nP+dK+QvnQaDQb0zOL8czcuZnzL3GqOdWKl+dnllpnF6dbs62Z0Pc2c/61NZfmZhuN5empxvJsa26qMbXYmF5ajputlcUZz+W1msFjbe+l/W615XvbbrTje6NRnPXeuIdoIKo09z/OO25C3sPU3NT08uz88vLM4vTy0tLKyrnZszOLc+caSzOLjamlZui4OT9IFpvNuVYrXlw5t7LUas7PNFpzy3PzjdbsctyavzzfL1zB831qfunc2UZ7di/NxjNTZ2eWplutldmV5szSfDwb/N5mmtPxuZlzS4vnIUzNLbfOT/mpeH5+Op4/Nz0bN1Yuz/cL11ad7/HK2aXGytR8c7m5vDLfWDp3fjKunP+6uDgdn51ang4dN63GucX5s/F8e7ycn+5xc+XcUmP53OLU8lKzOT177vJ8v3AFz/dmq3F2Znb63OJ57b6yvNI8r/DPW1PN5cVm67wcCJ7vS435pZmV+dmZqbg1M3v+Wa3zYnqqtdw6rwXOrjSnL8/3C9eWne+t83K8eV7pLs3MxXPn5/jy3NTK3OL09OL89NTZ1tnQcXNuKp6anjm3Ek/PN8/Ot+bPP+68rlg8/0O8uHSuMX15vl+4gvmwONeWpDPx2fj8f+emz87FrenW/NnW3LnzLlr4e4vPm2Hx0vzcytnZxuzi/NJ0c2rx3EzzvAc23Yxn5xuX5/uFy3O+891VHAuYKxqT5V4rz0UAa8+K3ON+oMMKT75f3W80sN/+wH5jgf1OBvYbDOxXD+zHWmpOsehm0XMGTgMnnxj1hfiuE73Ljvvz5tqLZFdG3Zif0CBzTOBa40nrQ8pe4XfdB2/3vct6f21d0V9Dm59LiSPzWdJPzzHrDDjyV3h7QvUbUe0r1C8NzvsBRYe15rLcIaDNil/GmpDPPqsLNZrqUbSO17w4PpnxeNwRpyIZY4yzH/XBqVF0reEocHKyLwov6NO+8NpTX1SnsOa5U73FhnUm42hUyZ7KdfQPRNk1TJxgxxsJm5nlPANPYMlveXC0ajw7bhVp7VA4CYxI4SkXbTPPMxf12fajkc+2rIEoezfLZdilYJs18UXHsb6PwKK+L7Lfn2emeW2tasMTXci5QJ+1Sh+9DU/0nMBom0YfHup+/whsJa+zSEP3djvq256dYNwy6rAtdFW3ZZ2P6gQ73kjY1G2sBSuw5Lc8OFp1vRzjPa2iOwW5Pb0fWzMFt9HIJ68rT17qZdilYKfqNtasEljUbVk47sK9JF1TZTyE/gt1zVehX/p53ouOkzJe8vHt3bbfQH6mjouE2uFlznupd757+ALclXkSzw+xnbibs8g54N72G3NqWWtI4luMeTjlMvbIEImdCXzC5BnFpJd9pc2uTsf2cD023KW/3vmd48Wqo1WEl6yluUVt7TjJ1uZ6i5etzXPo5V1Z49LR9m8MGLRqfcDxNY7x9brhbr9QmSXPrQOHUfWsUeNZVhw6VKboult56dG1Yh19o5jziWe93Wa4C9vzvBe9r0HLAOrS34DenPLHr8emoH6fBux+1jhNsyl+CLyZx5zXtchC/Z+sigqsjZem/6j3h9W9gah3b0Mt6q0gIM/S1QUcdWnLcU9Vq2hZsknQ61WhxpNeOe9F18usqU++yzw1uOud7/Txdemfoj4Lz3s5iT7yfG3HFrWJWWJO5s4Y7ul9P446YKroHkzqJad8gmbR+EcNOPWjjCDjH8SjIljxQJSdX3AxwrbsdPJd2+tpOLJ8I6tGOY3ZHntBYLT18Q2b0F64O+yFHzLsBeEz52ERPzvJXtC+YaitTttj1MBrIAUvT1uEekZw0HombwxHnin6gbqO70fGWl3B5fPT5gb1jtDPmvi6albRePl23NP7UbXtVqUPSj1KeP2OQf4U5r9TvKFnjSetWIu0OYr5/xLMf88YpHf8z/I9vOMDW9j3b+a1PRmT8fYpPWNyOv5W9fzjnOeYZflfafPbHX4m5UxqX0XrZY5/rv15rldre6JN51s2oW3zWcQS37bBsk3bGnltGz12aLcwriLvnusKTvZtgzaRtm0IU2xtOe9FfmNbafOBlHngWTPEqZ7P6lid7DxLxqrw7BTolzZ/mkI/z3thLqo+70XrkdUxMOJDX/t98LyXtXc90oU94cPbBnkr9HOsta9daJNmd1rrJQMG7hOKt7QneCaiLqw1EPXm+Nbw9zYDB8LV+s9ay7JsjnrnO2WN3BMc6in00KcY73ynTbnSYRTlH3PJk6r2MpYvbT4PGT22ff1z68AlZD2R8tiyDymjQ/IbKI+3456Wx/TjuO7mFaOi7yffrb0rMt5ERstvjF9Im6+lyKidaFfvfPIcqDpg6rkrf5OnfazptSqrz3SepcfsaeApbb6dYbOdUfQJXw6DPqGLZ7d7nj12WtFXU/Br5O/2ZPq2wtljMnb6pYv0WVrU7+2LZ2lN4l698/0UeBsyX6jrJnBP5BjlufxOGTehnm/pOrk3insi26hfdZyFct3TL7H8amuPKgulJukmaXM4Yx5Ya8JvgZ+hfeEyMc40P8AjfmnFHXmWJXWY09xalVsyN7RcngA90ubalPfFZ0k/eW+Uy6L/+lDU2ZTLusgz5fJtc8rlnvO4lVy2Tjm51OQyz03XZxx67gmy7FVrP7z2m634rbS5Q8qYSNIxusA8YernUwfIPUvHcJ2grI7J66/VAFPziPH2fqxn6bWRKv0Jz7wW+glaBrFWqLR5QIaMrSn6hC+UsTpW5Jk/QP2n6avhU9o8dIvbvmv5vZCxnvJM2xYCnzJWH4vmbQfqOWbZgTwvlm04NqXNozNkrLbNuO6z14Cpn5+27pO0lnjDBuT2ecezaWcKrYxxDxt4DBp4ZOky2rHU+062SKuoHfvsgnas8CXNjiXN9c4nbbJ6yvPlbysngXaypx8w2XlWGv+kzQsz+Dep6BO+kH86/hRFvbLO8hOcdFgrjf6aQf9Lt5af0MrjJ3jGSfV4sPwEacP8kY32E4aBU5KfIG1uzuknMHdW+tYNmPr51GH6HHL6CfRDPHJnGZ/Se86T/IRpY22Y6xl6zXktPtT51PZM+99C5++43GXWH9L76fjufwf5PB/Zvp6uOnixWde8dT5fXhuBflL7Wuh8xiWvfse49FkclEnvzinbN+s6seirfsl2bcsIfOExz49hjKGOPoK7trOL2vSUV9a6bYgty7gMc7fyyEPKCM/6TZRhQofe30XZMxzZcpby6K8z5oHuq/eyOeWWTW2VWkT0W48BbpH9s6PA3Yuf9OfT8lmlzeczbH8dG9B1xajfrPX8eucz1D6iD8yYXh6+1xVeVdhozInw9K8HovWxwZqBl8AZLokD5WINeMk92gzMAavadptQzz6l+EKcmLs3iX5e9kZN8W7S4O+2qDd+z77S5h4dXd6enwMjXbr2G7wedOT1mHq2wLLsVPLa07YbVLwW+BOA7zn+tF+ix5/1rnV9I77rW+Bd70h516R1F/pcC7vPKQbcd3tdv1Pa62MderPsde5F2UxrtjIWNspe12OR9jr3XtQ73xk3L1t/xLLXPfSSZ642fQHCc9prFSflAF0LGXC9ITfo16/tTcK9futInZehdWQNbRpbfI6v5YBijp/y4a2ZlyHwOd+kDevHep2pYMkFGZeEqfMydF4xx8mdUsYE5ZXQXkV9LZ4JbMkr+Z3yKmuth/K2hnu6phHnPXPFr8e8fzvGc6i/U7ZmY9F94xYfy9ad6oPcjzmeBEb7HTwIc7yfe1CtuSJtWqiZ/zD/vIUe3hDPR25C3nwT82cJetPKLQ2pdcJ4RNH9C/TzGTMIyf+ijqdv5LUm33721U7PpqyNACNSPJDratDrZNM0POmVej41RY/WG3yXk1EvL+RvS/7Tpi+bu0h9Za1JlpXtk7iXJz/e0a6ZYnwwAoxI0RMpPD33RVJO5cGpD3nYDc5XwW006p3DFcGK89hcFyNsKw+wJ9ej81nUJpUx4Thme+wFxn5+dhPaCx+FvfAKw8+udz7L7KdMy5seiGwbPGnPZT/r7STtwfSywT3lKHWo3tNHvSttfjVnjIIxWR2j0O/0UtxfTh9Y2lhxyEHwtmzewATueezpo973irEU2S/4dsgtz9xmvT6SFF+pd757nB2RlDsVUmuL/CKNOq/DGmtWPkrZel+M3W30vs+1dQzV5qBBy0cyZKW17/OrqN9PWNInTV8J/KK++cWQB5+2dvaZlPdg2Ym6ZmvSfk5PnTyRQB91srT5Qk6dvFn3c8rYoU72jNFrnSbwuTao1xIcbfOGNce0bW7JHp2/TNnz1Yx1A+7Ja187ovXypqicpj+mcaOf08+4I2WbjjEO4J48v2Y8X/OK8o5xTZ0TxFomxGPSwEPbiZMGHpav6lTLZFXGnuk8S8sgq5bJFZ3Ye9FaJpSxQtcZg+Z653MHfq+nPF/+Jv8m1PMd+bcqwyV+mcY/aTOWwb+rFX3CF/JP6GJbyrpJg34nHdZKo/+UQf/RFPrzrn1r/76fe42Ep9RhXnFGazwIfOowacN1EE+9quMt1tr3Wo6AakMZK22uSRkTSXF96Vs3YOrnWz6sFdc/g+d7xPUZCxDdQb9f84hrjNaZGcRJzz3WReV7af9b6Pwdl7vMHEqBZcUab4d124ePrqerDl5cbDYC/aT2tdD5jEte3rqtiG1wfU7ZvpXqzXjKdm3LaF2/C20Y06t3vlvrkHXgGyqvZE7Qzg+xZa19sHnlIWWEt0+mfR/LJ2M8xpKzlEeLGfPAyiWRPBvW0OR5bCvgxXEfXqyu9/HMmva/E52/mUd5FPCr1icn1LMFFvGSNre+qsufx4I/J3z4s7o+LnhEgMGLOuQEeOb0zlZxOlEAJ77HYz44ra6PHy+A0zHgdNQRp2MFcKLe9jrHjvV/8+DE+PhhRz4dVDwYjXpj5hXBauVZ13KCHW8kbOpY4TH5Hnr2A+sLOOVCtnYonARGpPCUi36I5xkDeg3pYjyX/hKBbZ4vLjrOWlOlvg9ZU3WcLw3rrBRtz1ZoQ63ySvQcYwM/B9/752EreZ29wXXPCDAi9X4i41141RWg7S24jUa9eyYqgtUaiLL3YjjBjjcSNnWbdRZ8aO0e2j5OvmBrq9RiGI16ffuKYMV5YgaXYZeCnarbmEsjsKjbisRz+nEuFv0X6pp3Qr84yfLVOh/6DHDBxapz9doru23fi9izji9Qb1FW6Xo08jdjw0c63+mbHVH9jqh+Sb5ACA67cO8I8JJ7J/D8/epeHnls1fLK66MInMMlcbB0AnPijuGeXi9pj0enc9x6ZIjEznRdMtqn2xS91nrJ38Jm++Jol35rvJTVr0dwz/NdOdqcMW3tJNvey9ZmLPeLkC96XDra/uZ6nLYdOL6+hPH1+Cu6/UJlVtn8zyPoFypT5Bkcp3nokXscp066q2d/CHNCvwm9ecQHdpMxdb2mdwQ8kjZPgt78jj9+PTbFEeD534DtFPtsDiiY5ANrykmbWfBmsDN/aAfQpgiJ7VF3U9fpM9Sy9B/1/qi6NxCF1eF21KWre23HnZ5ddD/hOOh1OlOh4Umv7LUdU/ToMxX4LvPUg5NxLGO9ipwZ1k8+ofCkTcyxW8QmttaguRdH5k4fYlGF6z72oa5Js2hsvw/njTQ4Xxnb5xyuCFY8EGXnGF2MsC07nXynvZ6F465o/d4VxzHbYy+w7mfzii7szWIv7IW9MGvYC4z/hPjZSfbCRu8X87ZFqGcEB61n8sZwdN3wpL1uIWc1cW5Q7wj9zG+V38mbImvBzG/VtZ217ValD0o92od6v4kxyAdi/nutcfGd6Pm/33hPX7ii2/YhmP+eMUjv+J/le3jHB7aw79/Ma3syJuPtU3rG5BzXxpqU+0n579QFT+3wM2nvjfZVtF62zgX0zsXS9kSbzh/dhLbNb0K2PWeDZVtIXkjWWWaMq8i757qC534bHWfRexzos0t+srUPQ9q8JGUeUFdHUbVywKkO8OpYHe88S8aq8Ix7ZqXN/0yhn/sUmIuq9yloPdLPfQpr7xr7FGo+vG2Qt0K/wOdZIdImze601ksGDNxrirdJdTXL2hOEm6euh2VzCGzKmpMKh5Mp9NCnqHe+06Z8WwdZyj/mkietgTOWL23eCBn96QzbImQ9kfLYsg8po0PyG6xaUpY8ph/HdTevGBV9P3m2rlPDcS4yWteW4th/V4qMSqqjOa7uWXNX/iZPRUYy1j2h8F7o/B2Xu8x6+EL/BPCUNh/IsNmSzmvi3nyha6NqemxX8Gto82c5dRHX27Qu0rbSRtfZ8tRFwjehX+CzRpS0Gcc9mRPcb1s2x6aGe1YOl/yu9yPx+Zauk3vW+VzUrzrOQrnu6ZdYfrX2DagvhqNk3SRtPpcxD6w14R+FDtO+cJkYZ5of4BG/tOKO3LdMHeY0t3rOntFyuYZPafO1DLms69zIe7POZ2btHad1UFMuCy7jwFPa/EdOubxZz3XfLHJZeEy5zHUhzzpveh1bx2YZL9Myivv819p01m+S6lRYOqbsni5Lx3CdoKyOyeuvcR3eqsH4wD6uZ+m1kSr9Cc+8FvoJWgaNAk9pcyJlvPFZ0k/v27TqYXjmD1D/afqYbyJtJlPo2wq2r3XWleeZqNq20Oce7UKbfsSnrTlm2YHy/rSMZWxS2jQyZKy2zbjus9+AqZ+ftu6TtJbY3IDcPu94Nu1Mfa4r7VHiMWzgEVJ729EWaRW1Y6/PkLHajhW+pNmxVddc1bFsbz9A7OE0/kmb+2fwT8ef9BnsVvwpinplneUnOOmwVhr92w36H5pTh20SP6GVx0/wjJPq8WD5CdKG+SOefoLWq0X8BNpt0ubROf0E5s5WVfuBfoIV66oyd5bxKb3nnLqUNuF/G3vvuJ6h15zlHbAeC22L9r+Fzt9xuWt1LOjaRno/Hd/905HP9/NXrqdrK6x563y+vDYC/aT2tdD5jEte/Y5xMU9LPqXNC3LK9s26Trxmd/VJtmtbRucP81wtxhisenPazi5q01NeWeu2IbYs62kzdyuPPKSMcNw/1SPDhA69v4uyR9ezo60nbX4pYx7ovnovm1P+19RWqUWUtMexSK7COHD34if9eW37Wvl0b8yw/XVswIpPyRiz1vOpP0fVvbxrLWl7sKWfxXfr3JwQHBiToY719K+t2KCViy5wRkviYJ3VRr+YNgNzwKq23Wrq2Tx/WePE3D3PXAfmn5F3EwZ/t0W98Xv2lTZjOy58tufnn8HmPGjw2unM9gbXdgcUDWn7VL1tu2HFa72G4j3+Dqpn6/FnvWu974rv+uvwL/465V2T1r9Fn6/B3vDay95ve12/U9rrn85pr3MvymY6s24tX2KD7HU9FmmvM77gcfaXZa976CXPXG3rzDrHvVZxUg7Q1yAD9nX0RZG6Af3WkTofUOvIGtp8e4vPcZFbnONOefEN8pb0r8LvfPJs3D7Uj21YcS9rT+le4Mk2zL1bW+PsjPGseKvQXkW8dRD3LHklv1NeFTl3nPmMMg8pg639YvtgGz53RxduqL9TtqYU32eoP1K2xmsf5H7M8cT8jvEdXdiee+A4Bqz5xPf0Xxgjp4Gf1/4/K/enDfuaTcib94E3t4LetPbPh9Q6KbN/gX4+YwY1dY/+o+BRM/DQ59h4rsm3n33a6dmUtRFgRIoHcp0GvU42TcOTXqnns13Ro8+b5ruciHp5IX9n7UcKOWudNjfj4daaZFnZPoF7efLjHesQTDE+GAFGpOiJFJ6e+yIpp/Lg1IczfRucr8yD5xyuCFacx+a6GGFbeYDkO/3RIjapjAnHMdtjL/ScBbUJ7YWbYS/8gOFne+xF0bFXywbfDPV2kvZgetng3vvL9d4RoYN6V9o8IcUf3Qp7R/q9v1zbJzpmx70jVhySe8I99vR57LdwtEUaRfYLPhdyS/OuzD7wtP0eQq8VX/E8OyIpvzq0FtJhg0ada2+NNessm7L1tRm789yDoOeSrrlPvHWu5GGDlp/PkJVW/Zt3GvW1GTNK01cCv6hvfjHkwaetnf1Gynuw7EThC+eWlaftqZNrCfTpNff29Ts5dTLn8mZaN7By+TzPRNU6zapbqNcSvNcN9Byz1g207DmocKTseWfGuoHID+YlanlTVE7TH9O40c/pZ9yRsk3HGPPE7mnrW+duM66pc4JYy4R4TBh4ZMWxuJeEvuopPKNqGTvZeZaWQaz1IW3+KkPGTir6hC+UsULXpEEzx8mkumc9X/4m/2rq+d61UiR+mcY/afPpDP6dVvQJX8g/oUu3lWvCoN9Jh7XS6B806P9CTh2Wtvat/ft+7jUSnlKHecUZrfEg8KnDeI694OS0/9vUq6xpLjCT1r5pt0mbr+Zc+2Zcv2ydfiuuP4nne8T1GQsQ3UG/X/OIa4zUpccNnPTcY/1/z7N6dA6l5i9tiRrOOj9z1Xq6LmYbgX5S+1rofMYlL2/dVsQ22Nd5p1vVP7H2kXrKdm3LaF2/C20Y07NqtJTNXaS8kjlBOz/ElmXMk3ul8shDyghvn0z7PkVyubj3TtrcMmMeWLkkzLM5jvYL1dAZt59xAvCE38eBv/z+lrFuu8ZV6/HyWHc+EfVeaWu8zOk86ojT8QI4Je3trXKsMpaYB6d+xFO5XpEHJ9Zr91oD3Sp76pzOuW/mkf1OsOONhJ20LlHWlqct7VVXa4fCSWBECs8IPBScvGKoXG/nHkSPPfN51vEvwy4F2zy3W+/75junvi+yR7QPdehW14d1bQ6dm1GhrxtzfZ350T8An3YRtpLTnGwyfh8BRqTeT2S8Cy8bmv461xYczmBo5okDOMGONxJ2Un3mkJqRVhzMMa+pVTSHM2nfWdVjVp8vcvlMxi0LO1W3MY6hY3V5cOSZd0m6psKxmbgX58f94yFTjIfkyR+9el+37fMQ05X4gsd5bczDihSOVo7SsZI4JOVh6Xg85RzHV0jcOq+PInD2l8TB0gmMnbN2l64f6bjHu0eG6PU/wqQ9Snqtmr2/CJvtDVd16bfGS1n9atVY8nhXjjZnTFs7ybb3srWZ5/kGyBc9Lh1t/3Xnl3FMsv6vtHkzxldrZ7dfqMwKyXmnP8bYX6hM0fvu89KjdYej7oo5n7gu+m7oTa8zMdvPOwaYnLdc15U239zbbfs+f/xWeXNM4dOG/QHA7ucZs3rvN8fPO8Gb/40536+60lbteUv/Ue/rehNl8mmddGnLM4+M+woiwIgUD+TiOVZetSM86ZU9rKOKnpr65LvMs0/Nil+H5CrQZ2HtSq73yfOtvJIiNjHrSOhae9TlfYhFTRWNNVAv1XxwahaN7TOPy2tucL4ytu+RozJg0Cd/b7uIYVt2Ovmu7fU0HJmr3oca+j32gsBo6+P/2IT2withL/ynYS8w/hPiZyfZC1ZeWej+VM5BjddACl6etgj1jOCg9UzeGI4+JzQpz0jGWpXnDVq1eKwcSnl+nlo81HVJtluVPqhVx947BqnPzWrPr6M7u7C91rj4TvT832u8px/E/D/Zwc87Bukd/7N8D+/4wBb2/Zt5bU/GZLx9Ss+YnOPaWJNyX8cyrDPe7tjhZ9Ez3jjWrVpnnrlYVu25u+x0h13YtrktZNt3b7BsC8kLsWpv0G5hXEWfq+Rds0HHWbhWIPdZ/5i2B9tKmwemzAPq6iiqVg5M+PCocF3Th6bQz/z/Y8BX5/9rPbLR+f/jPrw165rqWtusa5pmd1rrJQMG7uOKt17nLBFuVo2dJJtDnnHcoCdKoUfuMdbkJMsLx5qYR+qZS18kP4y59F5jvWgu/Thw8ox/jRfAiTEXp/z+JmVQHpy49nnCkU+HFQ9Go155UBGsVh454wQ73kjYjBNacpgytIgcljHhuaZUdP8HYxeeuX0Ch3qRMbCKYMV5YmuXYZeCbeb26ZpRfOfU90VqvVp7FLkW4xTbi2m3cP/ja3Z2v98M39RT/4htHgFGpHgoF/WP0z68Hv3D2m+X9Y+P/mFcsaz+oR/vuW+qiP5h/q7nnkgd37i8d2nLws6tfwQW9U9IHN5xvsTca83cyndDv3jtqbZy5AQXntkpbV63u9v2fYh9WuuGOj91IFp/hqj8zdjkMQWfOGp8rPzbEyVxYDyH9cT0+d2Uc1atTnl+nvOXB6J859DqM1FDcaBOOAK8dLwo6bw9r7nAdR0dfyRMxiRJL/tKm0/CZvunnV36rfFSVr8ewz3Pd+Voc8bW2UBaN3vZ2lyH+SfIFz0u9bpllev6AwatY4ofHF9fxvh6wq5uv1CZpdfiiI+Gba3tMpYfKlP0+ldeeuQex6nTmdQx55PAaL+Db0FvHvOBvboOw9otnLfM0ZI2T4be/C9//HpsCur3gV1d2E42RbOoTTEP3gx18KMdQJviiLqXZ4xTd1PXyXfWCEvTf9T7IXallVPm6Yc5rkO2mAMdAUakeCDXBOj1OnvUk17JLT+o6NHr03yXeeJclo8fuu9Q75WgbGetYW3HFrWJucYpc+cI7sncoe3gpAOmisYaqJec8vSalFN5cGJ+jdfc4HwV3C7vb68WtmWnk++014vsFelXbqnoaOaZTW9Ce2EM9sK8YS8w/hPiZyfZC9o3DLXVaXscNPAaSMHL0xahnhEctJ7JG8PReWnUdXw/es9u0blBvaPrAfD9kzd5fCK5l5a77rjfukE9Snie+3T1uUTt+fUgzH+vNS6+Ez3/Dxvv6R93dds+DPPfMwbpHf+zfA/v+MAW9v2beW1PxmS8fUrPmJz3Pnm9t0Po4D55afP0Dj+Tcsu1r6L1Msc/8/I916u1PdGm81mb0LZ5A2Tbj2+wbAup8UM5Zp2PxriK3vflaN+uqxfC8UyYa2cURr22B9cVpM3LUuYBdXUUVSsH+nkepfDMOo/yFSn0M7eceZA6t1zrkX7mlm+W8yiZ4yRt0uxOa71kwMC9pnhLe8I64yLUniDcPOcUWjaHrlU5EBWruUSfQurt06Z8a4ehlH/M96ZeoIxmLF/avAky+rMZtkXIeiLlsWUfUkbresh5YoWUx1atFcbDZcxx3c0rRkXfT54t70HDlHucRydAs7R5T4qM4rlU1rkKfGd67srf5GkfzwgzzwER+q1zQP44w2abVPQJX06APqFrEvRNOtKn9zltV/BraPPBnLoobZ+TtpU2ep+Tpy5K2ufEPU3SZgL3rJz4kPlCXVfDPSuHS37Xe4b4fEvXyT1rLzX1q46zUK57+iWWX619A+qL4ShZN0mbL2TMA2tN+FnQYdoXLhPjTPMDPOKXVtyRe1ipw5zm1qrc0ufjUi/Jp7T5twy5rOtT6T3GSefjOq2DmnJZcOF8ljbfzimXGSfSclnbR5eiXBYeUy5zXcgpzmaezS24EKb2m6347Rq+nfWbpLMFLR0jffcaMPXzqQN4Pq/cs9YJyuqYvP4a1+E1jxhv78d6ll4bqdKf8MxroZ+gZZBVC6OeMt74LOknfKGMtWpheOUPUP9p+qzayWdS6NsKtu/aedWQsZ7yTNsWut4M8//7EZ+25phlB/I8PrZhbFLaNDNkrLbNuO5z2ICpn5+27pO0lji9Abl93vFs2plCK2PcowYeIXsik+rSOtkiraJ27D0zZKy2Y3V9LMuOJc0cJ4PqnvV8XceV76IPtRrNWLrFP2nzwAz+aX9a15+14k9R1CvrLD/B63yZNPq3G/Q/PKcO2yR+QiuPn+AZJ9XjwfITpA3zRzbaT+A5EUl+grS5IaefYNXd22vA1M+nDtPnZ9BPoB/ikTvL+JToDtamtfyEAWNtmOsZes3Zqj9B26LK3KWBqHfNjzyy9kb8CPL5bt69nq6tsOat8/ny2gj0k9rXQuczLnn1O8bF+Suf0uZFOWX7Zl0nXrO7+iTbtS2j84d3Rb11f+SePl+HNj3nSxGbnvLKWrctW9+DuVt55CFlhOP+qR4ZJnTo/V2UPcORLWcpj16bMQ90X72XzSn/a4pyNQKMSNEvF/fEO+W7NSiLqZPlHm2K0Lq3XvxMi98wZ0LavCnD9tf2i/CDtj/rsMg9bQuF5ltTl9FfyMN3XWe0ipxv6lh9nkZoLJf+J/VmHllm7bEqG08eBl5yjzYD13eqtt0G1bP1Oi1xYu6eZ67DhOKbwNcwhZ+kQ/dtXwc6k609Pz8Im/OoweuaI68Pq2cLLMtOJa89cwBril8CP2l9sWqeaL9Ejz/rXev6RnzX34B/8fGUd01aP4k+/wZ7wykG3Pe8Tv1OGYv5bE57nes7m6lm8Fq+xAbldeqxyFgM915YuYtV5WJ66yVPH4i+QNLexwplTmytz3Let7/v70wGSx4n1Q3ot46cBO6WjqyhzX9u8TluxVudcl4a5K3QT7nZvnahzTHww6ueqiUXZFxqmKt8Um0oL6TNFZ3BUCQvo2x9LeYWWvJKfqe8KpJbmDfeytjqftiGz9vThRvq75StKUU/NdQfCYlrUq/0Qe7HHE+suXpqTxe25x44joGkubL23nAGyNXAz2v/H3lDPG+xCXnzfsyf20BvWvvnQ9ZrGI8omvtJP58xg0F1z4rDWmvKIjvpGznZ8av1fM44PZuyNgKMSPFArjOg18mmaXjSK/V8hhU92tfku9S5mfK3Jf+t/PXQsyWpr/YrPKuQ7adwL0/uoqNdM1W0rhTXtr1ynimn8uA0AZy85gbn6yg+OYcrghXnsbkuRtiMOdOeE1j0R4vYpDxn22nM9tgLjP08chPaC78Ie2HJ8LM99qLo2KtlgyftV9FrDnnXUGQMcdxoOWrZOtb+FS8bvN97R9LOLntiij/KGAVjsptp78ia740YhdfZSZZ9omN23DtixSFr4G3ZvAGeP2/ttwixt628B88YS157iHEC733gen0kKb7ieXZE1bWQ0vLOhUZrrHnU12bsbivt+7w5Q1Za+z7fbdTXZswoTV8J/KK+ucc6vafPXXTt7LdS3oNlJ+q8U8YU6Ed46uTBBPqok6XNm3PqZM7lzbRuYNV88YzRa50m8Lk2qNcSHG3zhjXHtG1uyZ6jCkfKnndnrBvofSuU09sNmPr5lpymP6Zxo5/Tz7ijxx4fyjvGNYVWxjUHDTxOGXhkxbFY64O+6iSeUbWMPd15lpZBk8BT2vx1how9regTvlDGCl2nDZo5Tk6re9bz5W/yb1A937tWisQv0/gnbT6bwb8zij7hC/kndLEtZd0pg34nHdZKo3/CoP8fc+qwtLVv7d/3c6+R8JQ6zCvOaI0HgU8dJm24DuKpV3W8xVr71ufESxvrnPiv51z7Zlw/ZB8i9b0V1z+N53vE9RkLGMdzBKbmEdcYqUuPGzjpucf6/151knUcj3rcijUOY932mr3r6bqYbQT6Se1rofMZl7y8dVsR22B/52VtVf9kLW+lT7Jd2zJa1+9CG8b0ZE5Y65ChuYuUVzInaOeH2LKMebK2WR55SBnh7ZNp38fyyfTeWS1nKY9unTEPrFySU5Dzeu9NG/5+tGVMjnJW2jQhZ5f3rn8u65nrGucDUXbtz52AtRf35PtxPH+7uhe6XkPZS1tYn2vuHeevqWfrmHv7voxlGSvyG2OH0uYuKWNlJ9rxnZ1S9zahX2nqDqHf0h33SOGDJSuFLzwj1PJ7TjvSN6noqyn4NbS5T07dSJmjdaPMuc2iG8d9eGvm/OrcIOb8UnfpeniMdZ9Q+PL5OtbNHKBx3BM5RltVfqeMG1fPHzeeL/e4vqV9AMbdmJe5DN2oY/gLnb/jcpeZ52ydT8G61km6Sdo8JmMe6L5tWu+CtRLZQ0p5qOvZ5PUVdL6wlcdIX4Hvt6yvYK05UIc5zS1zP5LwnDaYtHlahlzWayr6nJPNUJtZcLH2Yjwrp1zm2T9aLmv76FKUy8xpkDaMR+11xCmpTqt1hqOWUVz/kTY/lTImknSMlkuEqZ9PHaBrklh5D1XoGOoTqx6OriFCWcw1yqOQxdrnJB8s3svzrRqWok/SauJX6U845nG1aF9oGcT1c2nzKxkyVtsqwhfKWMZVhb6aD31N6j9NXw2f0uY3trjtu+b7Q8Y6nQXXsGwLgU8ZK204nj3tQD3HLDuQ+5XYhmNT2rwtQ8Zae7nKxrhY10vj1h7H/3HVhe9JsZIQGV9Etmnbswo7lnamrmVkxa65tkI8QvfjONkiraJ27IcK2rHClzQ7ljRznEyoe9bzdY463wXtZE8/QOcDW/yTNh/P4F9S/iv5p+NPUdQr6yw/wUmHtdLorxn0f2Zr+QmtPH5CP/OhLT/BqqXv6SdovVrET6DdJm3+X04/gbnXZf2E/bgn8pl+iPxO2b1fPX+/8Xxdb5N+AuNTVq6q5lF7Pn0AulTXf6Telrmnc6a1PVP1uvUx9WydJ893/19YT6nvW08XZf9+dS8P/629LrQbqrAR0s5rSbMR6Ce1r4XOZ1zy6neMS8aXZRtc1XmnZWr4b+S6teirfsl2bcsIfOFxUg0IXYObNj3nSxGbnvJK5oS1t7yILcs8IZ4tkkceUkZ4r1vrfQzCf8IUXgxHtpylPDqdMQ9039V9DFd1afXclzym8BlQf9fwnfuTvOwJymKOEe2r55HP7DcO3L34SX9e5KPOm2IcrZkyLqzYgPCDtSJ1XRTqGupPfZ5k3rUW5mdIvzx813XxQ3FgTIY61tO/tmKD1jqmzrepQi7WgJfco83A9Z2qbbcJ9exTii/E6ShwmkQ/L1+6png3afB3W9QbE2BfafPqzpxrz8/7wOYcM3g96MjrverZWi8SJ/J6wpHXg4rXAj9pfbFqnoypZ+vxZ73rvYpvfNdPx7t+WMq7Jq2PRJ+nwd5wikv3fW+6fqeMxSzntNe5v0nb61oX9NNeX8uX2KBYjB6LjMUwvmCdARGSa0H7xrLXPfSSY+ywQV+A8Gh7VChz4qQcoKdBBrzKkBv06/Ueio3QkTofUOvIGto8Z4vPcSveuhG55Jxva3n64IfnPiEd99IxKPoOw6rNfvSTNj+dMia88jLS9vEwF5fyqkhefA33dF0HznuZv5zr7e+jY124of5OSA64tUZbxh8JiWtSr/RB7sccTwKj/Q5+FfaX03xq8p1oG4k8kDY/MdZt+5vAzykeElu5P23Yv70JefM94M2boTf1PGC+EeeG5/4Fq3Y19QnnR541ZWtN1cmOX62RebXTsylrI8CIFA/kuhr0Otk0DU96pUZmTdGj9Qbf5WTUywv525L/1pmeHOMh9aAo20/h+WVl+yTu5cmPH4ncztacYnwwAoxI0RMpPD1znovW7ezD/p8G5yvrOHIOVwQrzmNzXYywrTxA8p3+aBGbVMaE45jtsRcY+/n7TWgvTMBe+ILhZ3vsRdGxV8sG996vQltHcLBsHWsPppcN3u+9I0KHtXfk33LGKDbr3hHR35vxHA8rDjkI3pb1WSdwz9pvEWJvM++Bet/JFmkU2S8ocQKuxVaxDzxtv4fQa8VXBM7+kjjwnWblV+v96Xlp3G/QqHPtrZy64wqvUBxII2N3nnsQdOxO59AT72HVZr9BS73TMUlW6r7tMfvjyCEkLOmTpq8EflHf3CsP3svnLrp2dpuU92DZicIXzi2hi36Ep06eSKCPOlnatDLGmehkzuXNtG4gY4c62Ut/WDpN4HNtUK8leK8b6DlmrRto2TOmcKTsuS5lTNCHEtp3ROvlTVE5TX9M40Y/p59xR8o2HWMcwD15fs14vuYV5R3jmjoniPs/iMekgYe2EycNPCxf1anWh1njUN4pa31Im4dkyNikGo+UsULXGYNmjpMz6p71fPmb/JtQz/eulSLxyzT+SZvlDP5dregTvpB/QhfbUtZNGvQ76bBWGv2nDPp/MKcOS1v71v59P/caCU+pw7zijNZ4EPjUYdKG6yBO+79Nvcp9RQIzae2bdpu0eWqGDrPi+iE6xDp3h77MGTzfI67PWIDoDvr9mkdcY6QuPWrgpOeetNU2VtX5gjqHUvOXtsQLEWv8rbH1dF3MNgL9pPa10PmMS17euq2IbfCqLe6frK0t9Em2a1tG63rWP2ZMT+aEtQ4ZmrtIeSVzgnZ+iC3LmCf3SuWRh5QR3j6Z9n2K5HLtRT9p86aMeWDlkkieTfv3k5374/j9rWPd3+ud+yfx+9vAq5OAt9D5jEte7eceAT+qtLF4jkwEGLwomwWPNk7HfXBqXBl143aPXrnpnitP//7Fx91wdvGmG258/P1WfvjJK0+6aQCg9fY//pZEyjbcG8H3k8bvvAZAtjzvuOrj+Lqa7Wc7HUe86k7o7dNCB7cKSJv3ZbhTerulvCd55s6oy/uD4N0JH/pWUyyOG3hGCk+5TgAnp+2WU0WnH/nkNA4aDJvnwYlmllepIB4vkwcnLmc4pSY2uS0/D050C7yWWBhiZLltqtlqYDWn84QufWBfSI/ZKNhJW8LLLsHJmHAMzbd2KJwERqTwlIvLzV5mIF1OpqvQ5awIVpzHlb0MuxTspr7hHUbyToUQXZhU4rHCsE7ilqyvIXzzdbgbXnYmy+9EgBGp9yMX3QKvIzZ3AI7gNop7UVStbjuiaJW/t7nCvjBXNwo2dRuPmRVY1G1ZOO7CPW4FdLJ9WjsUTgIjUnjKRX3rabcKHMFtNOrdKlYRrHggyt6Cdhl2Kdipuk3eb5Xl2Dy33jPcJTDa+mX//i5sJ1m+WiqG5X5qwIUhSmlz1cFu28Md/FgqjcsLIbKKx19Tpx5V/axjuT3l5U7c8ygZa6XkWSmHnmPcKknBpSnGPEYAq8q5wJC9LIfQXxeY9N9Ir7XkNtUhsD1m77y/S781XnRaaVFe8mivrSqPrJLKOn7jZWtzOeDOkC9WWRzPYw81rboUGMfXXTG+/nh/t1+ozCobv7COFZN+eWWKPIPjNA89eou7o03Xs8WIacX39debTUtvahlAvfnpA922D/THL6bfeBR4PhiwvXzWAQWTfDgC3kib14I3D8ecl99pU4SUv6Xutsqvsoxdmv6j3h9R9wai3vWrGv62UjNG8OmkS1tcBvXw8YpsST0Jer3Ssjzple3aexU91rEcAj9PSUEZxzLWq0i7OoJ7VjkQbccWtYmZxqC3dVCX98GvL1w6lHrJKVZZeD2qD0fW9MT2uR51Ob5erR2r7RHynfZ6kfh6H8oexElHprx4E9oLz4S98FLDXuB2vBA/O8le2Ogth962CPWM4KD1TN4Yjs4nSdouqdNSi86NrHKGIeX6eVwCU6QZ/5BP8q5KH5R6lPCc1n575j/Tqd+I+e8Ub2jynej5P2a8p/tg/r+lTzFI7/if5Xt4xwe2sO/fzGt7Mibj7VN6xuQ886co95O2UFAXfLhDcFK+ofZVtF7m+KcOcrIvGpRtR0DnxzahbbMfsu1vN1i2VVUyIqk8rbx76lXPrdA6zqK3ydBnlxR3ayuPtPmnlHlAXR1F1coBp1LSq2OV6fS0G7ntWtp8OYX+vMfqaD3Sz60ua+8aW11qPrxtkLdCP/269rULbdLsTmu9ZMDAvaZ4m1Sataw9QbhFSsPQ5hDYlDVZ+f1JPsWhznfalIMdueqd91IkX7vfeS/0xeTeAcAtsg65L7DfUGA/eadtenYretr3RAbxne890P29c6r1Wt8dnedH6Nvu85nWhe/Uk9xzQPuBupxrPmt7NaDLrz+w/rnU5SHrztTblh/hUbbO0tv0961j5TxkqbYT9BGFlIeiy/WRr5SR13Tej6XLkkr2nlT3LBmv9zFxWyzXROoK74XO33G5a1Wnj3eepcdsHXhKmziFD3yW9BO+8BhYvXVvJPI9CrCu6Nuu4NfQZiaFPtosXJfVNou2qTe6pJ+nzVKPulcN8FmOTtqcxD2ZE9zaHzJfaBPVcE/kGPW+/K73rfH5lk0k93i8oT4uzYrHUa57+q9W/EX7kNQX+mhb6iZpc++MeWDlDnwM/qh1dGloLDzNX/SIc1vx6aSjUZ3mVs8xV2nHU0ubR2bIZV1SS94b5bLoP5b5clovN+Wy4ML5LG3O5pTLtJO1XNb20aUol3n8trShn+m135GxE8FJx/AZV007flva/HDKmEjSMWWPx7Z0DNeTyuqYvH498zWs47ff2Md1T6ucbFX+hGf+E/0ELYNGgKe0eWGGjNXrksIXylgdU/TMM6H+0/QxL0navGSL275rJRshY73iJpZtIfApY6UNx7PXvjsrvq/tNM5DLWO53iBtXpMhY7Vtxrk/ZsDUz7fy05gbY63LvHgDckC91z1oZwofuBYyYuARelSylTfkZIu0itqxby1oxwpf0uzYqss76zUPbz9Ar7lY/JM2787gn/anhS/kn44/CY1yWX6CVx2ENPq3G/R/YGv5Ca08a06eR8MmrTlRhzEOKZ+efoLWq0X8BNpt0uYvc/oJzLEu6ydYOdZcUyubY81jPUV3MD4luoNHWmgecb8Hcwi4nqFzE+Qd8FmMMbX/LXT+jstdq2PhmHq23nfJd/95rKcMH1xP11bIjdB5n3ltBPpJ7Wuh8xmXvPod42I+n3xKm6/llO2bNZ9gze6CbPdcA9O2jM4z5xF+jDFYpS21nU3ZECXwljl/3BNire+H2LIs3c8cvzzykDLC2yc7pujQ+wApe3TpTNp60ubKDt5ZpTO5/5B7Hj332hxV+Ayov2v4zrxIz9w+gcO8VrlXB9wi+p22kBc/uWajay8wHrmWF5wyLvgs6Sf8kGdSV1r5At77GqSfxXfPo5S8y2vnjX941t7Ks35Vte2ma2/VFF+IE2PdnvmLtCvIu0GDv9uiXj3EvtLm2ah3MgOb86jBa88S89oGF1isT3LU4LWT/dEkDtr2Soo7Vc2To+rZevxZ79ryL6TNo/Cur0t516T1rujzSH97I/Z+p8LDoch+pzW0uT7DTslzPKbWBf2019dsMtjrnvnntI1o79FukTaMz4j+oz2tfV7LDj2meLsrWh9b60dNSK96pVaejt4nU6HMSaxT80jIgGcZcoN+va7jvRE6chy4Wzqyhjbntvgc73eOv/BN6NfHd+9CG8bYjjnipOetzg2y4q362Fm+xyeljImkPQZl4ws13OtXXgbfmcxXrlM+C/P+Kwe7cEP9nbK16uinhvojVe2XdpT7MccT4z0vhv3lte+U70TbSPTZpc0Nh7ptXwr8nOIhPbwhnv9jE/Lm1uDNK6E39Twosz8ibZ819XLa/kSvNXknO3617pPXUYeUtRFgRIoHcvEIYa91Tk96pe7TqKKnpj75LrNyDJJseo9aGDU8v6xst9YkudagbWPHdeSpoucncK+d13pX0VpUNeDkNTc4X1kjlXhUBCvOY3NdjLCts0PId2uPbhKOtEn7kH/UYy8w9vPHm9BeGIG98GeGn+2RI6hjr5YN7p1HSFtHcLBsHW3DeNrg/c4bYP0F+ZQ2n8wZo9isec2bJW+APrC1n8TKGygbh7TyBpgfXDZvgHrfK6ctrz3EOEE/a+YLvRtRM1/XkgrNjSO/SKOOm1lj7YTCq4r8PMbu+plbos9msHJLTiocSctwR4cmyUrdl+dQUD8yZpSmrwR+Ud/cY53e0+cuunY2lvIeLDtR5xQxpkA/wlMnDyfQR50sbY5kjDPRyZzLm2ndYG0PDXRyP/dOCnyuDeq1BM+8KstetnQM41pJ9ru0uTplTNCHYk6zPo+waEyE/pjGjX5OP+OO/azLonOCuH+GeAwaeOTZK2P5quN4RtUydqLzLC2DxoGntLlzhoydUPQJXyhjha4Jg2aOkwl1z3q+/E3+DavnO/JvVYZL/DKNf9Lm+gz+nVL0CV/IP6GLbSnrBg36nXRYK43+mkH/fXLqsLS1b+3f93OvkVWTYMKHtw1rPAh86jBpw3UQp7qmpl4VXCxbVesw2m3S5hEZOsyK65c9U8qK61s1D0Lj+hO4l1b3xtovQJvwfxi69KCBk557a/G9qHcuVZi7Y+ZQav7ST7oRscaXHVpP18VsI9BPal8Lnc+45OWt24rYBs/a4v6J6Kt+7SPVtozW9bvQhjG94+gjuJfde8l1SKsOWIgty5hn3jpgrC0iMsJxvcSs/6B9mjR9xvoP0uYVGfPAyiV5MeR8Wh1amYd14CM8Oo32Vcv5SdBJfE7jvrT5hQwbdzKBlnHjWb+c81nST3hb73zSt5C226JeeiKjLe2uMxn9iMNh1Yc++CTgyHfa6NK32jHeWF3HPQMcyXMNs30NqzZn0E/avDFnrE3e8Rk8W9pcjecmjSlp85YMeFcnwBs3nvV7OZ8l/WRMyTM5TqTttqiXT5HRlmMqqx/f16TqQ71AnM4oOCNRLy0Lnc+4zNWIY+JE/InfKYX7CNp5yHAtB+qKP2njm3Na2nwgQ4brvu1xt69TiHknfqf9wDWrNhzufYk6PJpE+6plOPOsiA/plzYfzBmn0LQMG8/6cMGYh6yXWOdFSttt+M71f7alfXU6ox+/11Ufy44hHJExI+jrIcNPA0fynDAZC2AbylRp83cF3zGfIW0ou9iHY0ra/H0GvDMJ8IaNZ30+57Okn4wpeeZO4Er9Lr9zTLItx1RWP37fq/pwz8KpFDiM5bSvhc5nXObqyHDir+eEpWMcc0Ib1js7rPjDOaDHN8ehtPl6hgzXfdvj7v90BrcVS6DPkyT3dDywahlOe4b4TOC+tPlOxhwZT6ClZjzrv3M+S/pZaySCq7Tdhu/0Jdm2jvunMvoRh/2qD2N/44Aj31mvycfXvCDDta47rPDlO9VjnPp7LVbZ+TGr9pu8Yx0rtnw7a0xJm90Z8CYT4NWMZ+3L+SzpJ2OK8lJwpT0qv+cZU1n9+L7GVR/W+bJkeL3zSbuufS10PuMyV0eGjxv4E7+6wt1bhms5YMnwpPFN2SZtTqWMkR1G3/a4e48hw5mzqevXyjMoAxhTrVqG10En8SH90uaWGXOknkDLmPGs2+R8lvSTOJ21r1babsN35hCwLefTREY/frfWUnT+UVLOjqcM13FbS4bXO9/1GKdMlTa3L/iO5RmsM699O+nDMSVt7pwB71QCvDHjWXfJ+SzpJ2OKa//1znfqd/m9jv6WX52nH79rHcK9AfUUOKxj0L4WOp9xmasjw4l/XeFJ35NxHWnnIcOTbBTC5LpEko0ibe6XU4Zz3L0cMlzLoTZ8ve4pZ1kdBHxp8+DD3bYvOLz+ucyNqql7A7gnz5W/rXXHGu7Jd66j1NU9S+7Wjedr24VjlPJZ5jv3i3nqe537IO+BMMUekbEivx0CzdLm0SljhXFzvrMz6p7lS9LXlWeJn0j/9mpFz0Ln77jctbqWek3nWXrMMg4ubW7MkKvXKPqEL4dAn9B1Dei7xpE+HYOfUPAZg39yhkyQtWLmOmymteK1OATWiid9eNsgb4V+gU/bSNowxiRz4jR4K304X7Ly6hgPon+ha4/uwO+UcZPq+ZPG8+Ue16K17uF6Gm1+kevea8UHFR36XEzqi+EoWTdJm5/OmAe672odLejGzpJDjzwcVPfocwn8PHmn1DvUYePqnuX3jRvPr3e+W/EX6jAZZ9RhTnOryZiilsuMi0ibmzPkso7Ry3ujXBb9dxr0Oa2NmXJZcGHMVNr8Sk65zDNHtVzW9tGlKJeFx5TLtN9rjjhp+512lsCU96dlFO13afOmlDGRpGO0XCJM/XzqALln6RjmZ5bVMXXc0zEk6pgJwNQ8auN6xPBTqAuH1L08fKA/MYR78t3Dn+j3HgPhJeMT0uZPMmSstlWEL5Sx9c53rqM55Wmb9d8OKfjUiR/a4ravlQM/5MNbM6Ys8CljpU0d/PC0A+sKJ8sOlPenZWwd/aTNJzNkrLbNeC56zYCpn08ZSFtSnqVxa//2zQ6wpFhJiIwvItu07VmFHUs7s975zpyOcQOPUwYeWscyhifPkrlPve9ki7SK2rFfK2jHCl/S7FjSzHFyWt2zns/8HHnWuHq+tx+g808s/kmb/8zgn44/CV/IPx1/iqJeWWf5CU46rJVG/4RBf+1IMv2b0E9o5fET+pnbYvkJOme133VVi/gJtNukzZ6UMUE/QXRJFX4C93GJfKYfYuXwFNkXwXUi0R2MT4nuqAOm5lEb1/dDl8rvXM+gTubckLbanmn/W+j8HZe7VsfCIfVsgUUbY83/OdLF9W5H1tNF2W+tv+epGSVwrXMlq7ARZPwUtRHoJ7Wvhc5nXPLqd4xLxpdlG0zllO0cM1q2a7uzn/7J2tpkn2S7tmWoL9vXLrRhjEHmBGMM2s4uatNb+W6s/RRiyzKffwj38shDyoiRqNenrfo9HIp66RD+W/tlhyNbzlIe3SNjHui+bVrfNdil1Ul3T1GuRoARKfr1d08/nfygTta+2ICBm7YD2W8fcPfiJ/15bfvW8CltHpwyLvgs6Sf8oO0vY7KOe/Kd+nNc3cu71iJ465ge+1l8H1V4heLAmEwNeHn611Zs0FrH1HnAVchF5jPpXPp+7c2UZ+u9CMSJ+9E915y4V4S8O2Pwd1vUG7+39qq8Gzbnk2Fz7jd4fcqR10Pq2QLLslPJa0/b7pTitcCfBHzP8af9Ej3+rHet/Te+61/Au35OyrsmrT+BPjfD3nCKAffdXtfvlPb6C3La63Xgu5nWbNdiDBtkr1uxBGlzEPd4LobgLnwrki9I+yZtf0qVesmzThF9AcKj7VGhzImTcoBuhgx4lyE36NfLO2Tsv986UudlaB1ZQ5vXb/E5LnKLc/y0D2/NvAyBz/kmbXhGmGe8VfvxOmeYvsOwasM4nLR5S854q9AeGo9jPPQ07lnySn6nvMpa66G8ncA9mYeUwdxDL5/vwry/zdEu3FB/p2xMmu8z1B+RZ+j6qFn0yL0+yP2Y44n5HX8G+8tpPjX5TrSNRJ9d2vz60W7bvwB+TvGQHt4Qz7/chLx5HHjz19CbVm5pXd2jzJLnyt9WPKKOe/I9bf8C/XzGDCbVPfqPgsekgYfeI+m5Jt9+9rVOz6asjQAjUjyQ61rQ61WHxZNeOTNqQtFzWtHKd5m1ByTJppcxwjFexOau4Z61JllWtjO/P09+vON+sSnGByPAiBQ9kcLT0f5rUk7lwakPedgNztd653M06p3DFcGK89hcFyNsKw+QfKc/WsQm5f4wpzHbYy8w9jN8tAvbyVZpUodre4E2rbT5HtgLV3S+W3vty+yntGxpTb+VW6hla5X7VcgnwaFu9NM2jKcN7ilHqUNlXAgd1LvS5khnLGTFKBiT1TEK/U77GaNYq43Sp70j2j7RMTvmhFlxyFPgbVmfdRL3PPb01TufjrZIo8h+wdtAbnnmNuv1kaT4imduXFLu1JC6l5fGgwaNOq/DylGx8lFCcCCNjN1t9L7PpFzJgwYtd8uQlda+zx9DDmG9c9+KGY0rPhDvPLo2SY9u1Tz4tLWz+6e8B8tOFL5wbll52p46eTKBPupkafOQnDq5Dnw3k062cvmc4mZmHVmBz7VBacPx7GSbm/s5LR1TFz6pNoxJSJtzKWOCPhTzEqWvZQvr51NO1/G7PEvjRj+nn3FHyjYdY8wTu6etz/wf+c64ps4JYi0T4nHGwGOT1TJZlbHXdJ6lZZBVy+RZGTL2GkWf8IUyVtcyIc0cJ9eoe9bz5W/yb1I935F/qzJc4pdp/JM2L8jg37WKPuEL+Sd0sS1lnVUrxkmHtdLoP23Q/5IKdJj27/u510h4Sh3mWQtdjweBTx0mbSbBj3FHnLReFVwsfaJ1GO02afOaDB1mxfWlbxEdYukw+jLX4PnaZs5jf2fF9RkL0DXQqUtpE/6lsYZnnfOQFOvTPnr730Ln77jcZeZQ1sEf+ZQ2b0Ss8cOXmI1AP6l9LXQ+45KXt24rYhu8K6ds55jZ7PVmPGW7tmW0rt+FNozpWTVahG+huYuUVzIn6nh+iC1r7YPNKw8pI7z9RB2jKpLLZa2pfCxjHli5JH9m5DjWAX8Mba2YVQ1tPgk5e+Wx9c/l2eSj6t5AlO/sPIFlnZ13GM+vqXtVxLHquCfjirHDrVQj8/+mjBX6MnxnZ9S9TehXFq6R+dVAv3Kr1Mj8ZgXrafqMzI3WjZM+vC1VI1PmBHVjyHyh7qLuFTlGW1V+p4ybVM+fNJ5PO1/u1dFH7olsG0d7kevt96B9lIXO33G5yzzjXuYbYQov9FoJdZO02d3BO2uthDpyCGslsoeU8nBI3bN0urX2pf1Ky8dizgHf77h6/rjxfHmH47gn3+u4J2OaOsxpbhWukVlPeV98lvSz9sdu5hqZZzLGo8jlfcBXy2VtH12KcjmrRuY+R5y0vSq4EOZaPohqM4p+0qaZMiaSdIz29wlTP9/KM7V0DONdZXUM9Um9850+mT7LgbKYcvLTnYcn5YjtU/cGcE/w2KfwpD+xD/fku4c/4RgjLVwj854ZMlbHpYQvlLFC1wToc8pTK1wj8745ZexmtX3XckEgYz3lmbYtBL5VI5Pj2dMO1HPMsgN1PRar7oa0eWSGjLVi/mX3u+3DszRubTjvNGQb7Uxte1Yt26z4flk7to57QutB3Bs38Dhl4LHVa2Q+paAdK3zJWyOT4+S0umc9X/621hZoJ3v6AUVqZD4ng38Xe43M528tP2HL1sjcaD9BcEnzE6TN/8zpJzBHVvruNWDq51OHyb0x3NPnQe/A75TdY+r5Y8bz5R731Nc73xmfsuriW37CC6BLdT1q6m2Ze9KXNTJpW7T/LXT+jstdZo1Mnc/Md/+rx7q4/smx9XRR9o+pe3n4b+V0026owkaQMV7URqCf1L4WOp9xyavfMS5dP4Ey6fdyyva0GpkbWcPfyqvdiBqZwuOkGpnWORzazi5q01s1fa089yK2LOMy+3Cv3vmeJg8pI7z3MegamcJ/whReDEe2nKU8+mDGPNB9V/cxbOvSOupD6xTlagQYkaJfLsHD054gP6iTRxU+lt2h7UD2OwDcvfhJnaFtX+IvbT6ZYftr/SP8oO2fdk4E9WeIfUQfmDG9PHzXNWiqsNGYE+HpX1uxwQkDL30mUhVykflvco82A/ONq7bdJtWzTyu+EKc6cNpKNTKvO37hsz0uvwmbc8zgtWeNzH3q2XrfGHGqAydP207XyBT4k4DvOf60X6LHn/Wu9ym+8V2P410PHl/PV9oYa/ocferHu3Q7xYD7bq/rd0p7/coOvWXyTDdyzVbGwkbZ63os0l5n7qnoP8bNQ/IFrX3u3nrJMXbYoC9AeLQ9KpQ5cVIOUB0yYMGQG/Woe0/eIWP//daRRWpkXrPF57jIrc1YI3M/+DHkiJOWC8xhFpg6L0PnFXOcTKeMCcoroT00HmfV+kqSV/I75VXWWk9Sjcx65zvjKDJfGb9bwLx/8/Eu3FB/J2Rdc1dk53qE+iM6d7yoXumD3I85npjfcW/YX04+e5PvRNtInCvS5pYnum3vB/yc4iE9vCGeD9yEvPkK5s9DoDf7lVtaxz2ZA9TLMrYYM5hU9+g/Ch6TBh6Xa2RerpFpyX/a9GVzF6mvrDXJsrKd+f31zncrBi9zydGuKVwjcwg4Odl/TcqpPDj1IQ+7p0am4Ha5Rma1sBlzpj2n196K2qT9qpGpbew2DS/chPbCn8Je+GnDz65iP2Va3vRAZNvgSXsu9ZpD3jUUGUMcN1qOWraOtmE8bXBPOUodKuNC6KDelTY354xR9NTDUzEK/U77GaPYzDUyrTikVSsjNG9gEvc89/R5xljy2kOME3jnNuv1kaT4ipUbVzYOkZU7pXOu89K436AxTx1QKx8lBAfSyNjdRu/7XFvHUG32G7T8SYastPZ93g05hPIcxozS9JXAL+qbXwx58GlrZ3+d8h4sO1H4wrm10TUytd1IWfypnDp5s+7ntHL5PGP0WqcJfK4N6rUER9vcrJGpbXNL9uj8Zcqe/5OxbiDyg3mJWt4UldP0xzRu9HM2ak+7jjHmid1n1b+q457OCWItE+JxxsBjK9TIlHdq1TIZ6MTei9YyoYxNq5HJcXKNumc9X/4m/ybV8x35Z9bItPgnba7M4F9SjUzyT+jarDUyLR0mbfam0J937Vv79/3cayQ83egamdRhVo1MT706rnCy1r4FF63DxtFP2pxMGRNJcX3pu9eAqZ9v+bBWXP8aPN8jrs9YgOgO+v2aR1xjpC6tGzjpuSdt9Vho/1vo/B2Xu8wcSsbDhU/SpoF12/ufWE/XxWwj0E9qXwudz7jk5a3bitgGCzll+1aqN7MRNTIp26UNY3pWjZayuYtWTV/a+SG2bFKNzHrne5o8pIzw9sm072P5ZMILrc/2oZ+0eXDGPLBySe5txDCtOmQyD/U6SJtH16B91XKe8534XIP70uYHMmzcqxNomTSetZzzWdJPn6FEnSBtt+E75wjbcmxfm9GPOOxXfZhvdzXgyHfGmXz20zViy44cV/jynQ6rNtein7R5QsZ70eNVnkH5cQs8N2lMSZubMuDdIgHepPGsp+Z8lvSTMSXP5DiRttvwe54xldWP7+tq1Yfr2cTpWgVnJOqlZaHzGZe5GnFMnIg/8TujcHfMJzJzhPXYTRvflG3S5vkZMlz3bY+7xw5c+M6zxw4Y8LXcYx112nJVy3DmohMf0i9tXpIxR84k0DJmPOtncz5L+ukzF6w5tA3fk+Yb4/3XZPTj94OqT3s8H1DtCId+tz5fbqHzd1zquiDDtb04rvAlL/UYp0yVNr9Y8B1b8TjqBvaxYl+/kjP2peGNGc/61YJxNBlTjDkKrtTv8jvHJNtyTGX14/dR1YexiDMpcGj7tq+Fzmdc5urIcOKv54SlY/od6xpX/OEcSLNRpM3bcspwjrvrIMPl9zrgH0BbxpgOJvCoahnOuArxoWyXNu8uaKMJLaeNZ/1hzmdJP71fZWe0XoZui9bXBtBt6ZtdndGPOGj9bO1BoQwXGaP3ulUtw5P2MhGm0DSs2lCmSpsPZbwXPV7lGdQZ1A1JY0ra/GXO9R8N77TxrI8VXEuSMUU/SnClfpff84yprH58X9o/yfLtGIMlLQudz7jM1ZHhowb+xE/nXjrGC819cXrspo1vyjZp84UMGa77tsfdQchw+Z17kFnjhTKuHnV5RLu9ahnOPe/E5wDuS5svZ8yRgwm0jBvP+pecz5J+1jko+rzfbfjOmj1sSztoX0Y/fp9Ufbgv45ABhzbTJOiqWobreKH2A8hLXZuI8UJp858F37G1DqTjc9r/pCweOJkO7+oEeOPGs2o5nyX9rHqxgiv1u97TrdtyTGX143d9Tgvt3IMpcEai3rG50PmMy1xGLEXPiaRYio+facdSRhV/OAf0+OY4XMtdTRkjO4y+7XH35c73pPXBkBxp5s4y15SyvkJeTltzd7jztyXrT2TMJS2fO8tUa8/k2gH9kUM+9K2uDx5OoI812KTNZMY4yLM+uJG10tdkOtYHncZOg7wV+qlT2hfX6jYqd1pwScudHlY4UjY0UsYE1zqF9ipy6Q/gWRq31X1Qne8jwKtiXq7utdwd9V4D6u8avu8BTk773Fdx2lMAJ/o3e31wavB9C26jUe/7rghWnGccecFuj8/dik7Svhv8LTLWubbgWR9B5hHXtK8/2YXtND5W6z3uAUzKm73gkbT54zt0296rg9/OqKtLhc+cC+Q95wefSxtD4HPOOsmR2Ju3ei/pHoO30ub7M+wXPW5HFJ/avBNe90O2OOrKKepK4Z3QwfUMafOIDN7tT+DdXvDO2kc14sQ7znniGSk8I+Ain151g3cATh6c+mEz0VfJgxPj0F62ZdGaw6zb6+V37oh6465ZOPXBv2nQ5s+DE312mRu7cU/GJuNZMjYGcW9MPZvrz9ZeWOoZ+gwLUSV8iEnbULQ+n7YNt3MEbNXx0lWb7Aj4wXjpUcA/AfjVjYHmUnsMHIt6r7QxcAI4HXfB6cK4FDiC26jiwbbK4E2v+vknFL3y9zZ3+LOtjYU/c26D6Z/aYPobGwx/doPhT28s/Kl4g8ffBs//meVLfP63Lu3xN3N2g/k/fWnPv0t+/G20/r2sf6JLmf+X59+l/f5nZi77P5fl7wbSv9Hyd4PH34bbnxutfy9x/Tczv8HwVy7t+MuGy7+N5v8lHn+45PXv3CUu/y7L/42Ff4nL/422vzbc/r3Ex/9sqw1vbQ26fuGzvb57EvAqXHNe3qHoFRiR4oFcgscOfD8BvhDPocrwvLA2f1LhdFK9lzaf6j58WmLO+DHwQPLByRfJIxdc2rnd93yGP45pPBKYe/C+7gC++eS1TMV+Y/fCs0+4PPtC3sORqPfKMy/aOTjtPJshdDqi3kGUR8j4bQ6+QFw9yk+c4MGNzUzImXDEc7wAnhPAc9zA0+twWBb5y4PnKQOnqEJ8dkXri6dz8xOTmI/Uu7gcc+HPhY2MxwGzBlyOgT/S5lVInD5Rv/B9J9p2bq3ek+/j4OkRB556JbxVtNmvoW9E4MM2fCesrN+ttofR56jRrn2NG23qCc89pvrwOxMAuclLfr9V/cKnlcjsKD+neNBCBBi8LPnpWSyXspLJoXKPGwvGFZ58X7ofk+N9+NmccSy6uPquOG8FRqR4IBeLFxzxwanhSe/uzrMPKXq0PtwG+EcUL46oNp4behzth9XFPBb55AaSCdArba6rX/hM2hihD1QQXnKDucwz6njaBgvV0BZHirbdii6/wgQXxq9TkffVd6aLgQkd1uFh96hf+Mxb8G1tg3Dnk+/MKqhl8XYA97ZFvWODhWykzXK9+6z7dL47biaIPTdutp/Hw69roIMFJ6TNA+sXPpPez178zffDohtiQ/Rhg2HDcyMux42WR3vAA2nz8Hrvb5p3uxN4R3kkPONmQ3FWj+LeCYPH1H8D1fFhdROn2PpHwI8b6l3YgltUMdw02o/6097IQzsL11Y4/lYPuCVfBQYv2kKHE/hRtd162OB/kE/UakxNNRut2aWZuXhuOj67PDe1Mrc4Pb04Pz11tnWWcqPIc89NxVPTM+dW4un55tn51vz5x7Uay4vnf4gXl841prlxtBC+ihf6RgQ+bMN3wsr63WrLTdx7jXYs9sANsbpIhLYlg/mwOLc8O7UyE5+Nz/93bvrsXNyabs2fbc2da8at8PcWzzRa8dL83MrZ2cbs4vzSdHNq8dxMM15uTDfj2fmGp++91+AxYWX9brXleztktON7o22R9d5Go16ZU6Ws9y4iUcS3oy/ruZFTH07JIgmMsRUprlAH7k6+Y3OHwklgJPGTvrLnxnkveh3jMat++JVRV6cJDfrAC+H3IPDQNjFlhfC77oN37Bg3W03unAD9tWh9/LaGNq/o/Jhk/04oPum5wpgx/WKvdRXHNQbzAE+hg4c1Spub6+m8m0zg3Th4JzybBO+c6JtyjCmYB5Lrw1cZU3hdPZ13ZxJ4dwq8E56xiPw+xU/RtbQBKH+3RfbhY+1/jsVVV/UAZZDAiBTdcrFYoJdf3panVtKB+FJ6nmu+Ub5m6V2/tbC4J8Fdy0CuhUmb3+38mDQW9Tqy0NvptjoWNc88C/kUtSEYb3BazJ8qOp7JJ6dx0CiaeHMMOHmutxcpQEGd6lSAoll0bf04cPKKfzOGI7iN4l4UVSsvjita5e9tvrDjjYRN30d4TL5Tz2ThuAv3aMtcg2dUOD5aOxROAiNSeMp1DXDyKpjOA2UFt9HIoVh8HJsHyLD4/WXYpWE39Q0WMJX3G3qwNQ+DZPFq0VfiI+g5VGXcqA1PdJHAaNtLn6t3v3++3sXjUo+ZM4YXRdXqnyLxwwphxxsJm/qHa0V6jS0PjozLyphwXGdsFY2LsqibZ1xU4Ahuo1GvX1MRrNVxk1U89TLsUrBT9Q8Pv9ZFXPPguAv3ZDw6zpee9Wjmxg6Nd2E7yfLVnICjgEn7lcUIpc1Vt++2He3gtzNabxczgZ2yKivXi/kWpPmo6ndU9aO8PF4Sh124dxR4yT0ezqDXPAei3jUx5qeQxpB1Mo7xIyVx2IV7h4GX3DuGezImGZdwWhOJmVdSi3rnJ2FyzpJe9pU2E51x2h6ztx3v0m+NF71GXZSXR3HP81155m/R1k6Sf162NuXfbSFf9Lhs47PbB5/GgEHrbsUPjq8Wxtf/N97tFyqz5Lkcg0V0FgvUhsoUnfOWlx65x3Hq5BvFnE9c17wOevOoD+yeuJjOQzwKHkmbT9+u2/Zu/vj12BTU73f3tymaRW2K14I334s5L7/Tpgjxf6i7qevk+wncS9N/1Puj6t4A7gkePLBQniVyhLkLTrq05RirX/XxhqLeK2+svuaDU8OT3vZ7a4+5PYqeIUWrfpfkhfxtyX/6+PpgCOofedZu41ly7wjuMVdanq/t2KI2cQ33ZO4w10jmDm0HJx1QeC8U9ZJT7k2zaPxjCDh5zQ3OV8Y/OIcrgrVqww8pWuXvbRcxbMtOJ99pr2fhuCtaL1scx2yPvTCEzx/dhPbCM2EvPMewF4TPnIdF/Owke0H7hqG2Om2PPQZeAyl4edoi1DOCg9YzeWM48kzRD9R1fD86D7Ho3KDeEfp5qFhIHjnj5TzUhIVG2pe23ar0QalHCU+/n4rg9cx/7hH6Bcz/fh6uKbhYh2veB/P/tX2KQXrH/yzfwzs+sIV9/2Ze25MxGW+f0ntPpdP6Q5NyX8cyrH2B7x3v/Y2X5atovczxvxu881yvtva8fWAT2jb7Idv+9wbLtpC1M8oxHnYo3xlXkXfPdQWv+hS0ibRto2G2LznQV37TaxLt6+Mp84C6OoqqlQPjPjwy90fo+g01tPm7FPpZsIy5mfqQa61HVn3gER/69CHXa+96pAu7HrnAbpC3pD8Cj1k3Kc3utNZLBgzc64q3tCcENnNuKUeOKVyPGc/S9ZBo+wgO1lqWZXOUPeiasSavtfKisSbm2njmuxcpFNePGgZF8925L7LuiFORfQF14OS1F6NoHTyufXrGCfW8Ho165UFFsFp55IwT7HgjYTNOWO98ku+UoUXkMOOEXmtKRfdoMHbh5L80GANjzIQxsIpgxXlia5dhl4Jt5vaJjmPxW4FFfZ+F465ofR1Ka53MMbbXk9s7CrgnJ7rf6xNdPLxyGIruE2F9FM99aQKH+0Qc6vG08sS1nGDHGwmb+odxRR2nKRr3S8rNqlr/FNkPwfiSp/4RONwP4eH/58kFuAy7FOxU/WPlaVD/FMnT4L4Hz3UdiR8w3nUd9IuTLF/NLdc5coKLVXf5RXPdtnfr4LczWp+LGmorM45KmvPs3xQ4J0riQHv9OPCSe4yJ7FH38sZfZYxS3uWR45aNFYKDtdbEGLBVr5RxCa8cB9qHEn+zYsC6tqbOP2e/R8Jme+xEl35rvOg9JUV5eRz3PN+V514Xa53eMZe7x9bmu34s5Isel57r+gMGrdof4fh6AsbX1ya6/UJlls5jL6qzGMsPlSl6/SsvPTqf2Tt/Ws+L9jt4JvSmV82J9vN0jRYtA6hLHwa9+WP++PXYFNTvz/W3KZpFbYqT4M0LMOd1fkmo/0PdTV2ncyiy9B/1/pC6NxBl50Qx54oxDCdd6p5bTh9OYESKB3JNgN5BH5z6kluu63zX1Cff5WDUywv525L/9PFljHCMF4mZMTdJ54PTJubYLWITD+KezB3mK+l61Y46YIo6IAKMSNETKTwd12cK14PgmoDX3OB8ZfyDeFQEKx4w6JO/t13EsC07nXzX9noajrtwT8aE45jtsRcoy35/E9oL35rttn2nYS8wtzjEz06yF7RvGGqr0/bYbeAl/LXw8rRFrPwrrWfyxnDkmaIfqOv4fmSs6ZwUPj9tblDvCP08xyC0TgFlpNyz1p/Iuyp9UOrRpPUur/nPcfEJzH/P3Fadfym47DHe0wcx/z/dpxikd/zP8j284wNb2Pdv5rU9GZPx9ik9Y3KO6w9Nyn0dy2BOrbT5zkQvj3lZvorWyxz/zD3pRx3VY6Bz4JQ77MK2zc9Ctg2d6vLLGrchsWqOW0v2ULaF5G5Ye9ZoazCuom0ET/+HdoV8F/iEWe98l9xy+Y37PKXNWOf9JOWWe+xfdYxxrI5VfRae8IzxDmlzOIX+vLnlWvf2M7e83nkuc8vHIxfYDfJW6K/je/vaFfXyX+7tNdrp3KQBA/dxxduknEadnz0QFcvrJtysvam0OegHyDOOGPREKfTIPeqp7Z3vUx1mrtYpgqz3qEWcFG//cOvCd8rd4ah7T76P4J5834978n0M9+T7AdyT7wfxXIezjmPCGAIuzKdn7nqFvtFqjId7TgeAC9cHfeyl5lLR3Pl+5zcJbqOKB9sqgzfdzONz+MGfbW0s/JlzG0z/1AbT39hg+LMbDH96Y+FPxRs8/jZ4/s8sX+Lzv3Vpj7+ZsxvM/+lLe/5d8uNvo/XvZf0TXcr8vzz/Lu33PzNz2f+5LH83kP6Nlr8bPP423P7caP17ieu/mfkNhr9yacdfNlz+bTT/L/H4wyWvf+cucfl3Wf5vLPxLXP5vtP214fbvJT7+Z1tteLIG/QHkFvjk5zaXdyh6BUakeBCB9vbFPK7d+I14DlWGZ74aRG0+bffh0xLzjlgnVXKKyBfJRRJc2p/3fIY/jmk8Eph78L7uAL4ddMFpKvYbu1OeuauNovUeORfaOTVj6KRzo6I8QsazIG6buO1RfuKYNCb9mJBTc8RzqACeTGQbMvDsxya4PHgOGjhFFeKTtMmr7kN/zwECAqPN/09BgfkUHG2sKgYW9mbSMwveSptlJEJ/FonQIgBlfO/Ed26UYYLWQiU0XNhg7HEob0WFqBv6RgQ+bMN3wsr63WrLpPJ9Rrv2NWS02Z7w3IOqD78zuVD6MHn7n3MmYVc8l6aKGmQcm2M+OPXIYcGNMpabHIoc4MIkVR9+Nmcc5X7hTeKUxU5FoRue9LbfPZ0fvYlBbwoZiHrlZS3qlQvCC6dNMrGjzltdKBwH/dx0UAe90mZwspdHvPgs6WcdmiDzZRy8q6PfQjW0xZGibVjR5bhZZHX8nvJ59uo7mwRdNdBxCryXNjsy3tkk/uY7k2fynbHtZApvB3BvW9Q7NiYBS9qcnuw+a2/nu6MuiP1subhn8V3ej9BBW07aHMx4P9rHknbc7CDzS9p6Fsd33Gg9xXEjvNObeThuTmTwbjiBd1YBI2lLP4Abf48YPKb+G4iq9UX0wVxtftwSc8OjsHsW7SyQO+ZDe0/QYiyBdie7Y7U4zVrQAzB40Rbq92EUY4AX5Gu1GlNTzUZrdmlmLp6bjs8uz02tzC1OTy/OT0+dbZ0N9bXOTcVT0zPnVuLp+ebZ+db8+ce1GsuL53+IF5fONaYpMwrhq3ihb0RRr72mC13m+d1qyzjWqNGOGw8pC/PYiUF8WJxbnp1amYnPxuf/Ozd9di5uTbfmz7bmzjXjVvh7i2carXhpfm7l7GxjdnF+abo5tXhuphkvN6ab8ex8VT69+d5GDR4TVtbvVlu+tz1GO6t4Z573Nhr5yXrHAPDUVtmMxwIcDOJnxZfZbztwd4rlNovGNWrAyclmanjS6+2HXxl1dZrQIGNC4Go/fWMX0Vz98abljwsdddArbR5c0B/Xc4UxY8sf9xirTj63WaBB6JgAD6TNozJ4dyqBd3XwTnh2Crxzom+q/exJR96dVrwTOuivS5tzGbw7ncA7xhSEZ9J2G9oxdiLJCVrHSx9pO6r6tPl1Bveq1gOUQQIjUnTLJXh4Lva2n2sVqBJfSs9zzTfK1zzruj6L7RfGol4L265o4FrYkzPGoj5QVicTsICQdRBGrfPvgOo3otpX6QNTxw0oOnYbtNzpmgufbX79KPxkp8OcCx/ayMMtncZN4cMtWQTEc83pYAGc6N97xhOKxDhYNMSryGHRwy1ZPNlrDco6qH40clnjXpV5WcXJnGDHGwmbBY94MHjZg0AYl3Pyu1pF101ZzM8z4UvHSpjQGEXVjpssP+wy7FKwzYO8rELBAiu0KD7jPl5xija8g+CPwKOfXqENtcor0XPMgfqtye73N8BWcpqTza1YECuKqtVtRZLRK4S9oQf+Ubcx2VpgVXHonlOMq1U0zkmfyEt+MN+XyfrMm6sI1uq42a5o3a7eyWXYpWCn6jZ5v3zn1G1ZODLHO0nXVBkTpv9CXfNB6BcnWT7F9SudM8EC8dLmd890236kg58VA6HeoqzKWivbCfj0zfIUTRU4x0viwHU+5nrIvSoOqdBrxXl9FJ3XUUXReharlnvMD5I5wJjHMGBVORc4PyV2JvAJk/Yo6WVfafN/YbP9+2SXfmu8lNWv1gEDHu/K0eaMaWsn2fZetrbA4LuyxqWj7W/GT7XtwPH1HYyvZ5/u9guVWfLcIsXh6Y8x9hcqU8oWruY49Tq4gfOJh1KMnu7CdoqDmocPaBlQQ5vnQm9e5Y9fTy4eD7vZDdheeXADCib5wILr0ubu4M1YBz/aAVUcCqPzdqiDD+Jemv6j3h9W9wai9fmizGGWZ4kc4b4PJ13aciy63yq6L5H5AU75Jg1Petvjoj0eRxU9Q4pW/S7JC/nbkv+MX+v9pUV9FutgsCE8X9uxRW3iGu7J3NmDe3pPmaf/UjTWQL3ktH+tWTS2z/1rXnOD85WxfY+DVAai7D1wFyNsy0639g3mwZF7BGVMOI7ZHnuB+0PvugnthVOwF+5u2AuM/4T42Un2gvYNyxzkpHPJiddACl6etgj1jOCg9UzeGI48U/RD0iGSIQdscm5Q7wj9LEQScpAX14K3457QkmS7VemDUo8SnmcM8riiuc3jc5j/XmtcfCd6/u823tM3Tnfb/iDmv2cM0jv+Z/ke3vGBLez7N/PanozJePuUnjE5x7WxJuW+jmVw36S0ecHpXrp5Wb6K1ssc/1z788zF0vZEm86f3oS2zTsg2162wbItJC8k65BKxlV0Xq5nvSfaRNq20TCjqHtIpfym1yTa1y+lzAPq6iiqVg7UfXhk7h/Re/NraPP6FPrzHlKp9Ug/D6lce9c4pNLzkFThG+lfhd/55KGLaXantV4yYOA+qHhLe0JgV2FPWLn/goO1lmXZHHq/wUC0Pvf+SAo99Cn0IbyrRRivufCd8o+55HoN3KqfJW3eAxn9lQzbImQ9kfLYsg8po0PyGyiPrVpfjIfLmOO6m1eMir6fPPs46JD7Mt5ERstvbCttPpQio3aiHd/ZuLpnzV35mzytd74z1j0R9dKz0Pk7LneZ+9WE/gngKW3+OsNm0/vVhC/HQZ/Qxf1qTnVqVumbUPQNKfg1tPlUTl3E9Tati6z99ht5YLKnLhK+Cf118Lp97UKbcdyTOVEHb8vm2AzinpXDJb9Txg2q51u6Tu6N4p6ucWjFWSjXPf0Sy6/WvgH1xXCUrJukzdcz5oG1JvzT0GH9OqzeI35pxR13Rt0xTR3mNLdW5Va98ywtlwdBj7SpdWLZSXK5rvgg741yWfRfHfQ5rYOacllwGQee0uaKFPoolxkn0nLZ2j96qcll4THlMteFvPYEDQCOwNSxWcbLtIyq4XMt3yJlTCTpmLJ7uiwdw3WCsjomr7/GdXjNI8bb+7GepddGqvQnPPNa6CdoGTQMPKXNbTNkrF5vknaUsVYdZK/8Aeo/TR/XhKXNdE4Zu1lt37X8XshYr71Llm0h8CljpU0/4tPWHLPsQHl/WsYyNilt7pIhY7VtxnWf3QZM/fy0dZ+ktcS7bkBun3c8m3am0MoY97CBR83AQ+vYmoGHlQ/iZIu0itqxDy1oxwpf0uxY0sxxUlf3rOfL31ZOgvzm7QeIPZzGP2lzNoN/44o+4Qv5V+98Z1st6zT9TjqslUb/kEH/Y7eWn9DK4yd4xkn1eBD41GHShvkjnn6CHmtF/ATabdLmaTn9BI/aD/QT6ni+R+4s41N6zzl1KW3C3cbaMNcz9JqzvANp61h/eHUsHFfP1vvp+O5fhHy+N5xZT9dWWPPW+Xx5bQT6Se1rofMZl7z6HePSdRYpk16dU7Zv1nVi0Vf9ku31qHtR1/PcEWnDGAPrngnu2s4uatNTXlnrtiG2LM9mYu5WHnlIGeFZ54oyTOjQ+7soe4YjW85SHr05Yx7ovnovm1P+V+EzXDaqFhFzDvYDbpFcBeo/L37Sn9d76q18uvdk2P46NqDrilGXWev51J/D6l7etZa0PdjSz+L7EYVXKA6MyVDHevrXVmzQykUXOMMlcaBcHAJeco82Qx3Prdp2G1TPrgNnjRNz98YVrQvV4NTUOJB3Gqbwk3Tovu3r9NXRGp8/BZtzj8HrmiOvd6tna71o7VP1tu1qil96DcV7/O1Rz64DH9LcvuRd631XfNdDeNf/mPKuSev/hU9Su7pLt9de9n7b6/qd0l7/Sk57nXtRtL1u1VTvl72+li+xQfa6Hou01xlfsHIXy+ZiWva6h17yzNWmL0B4Tnut4qQcoBrkxmTne5G6Af3WkTovQ+vIGtrs6NCzVef4Wg4o5ng9coFt5mVQbrYv5mX0oX5sw4p7WXtKmSPFNoxHSpvDKWOC8kporyLeWsc9S17J75RXdfX8uvF8ucd8RpmHlMHWfrFJzPuXX92FG+rvlK0pxfcZ6o+UrfHaB7kfczwxv2MK9pfnHjiOAWs+8T3tuqbbdgb4ee3/s3J/2rDnNyFvPor5c0foTWv/fEitkzL7F+jnM2YQkv9FHW+dZ1/1mmP72ZNOz6asjQAjUjyQaxL0Otk0DU96pZ7PkKKnrmjluxyPenkhf2ftR5JnHVG08FlpNjfj4daaZFnZPo57efLjHesQTDE+GAFGpOiJFJ6e+yIpp/LgVAdOXnOD85W1auvAoyJYcR6b62KEbeUB9uR6dD6L2qQyJhzHbI+9IDDasu6HNqG98EbYCz9s+Nkee1F07NWywTdDvZ2kPZheNni/95cLHXXwTtr8WM4YxWbdOyI6YaP3l9MHljZWHLIG3nrs6fPYb+FoizSK7Bd8OeSW5l2ZfeBp+z2EXiu+4nl2RFJ+dWgtpL0GjTrX3hpr1lk2ZetrM3bnuQdBzyWdQ0+8h1WbvQYtb8iQlbpve8zK+QI7FSzpk6avBH5R3/xiyINPWzt7e8p7sOxE4QvnltBVB311H/qalLuavjrwlDbvzamTe2pdbqJ1AyuXz0t/WDrNqluo1xK81w30HLPWDbTs2aNwpOz5YMa6AfVk+9oRrZc3ReU0/TGNG/2cfsYdKdt0jDFP7J62PvN/5DvjmkIr45qDBh7jBh7aThw38Kh3vtNXncAzqpaxp0A3x9sE8JQ2X8iQsUm1TChjha5TBs0cJ6fUPev58jf5N6ie710LpqPKU/knbb6Swb9JRV896m3P87fZlrJu3KC/HrnQ30qjv27Q/40K1r61f9/PvUbCU+owrzijNR4EPnWYtOE6iNP+b1Ovcl+RwExa+6a+lTaD1/TSxCsprl+2Tr8V1z+F53vE9RkLYN6bwNQ84hojdelBAyc991j/n3Op/W+h83dc7jJzKDV/aUvsx7rt7DXr6bqYbQT6Se1rofMZl7z6XecszTaYTJnHW8E/qXee2y/Zrm0ZgU/ZLm0Y07NqtJTNXaS8kjlBOz/ElrX2weaVh5QR3j6Z9n2K5HKxRrq0uUPGPLBySSTPhjU0uRdpAbw45MOL1fU+xqPb/w50/haYbfjUP1XrkwPq2QKLeEmbkVt1+fPd/vyZYq3UCDB41fA9iWdV43SoAE7Mhz3gg9Pq+vjBAjgdAE77HXE6UACn/cDJ6xy7HYCTB6d9wGnMkU/7FA9Go959qxXBWvUds/bDOsGONxI2dbjwuIr9wrQ1ndZPWjsUTgIjUnjKxfMZPM8Y0PsyR6Ne/VsRrHggys6xvgy7FOzU88WteiOh5wv1Y73ROitF5ypXaEOt8kr0HO3LJ8P3fgpsJa+zN9rvR+RRBBiRej+R8S686gowt4I1/LkeXBGslrXOrNfRnWDHGwmbuk14XEVOC20fpzz/1g6Fk8CIFJ5yMcbmJT+4Xie4jUa9PmtFsOI864CXYZeCnarbttpZ9fRfqGteCf3iJMtX63ywrm8NuLB+jrR55i26bX8esWeJtTD2PKbuEZZ+LmPDAp++2X7Vb7/qR3l5rCQOjKPtB15yj/HvkFpqVi2vvD6KwBkriYOlE5jHdgD3rNoNTnHEHhkisTMrjkh7lPSyr7R5K2y2P7ymS781Xsrq1/245/muHG3O2NpnqnWzl63NvZN/CPmix6Wj7W/W79C2A8fXH2F8XX9tt1+ozCq7H5mxv1CZIs/gOM1Dj9Ydjror5nxirciPQm86xUFX1/SOASbn7X7wSNrcG3rzb/zxi7n+sR94fgKwnWKfzQEFk3zg+pS02QvefBpzXn6nTRES26Pupq7TZ6hl6T+POtyOurTlWDNm1ccbiXqvNB+vBnq9clU96ZW9tnsMevi3tdYpv1t5NFb8uuweB569zLUzeb62Y4vaxNY5ITyPWeZOH2JRU0VjDdRLIz44NYvG9kfw6TU3OF8Z2+ccrgjWqg0/omiVv7ddxLAtO518p72eheMu3OM+Macx22MvCIy2Pt55bffeZrEXvnxtt+3eznfaC9Y58EX87CR7wdoTF2Kr0/bYY+A1kIKXpy1CPSM4aD2TN4aj64Yn7eeTsUb+FZkb1DvWXjr5nbwpshbMetW6trO23ar0QalH+1CruGf+MwYZY/7383x5wcU6X/69mP8tzH/PGKR3/M/yPbzjA1vY92/mtT0Zk/H2KT1jco5rY2atC30eFXXB/a7t/Y2X5atovWydC+idi6XtiTadD9qEts1PQrY9bINlW0heSNZZZoyr6H0YjvZtgzaRtm0IU+cny29WfvIPpswD6uooqlYOeJ7ZKH6pjFVdO7GGNjem0M99CseAr96noPVIP/cprL1r7FPw3O8lfBP6rT1U0ibN7rTWSwYM3K3zB6zanvIsypEDCtcDxrPkHuEWqXlBmyOkHhH3ZdOnsM4Hf1nzwnfKP+aS6zVwHTunLH0hZPQfZNgWoWc9jSm6ks56Cq1XovdOWPKYfhzX3TxrDWj5L++BMOWdi4yW346BZmnzqhQZxX1ofGc1dc+au/I3edrHmh5mPXyh36rp8UsZNltd0Sd8OQb6hK466Ks70qdreowo+DW0+dWcuojrbVoXaVupn7rIqunRz73HrI3cvqyaHtQfrINRNobDPW1WDldZ3cB9gCLbqF91nIVy3dMvsfxq7RtQXwxHybpJ2rw7Yx5Ya8IPgg67GM80lnFGHeY0t1blFut+831Z57p/KEMu673U8t4ol61z3Z3WQU25TL0rn9Lmr3LK5c16rvtmkcvC46T6gf08113HZhkv0zLKOtf971PGRJKOKbuny9IxXCcoq2Py+mtch9c8Yry9H+tZem2kSn/CM6+F9oWWQayXIW3+I0PGaltF+EIZq2NFnvkD1H+aPuabSJv/3uK271rdG8hYzzNRtW0h8CljpU0/4tPWHLPsQHl/WsYyNrmWR9TJqUuSsdo247rPXgOmfn7auk/SWuLOPq3DJMk2j3i2dX4WY9xW7e3tBh55avJY+SBOtkirqB07mTLeLDtW+JJmx5JmjpMhdc96vlVzSMeyvf0AHUu3+CdtbpPBv5qiT/hC/un4UxT1yjrLT3DSYa00+kcM+qdT6N+EfkJro2uy6vFg+QnShvkjnn6C1qtF/ATabdLmLhk6zLP2A/0E+iEeubOMT+k959SllF+fMPbecT1DrznLO+AcpG1RZe7SQNS75kceWXsjHoD8/6fcYj1dW2HNW+fz5bUR6Ce1r4XOZ1zy6neMizFK4ZO0Wc4p2zfrOvFanLpPsl3bMjp/eBfaMMZwBLwR3LWdXdSmp7yy1m1DbFnWD2XuVh55SBnhuH+qR4YJHXp/F2XPcGTLWcqjH8mYB7qv3svmlP81tVVqEe1SsAVukdxH6j8vftKf13vqrXy6F2bY/jo2oOuKUZdZ6/lVnD2Vtgdb+ll89zgfnDq2X2dbST9LlllnA5WNJ7PurtyjzcD1napttyH17JriC3Fi7p5nrgPXlsi7QYO/26LemAD7SpuvwOb8Vdic+wxeO53Z3nOGzoCiIW2fqncOoI5PMI9K4HuOv33q2Xr8We9a77viu/4LvOs3p7xr0vpW9PkQ7A2vvez9zuvU77SGNn+Q015Pqz+tdUE/7fU1X2SD8jr1WGQshvEFaz9U2b0d1jqnh17y9IGsM+sc91rFSTlAH4IM+GdDbmTVDei3jqwDd0tH1tDmr7f4HLfirTUf3jbIW6F/DX7nk2fj9qF+bMOKe1l7SpPO3+PeE2nzuZzx1irzMmq4Z8kr+b3I+XqUt1a8lTLY2i/2z5j3j7plF26ov1O2phTfZ6g/UrbGax/kfszxxLWq78D+8twDxzFgzSe+p7+9ZbdtdMsufl77/6zcnzbswVtuPt7cDN5s73xP2j9f1ZmyefcveJ9j42jHr9bzmXB6NmVtBBiR4oFcE6DX6zxoT3qlns92RU9NffJd5jnb2bLp9R6TojY34+GH0EeeX1a280ycPPnx3NvoEYtmLFBgRIqeSOHpmfNMOZUHpxpw8pobnK/MgyceFcGK89hcFyNsKw+QfNf5rWk40ibl+YJOY7bHXqAsm92E9sLTYC/cHvaC514UHXu1bPDNUG+nz3sw437vHeH+APmUNvfsjIWtundkbZ8qYhROtqG5d0TH7Lh3xIpDDoO3ZX1Wnkln7bcIsbeZ90C972SLNIrsF3wU5JbOUSqzDzxtv4fQa8VXPM+OSMqvDq2FNGbQqHPtrZw66yybsvW1Gbvz3IOgY3c6h554D6s2YwYtT8mQlbovzxegfmTMKE1fCfyivrnHOr2nz1107ey5Ke/BshOFL5xbXH8V+jx18lACfdTJ0uZFOXUy5/JmWjewar546Q9Lp1l5b3otwXvdQM8xa91Ayx69j5Ky55UpY4I+FGvOaHlTVE7TH9O40c/pZ9yxij0+mleUd4xr6pwg7v8gHoMGHllxLNb6oK9axzOqlrHjnWdpGVQHntLmdzJk7LiiT/hCGSt0jRs0c5yMq3vW8+Vv8m9IPd+Rf6syXOKXafyTNn+Qwb8JRZ/whfwTutiWsm7QoN9Jh7XS6K8Z9L83pw7bJOerr9trJDylDvOKM1rjQeBTh5H/gpPT/m9Tr7KmucBMWvum3SZtPpihw6y4ftk6/VZcfxzP94jrMxag67dRl9ImHDR06UEDJz33WP/f86wenUOp+Utb4jOINQ7caj1dF7ONQD+pfS10PuOSl7duK2Ib/PMW909EX/VLtmtbRuv6XVEv/+XeEfQR3MvmLlJeyZygnR9iyzLmyb1SeeQhZYS3T6Z9nyK5XKyRvtbmVr39eSXlkjDP5iDaL1RDZ9x+BvfU6jqcNfz+081uux23Wo+Xx7rzoaj3GlB/1/CdOZ0HHHE6WAAnynnPWtoHCuDUj3gq9wXnwYn12r3WQLfKnjqnc+6beWS/E+x4I2EnrUuUteVpS3vV1doRrdcXaWO2D/lADa63cw+ix575POv4l2GXgm2e2633ffOdU98X2SPahzp0iWf0MDejQl83tuqIrObM3Kr7/Q6wlZzmZJPx+wgwIvV+IuNdeNnQ9Ne5tuBwBkMzTxzACXa8kbCT6jOH1Iy04mCOeU2tojmcSfvOqh6zAodr7YwBVQQrzhNbugy7FOxU3cY4ho7V5cGRNVOSdE2FYzNxL84j/OMhU4yH5Mkf3TbVbbuImK7U+mDMNeQ8QNaPog+bp46OwDlWEgfumWPdD70XlTa8FaOX5xfNkZV+1pq8PoctFAfL32E8nbW7rDpaXnOBtqfESAU+YVLHkV72lTbPgM32/Ft16bfGS1nfkef9eb4rR5kQW2ceOa4r9djarOXzfMgXPS4d96j31AiWZ2u/mOPrxRhfu27d7Rcqs8raeKyZFSpTrHObitQy4zj13Kep50X7HbwaetOpZtmqX8LaYZy3Vt3Fjza6bW/2x6/njFnWp/wlwPY6L3QgSj6Hkbki0uaV4M3rMOf12ahl8p71GkxSHYk0/Ue9H2JXWuvJnn6YZx4Zc4ojwIgUD+Sqg16vfRme9Moe1t2KHp0/zHeZZ4+FjGPW1Q3Z88R4nFXn0co74dgtYhNzbVrXdKAu78M6y1TRODr1klfN1qIxuz7k1jc4Xxmz4xyuCNaqDZ+1t+BihG3Z6eQ77fUie9L7UEO/x14g3L/ahPbCE2EvfNywF7i2EeJnJ9kL1v7U0DN8dG69zq1LwsvTFqGeERy0nskbw5Fnin7wOguKeseK/1k5lEX2PljnSiXZblX6oNb6k2N8vGf+c6/lN/xjkOYedsHFikHeDfP/W32KQXrH/yzfwzs+sIV9/2Ze25MxGW+f0jMm57nGTLmvYxk872rNL7l1L495Wb6K1svWHljvnDVtT7TpPH5rd9iFbZsrINvGMW43QrZpWyOvbZOWk8+4ilVrw7N2rI6zCHzC5P5Q2h5cV5A2cco8oK6OomrlQD/rmgrPrLqm0yn0M/9/s541slnqmjIvXtqk2Z3WesmAgXtN8Zb2RJXnLBGu1n/WWpZlcwhsyppDCodDKfQw1uQkywvHmpj77JlLXyT3mbn0h3xwahTNpT8EnLzmX9E9BzXg5JTf3yxaB5Jrn55xQj2vR6NeeVARrFYeOeMEO95I2IwTCo/Jd8rQInKYcULP3L4i+z8Yu/DMWxc4gtvl/LotC9vM7dO11PnOqe+L5PZZ58hzLcYzt1x0EfP9nnrr7venwTf11D+h+8u8zoKjfGG+/2X946N/hMdV6B8ZE977poron37vm6L+ubx3aUvCzq1/dL5F0TyNPuybSlzXeTX0i5MsX80tPwCYjH0yR07aPPu23bY3G7FPrhvqmHKeNYqdgEWaD6h+B1Q/60zLUBy4TsK8Mx2T5bqEVadSnl+0xqf0s+S4znkPxcGq8cmY/yHc0zHmkaj3vNEq5wLnp8THOAcFps4t12sV7Pc22Gz/69Zd+q3xEprzr/MUvd+VZ84ube0+1CyKrfomfFfWuNyo3HKrtsifYHzd8zbdfqEyS+8DJD4atrV2zPoboTJFnsFxmoceucdx6uQbxZxPjK98DHrTqRaJmVuuZQB16X2gN//WH78em4L6/VP+NkWzqE0xBt58FnNe728J9X+ou6nr5Lt1bqGl/6j3R9S9AdwTPEYMPOjryKeTLm05rkO2GNuJACNSPJCLdVO91o896dW55QJHn9fAd5knR87y8fU+pqI+C3OH9J5V2sRF927KPZ7xaJ0hqPfEO+qAqaJ53NRLTvH3Zpn4u9fcuBx/94dt2enkO+31IjHwpHi3l73AePfu23RhbxZ74Su36bYd63ynvcC8/hA/O8le0L5hqK1O22O3gddACl6etgj1jM6/Ym55nhiOPFP0Q9K+Cxlr5F+RuUG9I/Qzt1x+J2+KxMutGplJtluVPij1KOH1OwY5hfnvlSfMd6Ln/17jPb0P838G898zBukd/7N8D+/4wBb2/Zt5bU/GZLx9Ss+YXL9zy/XeJ+qCB9yml1+8LF9F62WOf+ogz/Vqa5/9QzahbfN8yLZHbLBs07ZGXttGjx2r3jvtD+pVJ/u2QZtI2zaEuXZGYdRre3BdQdo8LmUeeOaWO+VfmudRjoBu+ZQ2P5xCf97ccq1H+plbvlnOoxQeZ9VmZzu9XrLKW4W7VctA3hVrDej87IGoWF434Wbtj02yOfSZRKQnSqFH7tGn0Gc9ttu8pHnhO+WftXdOy2jG8qXNT0FGvyPDtgjd26z36VGuUkaH5DdYZ+9a8ph+HH2Rfu7/0fvdOS70/p9joFna/FyKjOK5VHxng+qeNXc3+Iww8xwQob8OPKXNazNstnFFn/DlGOizzrAad6SvrujbruDX0ObXc+oirrdtpn1OMnb6pYvqUfeqAb61z4nnkFg58WVzbFirRu/XrUI3WDnE1K86zkK57umXWH619g2oL4ajZN0kbd6bMQ+sNeGHQIdpX7hMjDPND/CIX1pxR9a54Ht2mltNeV4UrZfL1vm4H86QyzXFB3lvlMvW+bj93H8quFj7T/86p1xmnGgznVm/WeSy8Jhymf6D1xkp9IkFJx2bZbxMyyiOTWnzuZQx4b3vKmmdoKyOyeuvcR3equU01cf1LL02UqU/4ZnXQj9ByyDGK6TNtzNkrF5vEr5QxvaxJmST+k/Tx3yTNf7eNpm+rWD7rp3RBhnrdV6XZVsIfMpYadOP+LQ1xyw7kOfxsQ1jk2v56iljgnkKlIFa3lj2aZ51n6S1xN19WodJkm0e8WzambomKO1R4jFs4JGVK0Y7tg+1KFtF7dgzKePNsmOFL2l2LGnmOKmpe9bz5W8rJ4F2sqcfoGPpFv+kTZzBPx1/Er6Qfzr+JDTKZfkJXnvQ0+jfbtA/m1OHbRI/oZXHT/CMk+rxYPkJjEPKp6efoPVqET+Bc1Pa3DVDh3nuj6WfYMW6qsydZXxKdMcoYGoeMY+fa8Ncz9BrzvIO+CzaFlXmLg1EvWt+5JG1N+L7kf//tNuup2srrHnrfL68NgL9pPa10PmMS179jnEx30b4JG1Wcsr2zbpOvGZ39Um2a1tG5w/vinp1uNwT/jLGoO3sojY95ZW1bhtiy7I2MHO38shDygjH/VM9Mkzo0Pu7KHuGI1vOUh49M2Me6L56L5tT/tcU5WoEGJGiXy7ux/Xy0ymLqZPT9gILnmm5j0n7WavkJ/15bfta+XQ/lWH7J9Vqpe2vz12lrqH+DMm3pi6zzveSfhbf9ZlfVeR8U8fq+kKhsVz6n9SbeWSZtceqbDx5GHjJPdoMXN+p2narqWfTj9M4MdZdRz8vX7qmeFc3+Lst6o0JsK+0+VfYnL8Om3O/weshR16PqWcLLMtOJa9rjrzWNhzzVAW+5/jTfokef9a71v4b3/VH8K5/N+Vdk9a3oc+HYW94nQXW77xO/U4Zi3lHTnude1G0va51QT/t9bUYwwbldVqxBGnDvRf6LIEq9nZY65weesnTB9ostf4+DBnwL4bcoF+v6zNvhI4cB+6Wjqyhzce3+By34q1OOS8N8pb0C6/b1y60Ya18r3p2lh8v45IwWT+fbRiHkzZfyBlvteKhobl/zC205JX8TnmVlYtLeWvFW63zjpgn8i+Y94txF26ov1M2Js33GeqPhMQ1qVf6IPdjjif6Yv8F+8tzD5zeg6rnE9/TJ+Nu221xFz/PWkd6nbsNeyjefLz5RfBmtPM9Kbc0pNZJkf0LOveTfj5jBjV1j/6j4GGtKdNXal+OdvxqPZ9TTs+mrI0AI1I8kOsU6K374NTwpFfq+QwregYVrXyX9aiXF/K3Jf9p0+s9JkVtbsbD9yk8q5DtddxLy4/vwxl3U0XrSjE/yyvnmXIqD0592P/T4HwdxSfncEWw4jw218UImzFn2nO69ldRm7Te+XQcsz32AmM/85vQXngG7IU7wl6wzordDPV2Qs40sHKIaesIDpatY+1f8bLB+713ROiw9o7cqzMWsmIUjMnqGIV+p/2MUazFzBCjcLINU88uow8sbaw45BB4WzZvoIZ71n6LEHubeQ/U+062SCOvPcQ4gXdus14fSYqveObGJeVOhdTaIr9Io87rsMaalY9Stt4XY3cbve8zKVfygEHL0zJkpbXv89XIIZTnMGaUpq8EflHf3GOd3tPnLrp29ryU92DZibpmK2MK9CM8dXItgT695t6+XpxTJ6flaW/kuoFV88VLf1g6TeBzbVCvJXivG+g5Zq0baNmj9+pT9rw6ZUzQh2LNGS1vispp+mMaN/o5/Yw7euzxobxjXFPnBHH/B/GoG3jIPcGjbuBh+arjeEbVMnai8ywtg8aBp7R5c4aMnVD0CV8oY+ud7xMGzRwnE+qe9Xz5m/yrqec78m9Vhkv8Mo1/0uYdGfw7pegTvpB/QpduK1fdoN+rNnsa/YMG/e/LqcPS1r61f9/PvUbCU+qweuQCu2GNB4FPHXYKvwtOnrX8tF4VXCxbVesw2m3S5i8ydJgV1y9bp9+K60/g+R5xfcYCrHPGNY+4xkhdetDASc891kX1PKtH51Bq/tKW+HvEGgcb6+m6mG0E+knta6HzGZe8vHVbEdvgX7a4f7KWt9In2a5tGa3rd6ENY3rCX2sdMjR3sY57Mido58vvRWxZxjxZ2yyPPKSM8PbJtO9TJJdrDP3W4qIdvJPmgZVL8l9GjiPjcPvQ1opZ1dBmZ6Pb9k6N9c89BFz2qHsDUS/eNfxNOSiw9uCefD+I5+u8kCrkOM+F1GcReOcb67UfXVeA9pGMFfmN+9KkzfGUsUJfhu+sru5tQr/S1B1Cv6U7TqfwIc2v5D6seuc7/Z4JR/rGFX3DCn4NbW6ZIRPyrKfJnNssutFzPU34JvRbOaXSpo57MieoG+X3IvOFuou6V+SYVRPloOIHn5+2nkZfRO8lZNyNa153gm7U63gLnb/jclfPfiChQ+YbYbKudZJukjbflTEPrLMCjqecRUrbh+83T16C4JBWN4A5B3y/ITkH1FfUYXo/dr/3I1Evyae0uX+GXNZrKtb+WGtNpe5I33gCfXXgKW0eklMus46KlsvaProU5TJr35D/gtMeR5z0moquXdJuk1THl2sq0uZcyphI0jFaLhGmfj51AM9Yknu6FkMVOob6RGQPfTKuOQlMzaP25zdudeF7Uo5YaM19XXuast7Dn3CMkbboJ6TV35I2z8qQsToupWtVUNf0Ya9Ik/pP08c6Z9LmuVvc9rVqZHrW8tK2hVUjU+fGeufM7FM4WTkzOkaibUXOzZdlyFhtm1UR82ctX41bexz/lSHbaGeGyPgisk3bnlXYsbQzhQ+s1bndwGPIwGMr5Aal2bG/UdCOtWo8ajuWNHOcDKp71vOtM0y2q+d7+wH1zrPS+CdtfjeDf3VFnz4Xxoo/RVGvrLP8BCcd1kqjf9ig/+1by09o5cmH9tyzXY+6lxUDtdYGvP0ErVeL+Am026TNH+f0E5gjW9ZP2Id7Ip+5hiy/U3Zr3b3PeL7e20Y/gfEpKwfMOrv6l6BLdf4r40oy94SHrJHJGFP730Ln77jcZdbI1PnMfPd/i/WUbzfW00XZv0/dy8N/K6ebdkMVNkJaHe00G4F+Uvta6HzGJa9+x7h0/QTq4H/KKdvTamRuZA3/zXKWovCP++0YY5A5wRiDtrMpG6IE3rKGBWuAyJyw8tyL2LLc/8u6n3nkIWWEt0+ma2QK/wlTeDEc2XKW8iiauvCRNA9039V9DLfq0uq5L1njNKD+ruE7fWKvvAHLH6WvafnFgmeaj0r958VPK36jcz7oA+1MGReWXSXtqMtkHllrIdSf2p+y4l9WXpaOf+Xlu3U2UAgOrKvLnAWdGxYay7XqXeSVZTrfpop4MutRyj3aDHU8t2rbTdc/rANnjRP3lI0rWheqwampcSDvNEzhJ+nQfdvXTVNdPt9yqkvXHoPXNUde71bPFlhW3g953Y89U9qvTlpfrJone9Sz68CHNLcvedc6P4/v+gF41zMp75q0zqPP/ae6dDv5z33fm67fKWMxd8qwU8Re5/qOtte1Ltjo9QQnX8iMxeixyFgM7V19zrnXOqeHXvL0gegLEB5tjwplTmytz3Let78/yZAb9OvlHTL2328dOQHcLR1ZQ5uHbfE5vllyyTnfpA3r8HuuY+p5u0fBt9YMrTiNtHlMyphIyssIyW/m+mMd9yx5Jb9TXtXV8+vG8+Ue4xdW/Q5dO4dzvf3981NduKH+Tkj+HPcO9OzVU/3y+iMheR30m/sg92OOJ+bE/BjsLyefvcl3om0k+uzS5pHNbtufBH5O8ZAe3hDPF2xC3kyANy+G3tTzgLmfnBueuZ9W7WrqE86PPGvKIkv6UM9itUbmpNOzKWsjwIgUD+SaBL1ONk3Dk16pkTmk6KkrWvkux6NeXsjflvy3cgsPKVr4rDSbm7mFBxWeVcj2cdzLk7vomNs3xfhgBBiRoidSeHrmPBet21kHTl5zg/OVuWp14FERrDiPzXUxwmbMmfacwKI/moUjbVIZE45jtsdeEBhtWffOTWgv/Cfs7fcafjbtBX3GZB5ZZ+Un69irZYNbdbcpnyhvQ/a209YRHCxbx9q/4mWD93vviNBRB++kzYdzxigYk718jkcv/cLr9sW9I1Ycsgbelo1DMs9J15kMtbetvAdHW6SR1x5inMB7D51eH0mKrwicvSVxYBwiay96VblTHGtCozXWrL2iITiQRsbuPHMl9VzS+/2J97Bqs9eg5dsZslL3bY/ZRyCHkLCkT5q+EvhFfXOPdXrv+lv1zrPyrJ2NdmIfefO49XmhjCnUQV/dh77UXL468FyT5yn0USdzLm+mdQMrT9uzlpfWaQLfyuXjePasx6LtZUvHrNkuUbL9Lm2OpYwJ+lDMo+bzNUz9fCsmQn9M40Y/p59xR489PpR3jGsKHxjXHDTwGDfw0HbiuIFHvfOdvuoEnlG1jD0FujneJoCntGllyNikGo+UsULXKYNmjpNT6p71fPmb/BtUz/eulTLZeVYa/6TNnTL4N6noq0e97XeCLralrBs36K9HLvS30uivG/TfLacOS1v71v59P/caCW+pw5zOkmpY40HgU4dJmz7sLTP1KmukCEzar0l2m7S5X4YOs+L6ITrE2ltMX2Yczy8b1z+Fezqfhn4s/X7NI64xWntaiJOee9JW21jtfwudv+Nyl5lDqflLP+ks1iaf11xP18VsI9BPal8Lnc+45OWt24rYBk/a4v5JvfNcyvZxH96a9Y8FPmW7Pj+Q8rAO3obE5pPWIWVO0M4PsWUZ82RtszzykDLCcb2kR4YJfO3TpOkz1gKWNj+VMQ+sXBLJs2n/fqRzn3uRXtLs/n68c/8Ifn8ZeHXEh1dT3A8bAQavGr4LHm2cDjnidKQATqxZfNAHp9X14UMFcOI57gcccTpYACfmzTqdPby6tn+gAE7UpV57D3dE689sGo166+hWA6s5PRBln03iA/vC2v5GwW7Le71vnnznXuSQc8Qcc39bOxROAiNSeMrFNQ2vWpZcM+SeXa5zVAQrzrMWeRl2KdhT+kZ7jIuO4zkRAov6PqTehmeuvLUeqtf3KvRJY2ttcjW3Bb7nH8JWcpqTTe7/jwAjUu8nMt6Fk75tcC1ScBuNemt4VAPrgm7Lqg3iA/vCXN0o2NRtrI0jsKjbitSuoe3jtDbe2qFwEhiRwlOuPcDJS37QX+I+fvpWFcGKB6Ls/TOXYZeCnarbWNtEYFG3Fdnb1Idckpj+C3XNP0C/OMny1XfGek61aP15tzW0+cR0F78vIvYqsQSRS9RblFVZdWt43i59szxnOwuc4yVxYO0cxmLl3hE8f5+6l0ce8zynoucAC5z9JXGwdIJVT8vKhfPcI8X5KeMxLbdsm6KXfaXNf8Nm29Hq0m+Nl7L6leeWe74rR5szpq2dZNt72drMbZN3ZY1LR9u/J7dPnq1tB46vPa0uzv+z1e0XKrN07eqi/hhjf6EyRZ7BcZqHHq07PHUX5xPPiTrR6sJ2ioOurmkdB0zOW+5Rlja/Bb054Y9fzPg+10lOA7ZT7LM5oGCSD7Q1pM2N4M21mPPyO22KkNgedTd1nXznGcVp+o96f7e6Z63/5MkFd9SlLcc9Ji2uFUaAESkeyMW95yM+ODU86ZW9pnsVPaOKVr7LkaiXF/K3Jf8Zv9Y1BIv6LDwb8YjCkzYxx24Rm3gE92TujOGerjHpqAOmisYaks58rTpmVyS2z1qMXnOD85Wxfc7himDFeXIGLkbYlp1OvtNeL5JTMYJPpzHbYy8wF+whm9BeuAfshUcY9gLjPyF+dpK9oH3DUFudtsdeA6+BFLw8bRHqGcFB65m8MRydi0ddx/eja7oWnRvUO0I/98vJ7+RNkbVg5lDp/FFtu1Xpg1pnXHnHII8rmtvz60cw/73WuPhO9PzfZ7yn45j/z8b894xBesf/LN/DOz6whX3/Zl7bkzEZb5/SMybnuDbWpNzXsQzuU5U2N3f4mbT3RPsqWi9z/HPtzzMXS9sTbTpfuwltm39ALPFXN1i2heSF5D3Ly6oN0q/8XG3bEKbY2pKfq+vX04//vZR5MBL5rLE67slZHaus2Ue7kec9SZu3p9DPPP3jwFfn6Ws90s88/bV33ad9xHpfiMDnWRnW3uJDRju9XjIQZdehoT0hsKuwJwhX6z9rLcuyOQQ2ZY0+u+NYCj30KU50vtOm/DBkvVNee4t6JgKMSNERKVpHol7eV637BM5x8E3unQTcIwpP+dt6d4cD+x0N7CfvtE3PTkXPjk7b9sW9Dp9pdX/f0bm/E32uAhzp86b7dduJbLLO3dG6nGs+0uaL0OUHptc/l7o8ZN0560ws6vKQPBjqbatuDNdNdM0Wz1gmYwTy7OOAK/f1Xhv57Tholjb/lqLLuPeP70yf12fJ+Dx7/0airlzw0Om6Ngjpl09p858Ztn3SGaDHQZ/Q1Yd6qj1nXQh9owp+DW0Gp5Ppo83CddnNfo6Zp81CfVWL1p/fY50rQL3MWkQh84U2Eet3Wbl+8jtlXJG93FY9NdphOh5Hue7pv1rxF+1DUl8MR8m6SdoczZgHVu7Aa+GP6phJmVh4mr/oEee24tNWnUjHubUqt6gH+L54jqq0uWXK++KzpJ+8N8pl+rZCn9N6uSmXmS8jeEqbRk65zHiilsvaProU5TJt/Br4IJ9ee0Ise1VwIUwdX7Hi/NLmTiljIknHSN9jBkz9fOoAuWfpGK4nldUxef165mtoHnFdph/rnnoNrUp/wjP/iX6ClkHcby9tvj9Dxup1ybX1KNCnY4qeeSbUf5o+q27Kw7e47bt27jhkrKc807aFwKeM1XVVve1APccsO1Den5axjGFLmxsyZKy2zbg+uM+AqZ+ftj6YtOb8kA3IAfVe96Cdqevu0h4lHiMGHlm6jHYs9b6TLdIqasf+WEE7VviSZseSZo6TYXXPer5V412veXj7AXrNxeKftPmpDP5pf1r4Qv7p+FMU9co6y09w0mGtNPpHDfp/dmv5Ca08foJnnFSPB8tPkDbMM9poP0HXzbb8BGnzizn9BOZYS99jBkz9fOowuWflWNMP8cixZnzKqptu+QmnjRwCrmfo3ATpy3g6bYsqc9wGot61YfLI2kPzZuR9fXR6PV1bITdC533mtRHoJ7Wvhc5nXPLqd4xLxpdlG7w3p2zfrPkEa+d09km2a1tG55mzbjdjDDInGGPQdnZRm57yylrfD7FlGZdhjl8eeUgZ4bjPrkeGCR16HyBljz4Hgmtx0ubjGfNA99V7Hj1raBTZ17JRNauYm0I95nmOr86fPKB4wHjY5zNseO3j6zpy1EnWujz1YIidk3Wei/SzcoKOKbyqsLWoKz39ZCvGZ+09EDi7S+JA+TYKvOQedb/TuekNnTdGvTJi4MRcTc+1I+YbkndDBn+3RevzPSLV7x4z3f4DM126xgxejzjyep96ttZv1r5kbxttRPFa4PN8Ls/xN6aercef9a71Pju+61vgXe9IedekdRf6XDvThe/kB/fd7tbvlHb3WIfeLLube4+03a11QT/t7rW8hw2yu/VYpN3NOIGVq1o299ayuz30kmMMsKe2I+E57a2Lk3J5roUMuN6QG1l1IvqtI3V+hdaRNbRpbPE5vqbbMcc9zyahH8M1fc43acOYndP+TPO8Qb2Hysqv0PGmnvyKlDFBecX6/SFrb9Z5m0nySn6nvMpas6G8ZV5iWpyAMdLrMe/fPtOFG+rvlK0hRj811B8pW9O3D3I/5nhinsaDYH957nnkGEiaK9KmNdtt+zDg57Xf08rhacN+5CbkzTcxf5agN616CSG1bcrsQ6Cfz5hBSB4XdXwfzi5erd9Ud3o2ZW0EGJHigVx10Otk0zQ86ZX6TaOKnmFFa895cVEvL6zcdMumL5uDSH1lrS2Wle3M08+T5+5o10wxPhgBRqToiRSejvZfk3IqD059yKducL4yx5BzuCJYcR6b62KEbeXzke/0R4vYpNzn5TRme+wFwv3ZTWgvfBT2wisMP9tjT4mOvVo2+Gaor5S0l9LLBveUo9Shem+eVU/gV3PGKDbrHpA13xsxio2oJ0AfWNpYccgR8LZsnfR+7ZvwjLEU2ff3dsgtzbsy+7nT9m0IvVZ8xfOskKQ86dDaV/sNGnXOvDXWrLOLytZTZ+zOM+dRzyWdC0+8h1Wb/QYtH8mQlbovz5OgfmTMKE1fCfyivvnFkM+etnb2mZT3YNmJ0o5zizFboc9TJ29PoI86Wdp8IadO5lzeTOsGVk6eZ4xe6zSrTqVeS/DOTdJzzKo9qmXPmMKRsuerGesGIj+YX6jlTVE5TX9M40Y/p59xR8o2HWPME7unrc/8H30Gs5UTxJokxGPIwGOT1SRZlbG6JgnzOORT2lzRib0XrUlCGatrkpBmjpNBdc96vvxN/m1Xz3fk36oMr3eelcY/aTOWwb+6om8tLwT0CV1sS1ln1Xxx0mGtNPqHDfqPptCfd+1b+/eOOmzdniHhKXWYV5zRGg8CnzpM2lCXeepVHW+x1r51vSdpY52tfk3KmEiK6+saUEV9WCuuP4jne8T1GQtgPElgah5xjZG69JCBk557PO/B82wmnUOpz+qjLXE7rNs+fHY9XRezjUA/qX0tdD7jkpe3bitiG1yfU7ZvVv/E2g/qKdu1LaN1/S60YUzPqrVSNneR8krmBO38EFvW2s+aVx5SRnj7ZNr3sXwy4YXWZ9wDK20WM+aBlUvyIMh54bFVy1Xvy+73GXw1hQ/rWEibGzJs3L0JtIwaz3pczmdJPxlb3GOv15+24TvfPdvWcH8wox+/a1uCNodVF5Q+nk9dxsbqOq6u73pc4Ule6n3eR9BP2jy94DuWZxxEmzqeyz4cU9LmmTn9Jg1v1HjWcwr6YDKm5Jm0M6Tttmj9WotuyzGV1Y/f96k+lKt7U+Awh6d9LXQ+4zJXI46JE+cE8asp3Pstw48r/nAOpNUxkDYvzZDh1v7+T5268H1nAnzWQ27DkjrK3HcqbV4BW/mPZtc/9xBw0bl3eW1lnS/bT1uZ41bGMseKU43annxy+S7vgTDrne8yVuS3E6BZ2rw+ZazsRDu+swl1bwD35PnyN3k63vkuv7V5dUrRs9D5Oy53rdr/k51n6TF7CnhKm9/OkKuTir565/sJ0Cd0TYK+SUf6Tin6agp+DW1+N6d/k1YTQdfN76d/I2OH/k09coHdIG+F/nF8b1+70GYC92ROjIO3wjfOlyJnEtRxz/Jv5HfKuLp6ft14vtyjf6Pz9rl2whycP4J/43XmQPt5uiaCzDcrtjIcJesmafNnGfNA913d5wvdKOcOUB7qGsBWnLFoPeEq1mK4F0LuWbaXZe/UAatquTUOvPi+6qBH2nwyQy6PKz7Ie6NcFv03DvomHOk7lUDfBPCUNn+fUy7zvAstl7V9dCnKZeEx5TLXkDzXFHQsTHAhTHl/WkbxbAFp888ZawqWjtFyiTD186kD5F4d96x9YPJ7qI6hPrHidjp2QVnMOO4nOpOI/gR14VF1Lw8f6E8cxT357uFPOMZnW/K8KFovg6w9vcNzFz6TZGxN0Sd8oYxlrELo84ztDyXQx9i+tNmRQt9WsH3XahhCxh714a2ZDyzwKWOlDcezpx2o55hlB8r70zKWY1PaHE4ZE7ui9baZVWPYsk/lb8pAuXcUz9K4tfn5+4Zso50ZIuOLyDaPczFoZ+q6crRHiceggUee3BmZ+9T7dTyjahlbxI5tZMhYbccKX9LsWNLMcTKu7lnPl7/JvyH1fG8/QOzhNP5Jm9tn8E/Hn4Qv5J+OPwlsuSw/wUmHtdLorxn03yWnDtskfkIrj5/gGSfV48HyE8h/wcnTT9B6tYifQLtN2nxfhg7T64lV+AnHcE/ksxXrCj1/k2uPunYg/QTmBGsetT+fC10qv3M9g/Edzg1pq+2Z9r+Fzt9xuWt1LJxQz9bns/PdL851cf2JufV0UfaHxBqt2se0G6qwEWT8FLUR6Ce1r4XOZ1zy6neMS8ZXHXySNk/IKds5ZrRs13ZnP/2TNT+yT7Jd2zICn3vtyH+5dwh9BHerlnkRm57ySuaElQdexJZl7tRR3MsjDykjRqJen7bq93Ai6qVD+E+YzPey5Czl0Qsy5oHu26b1mRNdWj1rSxxT+Ayov2v4zj2mXn66lWdKv5XzL2s9nf0OA3cvflJnaNuX+TPS5hUZtr/WP8IP2v76vC7qH+pPnQ+bN77HWhrSLw/f9dltoTjswj3mRFg1i2rq3kC0PsZXM2ikDSr98uRR6nymUByYm8M1LWv9ahzPrdp2q6tnjwNnjRPra3quOY0rvgl8DVP4STp03/b1Hdicvwub85jB65ojr4+qZwssy04lr+uRH69ril96nd57/Gm/RI8/611r/43v+lN41+9Oedek9Q/R55OwN5xiwH231/U7pb3+Rzntde5R3UxrtmsxBtjrTnEu0163YgnShudJif5j3DwkX5D2TQ33PPWS5/4Law1V1/apUObESX7GJyEDvm3IDfr18g4Z+++3jkzKl7PyMj63xed4vfNczvFxH96aeRl1fG9fzMvgWSqe8Vbtx+ucYfoOw6oN43DS5l9yxlvrnc8qcv/Gcc+SV/I75ZWWt+PG86nv5J51Lq3M16No/23M+8fNd+GG+jtlY9I9+61Vv7z+iM4dL6pX+iD3Y44nxrpH57uwneZTk+9E20jUrdLmi/PdtlcBP6d4SA9viOfuTcib3wRvxjrf+5lbGrImX1f36D8KHnUDD5H/8pvnmnz72aednk1ZGwFGpHgg12nQ62TTNDzplTrHQ4oe7WvWAV+vueo9IEk2vTzrkKKFz0qzuRn3t9Yky8r2CdzLE4MfiXrtwqpj0YwFCoxI0RMpPB3tv2bR2svjwMlrbnC+MveSc7giWHEem+tihM2YM+25ccBtX0VtUhkTjmO2x16gLXzXTWgv/CTshbvDXtC+RZn9lGl50wORbYN777mkrSM4WLZOWs6ARxzy/2fvT+Ak2a76TjyqX3V3FSpV9b4vUf2eEIuBzKrsft1IoJKQQUJCG0II0PL6vX6NFtCChLY/YGwhVjNGls0itmEsBDP+CBvJtgAzYAwSxggwIP4GA4OsYSw8FsIDZjAgzCiq4lR+81cn1owTWdXV8fl0Z1bkjXvPOXHv2e4550bxUcpQmxcak0e5+tx8LlT5KOiTVR+FvtNZxw2kScjYbkyY+uwYE+b5IedB22njBlLci8zpC9RFhk1iEr4MfCsytln3R4r8K5GxcUWxUxpzXRfHiw6OGtfhzTUvHqUNDMSRvrtZ530WxUpedHB5YwWv9PI+H48YQuuHPqMyeWXjT5P32WYvwtun7zsOvmzv7M0l78HTE/XMZ/oUaEdEyuS0AD/KZGvzHTVl8m7N57S5Q5kcJT88mWbjc28wxe8GU+S+ga4xb99Aec8FgZG8520lc4I21Ha+WrKT3zTl07THFDbaOfslp521TAjHFQeOKj9Wz7VMNnnsfcCb882rZfKTFTz2PsEvzb+Txxpe9zk4c57cJ/e8/u1v0i+V/qNrwZj/sox+1ua9FfR7lOBndCH9DC+2TfH9ioN/kAwbleG/6uD/SzVlWNnet9r3feYaGU0pw6L8jN58sPEpw6xNCnpEnYPtyVWDxdNVVYaleM7a/IcKGeb59dvIEO/sNNoy96H/CL9+VU0CpRH3GClLvfqbuvasrepY2b+N/O/BdJcbQ6n0pS7xYfgalz99J177pe5Ndm3kn4Mpr77rnJXpBn+5x+0Tk1d98XbVZVTWr6BNintejZZpYxfJr7waLW10Wfo8m9ZoIY+ItsnU9mkSy3Uez1mb458++TyvoliSRYfPMyfvHNrSJ8fxrc3ZTx+3fbLDZ3lewBm5N4d71q/9TT5oY7G2u55lTz5OmTUtH/dqw/C8wHmM1fVc0b0f+gPtfpp/t7liv7GttfmEkrlCW4bv7Irc24V2pSs7DH9PdgxK6FBmV7KetWf33BeIn8b8HpTx59HmWgVPqCMbbc3tFtmYJiFjl9Zio8zwamTamqBsbLNeKLtS3DM+Rl3VfiePS6X/1Onf7tEWMd7GPS+1r8jXs/egPvyN/O/BdJcrG7X2OeWF1o+mbLI2T6tYB/pshut78peZrXHLISU/PCr36ug+lFfMabTvlGFam3kumb7OM2WY+qX7zkfSfWOutxdU8OVVoYPu5RXtqQTp1S5fNliuAE5rc6smXz4LeJUvq360H/kyYxoo3w2mM4EwzQtMXvyEvT/lUdxTsTavLJkTRTJG+RLH1P4pA+xeint63kMXMobyROvDUcZwn0hplP32feDFnt/mrNyrQwfaE2dxz75H2BOBPtIR7QTlQawXaG2+qYLHql/K6EIey5oHhl9QnNo65Z/ix/gAa/P39rjua3CTx56Noa1bj1Jrn3ixsZH1QOh/MJi8uCH1kXjn5Fib76ngsaqbdeHzP4u+FLZs3n6Vw9uoZ7bh8U14m+qeXeix1DO9eJdFB455Bw6VsfMOHLOODSrTY/9ZQz3W6FKmxxJnzpNVuef1b397ewvUk1P00TUPN324jH7W5qcq6Kf2tNGF9FP/U5Ls5HWKf5AMG5Xhf9DB/z17y04Y1YmHXo2hbWk8NGWY7g1E2wk615rYCdTbrM2v1bQTuG89rZ1wDvf0XLOlZOeZaZ7sPuf0r7lttBPonzLZ4dWupk74JMhSPTeDfiVbexozrX6t7N9G/vdgumsiBnhOaESflbX5feynHHrMTrzI+8/JvTr092pmU2/oQkew+dNUR6CdlF0b+edgyqtvH5fWT6AM/pOavL2shv8sc128uNrIPTDVZWx8ozHz7crOemIsKtdLk1jUedzTs8nb6rLM/z2Le3X4IXlEtE2meQwaJ0Xecyjx+Sz50SMeM4kfryXn2c08htUxrkGye418NcEYieBvl8ERaaeTHpTJms/F/RG7r3ogn7sM2KPoSZmhui/h367bWTIvPPlj9KDurzmglD+Un0fkXl3/ntZ+qUt3Pa+5LQz0MzAmQv2V5NfkSW1iz+rsQ3l5dG1h8M5mKdq/om3Rte6WSt+U9QoTa65H7jmtgm6k3RWHvgeSSf89n7U2f+sxY5yuQec859D6YCCtz0rfGjdJmEjrNImj9UGhtY2fYvzI+ad2ic4/712r/cZ3/UK868eXvGvi+kQ88wLoG0GxAL3r6/pOqa8/uUJPMX19onbXLtqz3fYxQF8P8nO5+rrnS7A2rAlv8o9+82n1dcbvRMqlyBwIbw81MM5+UGRnvAA84GscvkG73t4hff99y8iieDkvLuP2Hl/jad7vrGtkevFyzA2JtE913aqPjTr6IWlDGW9tXlUyJ8iv0vyzrT+uyB/q8Sv7nfxK+e2q07/nH9Gzhrjuz+K3r8G6/6PHjMdta+9M65NuepaAR0eNHW9qN/fA9wecT7TF/i70ryCbfZ3vRHUk2uzW5sWPHbf9NsAX5A+ZoA3hfMsupM2ngDbfAbnZV2xpmz35VO7RfjQ4UgcO4yX2W+Se/N0amd3hazUyFwWfVcE1xfi65+rFtHs6vcYwNNW56fc/JnB2wduv4F4dH3xgvtha03qURwFTkP63Tj5VB6ZVwBS1NrheDba7NTK7HdvLZ/dqkzbVSW1OBM7ZCX2Bvp+f34X6wgL0hV907Owu8inL4qbnEl8Hj865pK5jMHi6TlnMQIQfMoqPUobavNCYPMrV367po5ioMSA+Cn2ns44bSJOQsd2YMPXZMSbM80N2GTeQ4l5kTl9k7nqTmIQ/At+KjG3W/ZEi/0pkbFxR7JTGXNfF0WAkjlX1i4viUdrAQBzpu5t13mdRrOR5B5dDuQxtkvd5MGe6lI/0GZXJKxt/mrzPrvbp+46DL9s7O1HyHjw9Uesg0adAOyJSJqcF+FEmW5tzFfNst+dz2tyhTI6sfZIm44v6DvcGrQ3nc2T+k+rLnozZ1l2SYv3d2jy6ZE7QhmL9XXt2og6dwFXmE6E9prDRztkvOe2sZUI4rjhwVPmxdkONTHunXi2Tx1Xw2PsEvzT/Th5reN3n4Mx5cp/c8/q3v0m/VPqPrgVj/ssy+lmbJ1fQ71GCn9GF9DO82DbF9ysO/kEybFSG/6qD/zNqyrCyvW+17/vMNTLaUobdF0Nbt0amjU8ZZm1S0KPP2tNaU438XGVYiueszfMrZJjn128jQ1gTzvPrX0H/0/r178O9ujUJlEbcY6QsveTApGtv27+XTK6l7N9G/vdgusuNoVT60k56OXyNb37sTrz2S92b7NrIPwdTXn3XOSvTDb5mj9snJq9mXSOTvN3apLjn1Whp45sv2of0arS00WXp82xao4U8Ijp3Vn1UatOUybOzeM7afHvFOvBiSf6uk3uZYnzSh7ypKB+oaz5PvxfhIf7W5vsqdNzzBbhcdvr6gZp92XMaw+SddXQg2Xn2kLbl3D5W8Ry/X5Rn6GPwzjmin0nPJtrI/x5MdQ0393GPAUbSnGPq2RwqI/lefqThO9Z9CK6peXnGW1PvrBjvaMF4l52+/nnNvuw59bd7OV8H8DvnJNtyTlU9x+9as9eLaffGWUgm5+ZG/jmY5hoOBgq/rgnyfe4VRcbj6jtbFPpwDej85jy0Nu+p4OH6bDbvzqVb37395uyZ43JvDvdsfPubOqfBxHrrJ9BHh7S8mvV3EjhlfR/K/z4BOK3Nr1SspZOCX65abfe5DLxOAr9TMfht5oeeLsDvFOC0Nr/Rgb+C8sPwC9Jp11SnNZpSpw2aO0PS1vDfHj//XEEbzufIfQCVfQYLxzwOONmGss/afLCmz91wb7v2qeufQF8KWzaPn5wLuoX8ORujy7mVjb2cTF5z8vd8MkkLgyno/W7GB640gInyKMpHRv+FwbaYTM6XjsYa1PGL3IljZ3RdFhqT7vZbU79gD3G2A65h6g8fhb0bNDc3fTorGJO87ghoZG3e+sXjtslnjGm7IHTmOiTtuTbZL/UbygbDP4iHDaJpq3bIikPb7ZjhnJ517ZAFodNyMqZ1H3wt6/tYIO2OC+001pMy8kgF7Y4X0I5nbqiPORC/tUC9a93T2Q0PT2c/XUG7Ip2d9q+nsy/E4DckvyScicCZABb7PBkI00IDmEinKP2b+n4dmE4ApiB7axOmEw1gOgWYTgfCdKoBTKcBU5QfeimZtJ2qYOq7DlQdmFhPjPa93bP1Qt3Y5utx3LP5cg/u0Ta3e7Tj7R73dZNkMpY0uzbyz8GUF/E9mOysHUPfW8f++IHnj9caCNn4lzF+d/Ni/UHGtCYYgxfnBet+XQqBaWuu2jis2UkaHOhsvKubMvey4Gt/Hwgf//7RbMe/dnvG+K/NGP/hjMe/f8bjX53t+GuDGc+/Ga//aw/t8/U/2t/z79qtGdP/6v5ef/t+/s1a/t6VP8l+pv/d9be/3/+1a3ftn7v8d4b4z5r/znj+zVz/nLX83efy79qNGY//8P72v8yc/82a/vvc/7Dv5e/1fc7/7vL/2Y6/z/n/rPWvmeu/+3z+3z/KxrM96H+dxxPF1QJaf2hJ8LUxEqGBXWn+yXpnl0EXwnmwMzi39uZTgcn+tvcSV49ha29ez/TbPCtuYSddLE/BYMlyB57yhngYy2hkY2YxIva+Hgu6xcS6rAWeAbPV9+WQvrfiHpgrZmMkQl+70vwzi4PMYm8O4iGtH5jUYTJ9FdolTEXIGRxMkGNATlCi/JAJ0nXgvBdwXnHgvC8QznsbwHmfA1PSITw8uMP6Z3IdA9V/E0ImMlGWB1XMJzsTZefR5qUIjv8dBMdbW5uDRUWdzgfQNCrgjcx3in6HeiNJ/MRsjlX1u9eWhTkvOO2y64rTZrWg34vyDL8zAJDJy/b7/10ScB3IP9dZlDPBGLw8/hl5aBd5JQNG7R6TR64InHxf+tzRls8x+D/mPaxfi07K43q3MRKhQQLcDd+ohOxAfNczxSXjyWcFH5WjBzB+VfHkDN7lGHg3+ebxmL43NwFZkHUeeBwHvtsFyz9z67Mo8WNR6MSic/bJAw+Mdky22egGt0EiuHnJOlH6XKAOtvnOtGCe6kDzaPNxFe9MC8RpgSa+M7Z9VAlt55LJJEnOjUdhLGtz72eO+zqSfw9MTAhfU0ysnk92FiibR5uTFe9Hk8+1+A+LwVjbQPyGkQfIZP0dEdrpoWzzaHOhgnZHCmh3HLTzDlxLrX/cM7uVNKb8m+uODpsJvmYjsBDOJ2JtdF6YJR83LcH9Qjzuwzq4BxV339R3SVcbgxd1oXMF9Oha3/UOtm5lS42Ga2vrw9H9D167Prh+dXDroetrD1+/efXqzRtX126NbrWVxbfXBmtXr91+eHD1xvqtG6MbH+tuNHzo5sd+GNx88PbwKhNjG8ErtNAbSTJ5IIAeIFDnd68tC2kcc9rxEEwm/FYdntmaDjevP3T/2sPXBrcGH/vv9tVb1wejq6Mbt0bXb68PRu3f2+DacDR48Mb1h2/dP7z/5o0Hr66v3bx9bX3w0PDq+uD+G8NIm/2YQ2OOVfW715bv7azTju/NO5Qju7z3tpjsPNh8I2lFix1XpC7S1LajbhyZFGrjsFCl3aNvrkmBm1XAHmU7LglMNkYRPWkrBxUGCLWVA+3atUzfekQyWfQtu9RmNHrfAzhUJ/YKZMX4eLfWa9ABXuu2mZgkY/2XyaiGr7V5ToX+q4cy6BqjX5kHWEQdDh/pq8z600PUDY8roIG1eX4F7e4toB0LgxrN7gXtgvBbC/QpuIcQGB6eT+FWQ5+C0Y4+WqOZtT2AdvTLWOCBynh7xtoek2cyen087nUtB8iDbIxE8LbL4Ii0yzN+6gUrmC2l61zpRv5aJXcDE/HdQ40uCi7c8H9VxVxMBRfDlzzQOwg6qpBPUx2C/oY0EKYm8zkFTJEFGdIGMF0CTKuBMF1qABN10qgi+01jHCirIoNK7hUaLCaTMrWjsdY9WW1/H4gdezDLsYsK+dtYlDNVMDKOwuZENj8ejT46nB+jpnEkjwZMQTJ9c87aOAbbIu4lSbfz5tGC66Plndwde6qx1/UGD6aw98t3TnlfBeMK7n087qXAIbt0DXXpN+JBGDZGpsf8I+ylvQ0+8yD/9HrTYk48pPVCDEwTQY20nwPipdbrxAcEjT2Y5diez66Lw6e9PY4I+dMk6JWHYUUdLMxYK4ONcSpJ0u28qTpY+e7YU41dKn+8g73bHnrNPcioeAnuAbNo4Xuc/eiImICLGJMx5BdAI2vzgeeO2/5CDt8ynuEhcRfk3lwyuf87j7+N9ozPJc4X5bmL8hz55eUpYeCBV/RjaBwI93+a7FPyMBjyuzp83Ma5MCUM3KvjITV2j4fl2ZxM88/AItYTRevnk8n1yTG5Zokvn7U2H4TO9kefOcbfmy8aw9KUlhdxL/JdBcrKAXXtIv4XpWuT//0R+IvOS42T6jJGZi4pPjjzHN6TtflvmF+vfdz4ubY8S+Mkmsos79Awe64uT9GD0uriY/c4T4NsowHXE2OZ5h43Hjton3KiwIwevslcFGvzo5CbB+PhG3gFd7OxFzB2kE6x3lSn+ErQZimHj3oAdYo29o93yCBlcIp7ZfKPcl8PP5hLdsZDHnHg8A4yCZKlo0Bf/ajpwT701QfFPAwj8c3eUTbnzgo+K4Ir3+Wy0ML+9vg/bfyyeG/rq+yQHMZ88KBL61/12KY6MYvGp/n387hna6eH+M3GMViUS5FxTE38H4xjilobXK/0f3ANdzTWpg5fdbDQnTi2p6eT7tTXq2BcSXYe2BQ4Zyf0Beb1PnYX6gvPgL6w4egLRmeuwyZ2dpG+oLZhW12dusdZB665ErgidRHKGYNB5UxdH471meaflHV8PzbXSL8ma4NyR+OY+f5Jmyb+ch6Gkubfi3S3Lm1QytG+Dr27LDhn6+sFWP9ReSF8J7r+zznv6V6s/wex/iN9kNH+P8/2iPYP7GHbf72u7kmfTLRNGemTC9x/cA9G1DwOyoKvzelZ92BElcveAe3R+9WqT2R4vmkX6jZ/8IXjtt80Y97WZu+MfIw5tPadfhV792n+GajfDqkTqW7DMU3XtoOm7TfuK1ib7yxZBwtJzMG6C8nYdoyYq6t5X3rI5zw+rc33luDPQmeMg9TD11WObOK3EIOfHr6+/a4XxmNH5WaQtoa/jW80Zl2sMr3T2y+Zc2BfFNpSn+DBwNYX+cglgfWS05fd47gq/7y9LE/nsD6OOfgkJfjYvaKD/Wbpa2KsTWS8e5Ocasa7R831pvHujOeL9H8tNoCJPpeoXAzyoDowce8zKs+F/MBgW0wm+UFHY43q8JmgsQezHJt+Qo8Pk4c24cPML47aU2qao0HfRWTOs41DmUQfWEdjDer41u6OPdXYbmyfyTh7v3znlPdVMK7gHmuU6T5ZoG9vQL2F9Xh+73Hj7x94nA9H1/KnSa5cD37IibXMnOCAOT3ar2uZ8of+BBuL8qfJeqIvJ0iPGy0JTDZGInDa1cPe2ZB6nMG2mEzqdh2NNZhLquMK7o491dil8od1zGwsyp86MR+Mn8iuyPqW9OPZGJsxchvjsSPrzR3HmPQX0p9mbZ7/nHHbgxtjmDUWnzEy5FVVMTLLyc56d4RR4fHib89OCQPjdOiL0dgd7o1yflXtjXLvlfyuDh+3cY5OCQP3Z48ALrvHGh82J+mXYK2ELteC9Wdwc31yTK5Z4stnrc2lja3PbM5+8sYYf2++TBsHchz3It9VZJxJka5N/hela5P/2bvy5qX62Lvc159zcJ0XenB+DTbGML9rY/xcW55l/XIONpFZ9Du15SnWB+dpk1pkPcTODrieaKN9xsZ47CAf3Dr32UxuKg+gLP1UyM3Hx8M38GIQsrGfiLGDdIr1pjrFH3/BuO2TciCoB1CnaGP/eHFUlMHHcK9M/lHu3yP35nDP4LjHgcP4iP0WKEvDY8ub5LyvAt+oejl9xJYvCz4XBVe+yzp+Yc/Gt750n459zTt92T3uS2qOJHVizt0mOjFjn7R2NGV5kZ+u67016k82RiL4JAJnZN5RU//HRcAUWUvqotBgMZlcwx2NNZhLqmPR7sSxPT2ddKe+3iRWj3uKkbloGnuYyePXbYzH3i36wi9BX/iqHAjqC8yjaWNnF+kLahu21dWXpV+Fa64ErkhdhHLGvqucqevDsT5pR7LWscGucYdN1wbfr+Y+dbH/RLtP60Sq7talDUo5yvGC4som1r+Nka2vt26Mx47KxeI70fW/4ryn/xnr//tyIKJ9kNH+P8/2iPYP7GHbf72u7kmfTLRNGemTC9x/WCffV1/GMmhgbX4yH7gotlxtFZXLnP/zoF3kfrXqExmeP7MRPnZj3eZh8Lb3bIzpVZaX1cRXzXnr8R7ytnm5V8cOpY4yj3v2nX4V1REi7R/qFda3jc8xLQ7aYsvtt3uAk7V5/8bWZ1FsOXWwjW7wGAT6ODbn6pW8L607vQr8rc1vbRTjz9hy+jg1tlxlb5+x5dvvGrHlaRIy9pC0Nfy19scK2tyDe8ecdjwLweBNBfZUaEt9grlq0/qbUjynMsrTQ/S8C+98p7mkWc0l8pzD+fc/3tj63KxTlH9fSGLO9qWMYV7bDzxrDJ+tg0OA2b4v4J59P4l79v0E7tn3U7hn30/jnn0/g7E6OItqx8UxDgIW8nfqRx3aSztqks0BFvohD2P87tb3+oNN48QPA6bIGH8bh3HipMGBzsa7uik/Dgu+9veB8PHvH812/Gu3Z4z/2ozxH854/PtnPP7V2Y6/Npjx/Jvx+r/20D5f/6P9Pf+u3Zox/a/u7/W37+ffrOXvXfmT7Gf6311/+/v9X7t21/65y39niP+s+e+M59/M9c9Zy999Lv+u3Zjx+A/vb//LzPnfrOm/z/0P+17+Xt/n/O8u/5/t+Puc/89a/5q5/rvP5//9I8azfP3jtz7jYnbXH1oSfG2MRGig3xnzcRh0IZybdds7gXMyp9vg0HiSuDy4rb15i0VibPg8YpHsnsUn3QP6POUN8TCW0cjGPJqM39djQbczITCtBdYx3er7cEjfW3EPGpNWZ11kMalZnM0pPKT1b5M6TCa6UDIDC22MIuQYbOUFXAYlFA2bFr1kcNsFB84+EuPqwHnJgSnpEJ6ixK/LMfhPHNDGw9K+FwIsJqh9uCkYjmFMBvkx8cPaXENw9A/k8DGg2eY3g4tZ4DWg6NGQAVwd9jvBIKfod6g3kmQyKNO+c6yq3722LPy74rTLrgtOm3sK+tVkG35ncKE9M4/f/8njJ/vgFVlIfglwJRiDl8ebo4WhjWOwkce2PXT3UMvnFvAZ8x7WrwXKi7WmRYrJw6MKJ0cWQD6S43tK8LF3x3Vv41cloy0k43nQtTwLlJWbG4xp3pfJK8PjMvC1Nu8t4UPsy55jcaMkmQwaT/HbZTy30Q1ug0Rw00NtAhNPNufvlZi+N9/ZvcBrHnhcAe2tza9UvLN78TffmfXJd8a295bQdi6ZTKjk3LgXY1mbP3j8uK/fgJ4WVUwoMLFx8/0sgDbEkzqgtfkPFe9nAX/z/bCQn/EyyqKowqOBsn2NTgNN3KReZG3+YwXt5gtox0TBBfyeXbQfTuEek03sM6qAHA8zYAG5j2BtUC/rctwy3DnPjsfgPnGQw/EC3KMSh5sWp+670C+L7bey0UbDtbX14ej+B69dH1y/Orj10PW1h6/fvHr15o2ra7dGt6jHNOn39tpg7eq12w8Prt5Yv3VjdONj3Y2GD9382A+Dmw/eHl6NtP2or9l3jlX1u9d2Ac8cdtqx+AB5YR09sRUdbl5/6P61h68Nbg0+9t/tq7euD0ZXRzduja7fXh+M2r+3wbXhaPDgjesP37p/eP/NGw9eXV+7efva+uCh4dX1wf03uvIFuO/tsENjjlX1u9eW723Racf3xiS1JkWeu+b1gbbDWtMkPsq2yCQ+2gP2XuweCxeo7sP3q8+xqExkITTCZGMU0ZOF0KL8IZH4RvodMjv8EcnOw+i3ixyDdkkyuVFVZ78i6tDaQHt83bPHDQ/PHj//hK3Puva4rjH6lVPQLgi/yIKWbrEHw2MVNLA2Vypod6WAdpdBuzTJ+wLtgvBby/q+N5B29wntDA/a69bmEytod18B7ehTMJpZ2wNoR9+JBTWojLdnrO1heSZr9yjc61oONAlUeBRgD5L1w4yf0n4zm02LvKX5p9KN/LVK7rLgQp888BhgsjbXG/JAw7eMB5IG5m84Lc9pcZUubWDKuDnBY8HBZe6ztz4zej3uCeN2MYEUzQ+lpO8kyKe3Rj9FHZhoSwfN5WFTfwLjAyKLhzU5KLOHA5bWmwa49O13MdhoByZJtzyviQ3a4dgzPWCJBY9YsHHagpAskBMkb0d7xbZeTFr6hiquOnrC3bGnGts9FMxkHAM/bSzK+ya+E/o9o/RTFlTlWlA9p6PxJg79sTEy/ehlTxh/fzl0paA1ud60oD/fRVR8BWM+WKQ3IO5rU7YtCq4aYxE09mCWYxcVCLexKNuqYPQOlAr0KY6axgTRNo/iH7S56dvvYF9pxzWXNEu8uDt2t7LN3i/fOWVbFYwryU5/UeB6GdB+oaz5NsiXIF6+GTPB4uD0l7CIqLV5zRPHbf/BE8bttLD8NIdBaLFtwqjw8J1F2gIs5HwG/bfRnbJ+dK+4Lh+P1N8Yz8L4EZuT1L/6PPDS8zFyzaq/LZHn3gGd7SeeMMbfmy/WD+dLE1qu4HOP6tqD3aJr/wT4i87LhWT8rvvwn84LPTi/fhrz6wmfNX6uLc+yfjkHm8gs+rTa8hTrg/O0Dj56aEegbTTgerIxsnfwPsjNyENaeHgC1y3jNK3N50Bu/rt4+CZ0Csr3X4/XKdab6hSPAG3+Pda8d8BUG/uHspuyzouFLZN/lPv3yL25ZHceeJkG9d00nzEFvlE5lpH42oGXhwWfC4Ir32Wdg7s8G9/6ansAAXXXMwIndWLO3SY6MXNTbe3QH0QZbZ9BMmCtaUwV5VJk3lsT/wdzwfrIP6b/g2u4o7E2dfiqHLg7cWxPTyfdqa83yRFkHGDQnB14B+Fm8vjwZ43H3i36wn/6rHHbR3zWuB337bKL67CJnV2kL6ht2FZXp+5x2IFrrgSuSF2Ecsa+q5yp68OxPpm7ZDTi+7G5Rvo1WRuUO4b/YfRvv5M2Tfzl87hnuPR14KV3wKa+n47Gm1j/Nka2vj4R6z/I3zCxx6Prf8F5Tz+O9f8pWP+RPsho/59ne0T7B/aw7b9eV/ekTybapoz0yQXuP7gHXhoeXt7kU3J61s2bVLnM+U+/WuR+teoTGZ7P2IW6zdeAtz17xrytzd4Z+dhh3LPv9KvYu6evOapOFHUi1W04punaduCl2ve04x8qWQeU1UnSLR/oM3/EaOblj7yoBH8WmWMsqh54qXJkk24LMfhlc5AHXm6/64Xx2JEHrqbJ+OI84uGWKX63e8eddrpfMufAfkloS33CxmY8L/nIMYH1mNOX3eO4Kv+8vSxP59C8g7mk2YGXtCksz5w65T2fPR7T5hxjySkXyKPpy7c2fwc8+p0VukWb/UTyY08/JI+el3t1fIXkx/QZKj+mHddHjTzafta3vQeOafPNeLT9RvvF2ry5hEctox3fWSr3vLVrf5OmxiPtt4xWq8kkPhv534PpLjdfzXBcBZzW5rsqdLYrgp/RhbpKmn+/AvyuBOK3KvhdkPHn0eb7a8oi7repLPLy7Wd5+HKkLDK6Gf42PutjWpsU97wDk+33JuuFsu4S7mmdlCX8Th53Sfr3ZJ3do917HM/YPfWzkK9H2iWeXa22AeXFoaRYNlmbd1esA29P+BmQYWoLT+PjLLMDIvyXnt8xu9dj/dRNvsW6oXxfl4CPtfn5Cr58Wehg743zxOQfa5OlgfitFuCXAk5r80s1+TL9RMqXVT/aj3yZ69bacF8oKifI01eZz2Zjqt3s+W+tzX8omRNFMsaePeeMqf1TBmjt4KJ9gmllTF17jfvwSiP62/vYz9K9kS7tici4FtoJyoPuARzW5o8reKzuNxldyGPVVxQZP0D5p/jRH2Vt/vse131t7pDHRvIz1S00p38lmZxHBlOkHqhrzNMD7f0pj6Vvcluve+IkTrwYp0AeqPzG00/r7PsU7SUe7mkfpoi3RfizqWcarvRx3+PAcdGBo0qWUY+l3A/SRUZN9diLJfPN02N5iIfhp3osceY8uSz3vP7tby8mgXpypB2Q5n2V0c/aPLqCfqngZ3Qh/dT/lCSTvM6zE4Jk2KgM/wsO/p9agv8utBNGdeyESD9pmoyvIjvB2jB+ZNZ2gsFSZidYm8dUyDAvdtaePeeMqf1ThtGHYPeMP9MOiYidpX+KNYpsTM9O+HXEydvv3M/QPWd7tqgeS/ZvI/97MN21OReOSt+kq+FnbT7viWNYX/7EnXjthT1vjeerqyPQTsqujfxzMOXVt4/L5penGzyvJm/frfvE22d89MTbVZfR+OEVtKGPwdYEfQyqZzfV6cmvvH3bNros/TKM3arDD8kjAvOnJniYjU/625hGi0OJz2fJj15dsQ70Wc1lC4ot25N1fk9g3Kr9dD5HXSiKnpQZZfGs1ubvVOj+Kn+MHtT9bU568ofyc17ueb4Hz79HuO25OnQ/J3B1kd/EeaH+yi7ta8836MWin8Hv08BAvngBcNk96gyMAetad7skfW/b+A5MjN1L8VyUvjEvtEsd+h5IJv33fNba/AF0zu+Hzrns0PpiIK0XpW+tY02YSOtI3e6i0NrGLzp/sWuaqF2i88971/T9GezW5t/gXf9vJe+auL4Dz/w89I0gH3Dv+rq+U+rr76yprzP2cDft2dpcmJW+rnOR+jpzL0z+0W/eJl6Q+o2nr0fIpUDf4UStP45H3aNDnjMosjN+HjzgQw7foF1v75C+/75l5Cpg92TkPNr8yh5f49sxoFjjUecOkLaGv43P9baK7wZT1LkdHl+weckxNS5D44o5T36npr/VcO+ivhb5osev7Hfyq6q9HvJbxjNqTSOue8aKfwjr/rl/czxuW3tn2pqNtFPb2iMaO95UrvTA9wecT4zv+FPoX0E2u5uD6q0Va/Nrf3Pc9s8BX2StI93nzsb+6C6kzbeDNkn+vc/Y0qo9eZtb9Bm0if+ijKdtFLUnn/V9b1Df5LUJxkiEBnbdC3zTGJiGkfhaPZ8Lgs9lwZXvMk0maWF/e/yfOv20sYuUV96e5LS8PcW9Oj74QL1mjf7BBGMkgk8icAbqf43P6+khDnvI9cq6xhFnYdfRue7Eselzpj6nPKKpTprmn4FzdkJfoO9n8DfHY+8WfeGV0BdG0BfUtpgmn7Isbnou8XXw6JxL6jrWh6frqA4TqYNH8lHKUM3p8/LLn5jPhSofBX2y6qPQd9qnj2K35JfTBk7x3T69nPBp4wb6yumL9LE0iUl4LvhWZGyz7o8U+Vciz44oip1qU2uL9CKOGtfhzTUvHmXael/03c0673N7H0ParDi4vLyCV3p5n9+GGEKtx0Od15NXdn+avM+9Ggdftnf21SXvwdMTSSP79OK0I2XypQL8KJOtzRtryuTdms/pxfJF+uhVpjGuI7so0zifg3TzobfGVDf3eI/GL5P3fFvJnKANxbhE5TdN+TTtMYWNdk6ffkfyNvUx1vHde3mG5Hf0a2pMUHbvkgNH6sBh9wyO1IGjx1ommzz2St6X8qBVwGltfriCx14R/C4BL/tM8+9XHJw5T67IPa9/+5v0uyT9B9Jvk4eb/7KMftbmnRX0u1fwYz6WfRpebEtelzr4B8mwURn+lx38f7ymDCvb+1b7PlCG7cg1MppShqVJyNhDbz5wzWTXCtpwHyRSrs4LTN7et9aJYmyYfVqb91bIMM+vr7Wjmtqwnl/faBvl16cvwGQH7X6lEfcYKUuPOzDp2qPPLejsIDeGkr4Bw8Xa/CZ8jX+xz3QE2knZtZF/Dqa8omVbE93gQ3vcPvHySNMkZOyhp8uorF9BG/r0vBot08Yuprjn1Wix35vosvR5zuNeHX5IHhFtk6nt49lk23UyEp/Pkh/9dcU68GJJLM6GNTRZh8RqaGYwHY+hxeZ+H+OXsn+n878Zv3UM43ctT05L3zYW4bI2v/jkMX0WQZ/TMfTZ3B83OBKMwYu60WnQ7EQgTKcbwHQCMAXNo8398RMNYCqaW13DdLwBTJTbQXmO66z/Wwcm+sePBtJpRWiwmEz6zDsaa1RnXyto7MEsx6aMNRqT7m3PfmCeY1As5GhJYLIxEoEzAQ0Npqg9Hfo0uZ9Fud7RWDM9l36fjO2eL24yzttTpbxvs6cauF4297FPgD42HnXLDnUo9/zgTD+6/tnj7zegKwWtyXXueyYYI5H3kzjvIqquAHVv1sdZBhwdjTWaS6pzMYLGHsxybMo27yz4trV7qPsE2YKjvVKLYTGZtO07GmtQx2dwd+ypxi6VbYylsbEo25r4c4pkTZf+AtovlDVfDPkSxMs363zoGeA8u81oZG02njRu+wKcR2K+FvqG1edAP0QiY9E3fDL/Thv2pDx3Up4jvzw1JQz0o50EXHbvNPpfkXt1bI2sL41l4nuw5446cNk4x6aEwbN3GMdGH7ytJ/o8otYCdU/znXl+RMo44stnrc1robN93WeP8ffmy7S240nci3xXgTxhQF27KJYwSte2MfiuvHmpukLX/lPFVe1izq9vwvxa+pzxc2151rQ63kk815anWB+cp3XwsXucp0E+tgHXE2XYt0NunowZe3NP7xTG5Lo9CRpZm6OQm2+Nh2/A/Y+TgPN7MXaQj3h9TsYkHRh3bm1+43PGbX8Aa95+p05xVO7VmeOU3ZR19v0E7pXJP8r9Nnqll8MTaYdl/QbVjBk1zSdkXOh8DEzDSHwt11bjNL0zIzg+aaHxVuT/Nte7iP+n/n5a4KROzLnbRCfmHrStHeqzPC89uwJlwFpTPzrlUtRZxE19doz1iVobXK/02XENdzTWYC6pjjG6E8f29HTSnfp6k7POyVuC5uyEvsC6n7+6C/WFfwp94TccfYF7G23s7CJ9QW3Dtrr6cuLnSimP9OCK1EUoZwwGlTN1fTjWJ+3IM/husLepVc61wffr+f/sd9Kmjk1EHmn36P+wz6D9p6G3/xToH59Y/4yn+pN4H+S654M8Bbrre3oj1v+f9eSDjPb/ebZHtH9gD9v+63V1T/pkom3KSJ9c5B4z+b76MhhLb21Ofs4k3rw8W0XlMuc/ZVBkzJrqExme5z4nfOzGus2TwNsuYd7OgreprlFXt9G5Q73FqzdKudpHrUnVbXTM7LL4ZNYlMpytzaeUrAPK6iTplg9EntnIuHHqjTzvytqsleDPPIVTgFfzFFSO9JmnsP2ukacQdN6nm7OsPqOVxD9T5ITTTvdL5hzYvTOivLqa0+oTHFfln7eX5ekcNjZ5zRmB4UwJPrQpLHeDOuWzn7n1nfyPseSUC+TR9OVbm6eCR39VhW7RZj+R/NjTD8mj28TukR8zhk/5Me042iJRPiraftb3KeBh9/X8NfuNba3Nl5TwqOVkz55t6dbDN/y9mh4PVehsRWdbngJ+s67pcVjGn0ebF9eURdxvU1mkulKfssir6REpi4pqetBX6dUHtzXBOhjTxtjw/C8vPtl+J49rex6ixhAXxfl+VbxtMPTsarUNKC8OJcWyydr87Yp14O0Jn4MMU1t4Gh9nmR0Q4b/0/I7MW+Z7Dlpbm3xLz3XXPESutzdX8GXNpbb3Rr5s8o/1zYP2QV2+bLCwro61+Y6afHkvnZs4C75Mfyjlu8EUFetPm9jGVN8s/WXKo+bxaW3eVjInimRMGx8d/fiejOE+wbQypq69xn14pRH97X3sZ+neSJf2RGRcC+0E5UELgNPa/GQFj9X9JmtHHqu+osj4Aco/xY97wtbmX+9x3dfmDnlsVF6up1vY+ORrXvx/pB6oa8zTA+39KY+lb9La/EoFj1XdjPs+K86Y2n/Zvk/RXuKvziC2L9qfTT1T6wpRHyUc8w4cKmPnHTi8eJAgXWTUVI/9UEM91uhSpscS5y5qDqkvO9oOUF+6Rz9r8/9U0E/9T0YX0k/9T4Yjn1P8g2TYqAz/ww7+/31v2QmjOnZCpJ9U54NnJ+jZK9F2gs61JnYC9bZtv/2Ttj6r7ATGzk5rJ3ixs56vq8vYWfqnTHawRp/SiHH83BvmfobuOds7YF+R9YdOSd+aT8d3fxq5ETeetBOvvbDnrfF8dXUE2knZtZF/Dqa8+vZx2fzydIOPL1nHe2GfeLtmWU+8XXUZjR9eSSZluN3z6s2pnt1Upye/8vZt2+iyK7hHf0YdfkgeEZg/NcHDDA/N7yLvOZT4fJb86DMr1oE+q7lsQbGfjXMoZlWLiDkufAdNcmMo/6Lo6flv9IxW2kBPLZkXnl5l9KAsYwyi3bPvlJ9t4q09/1ddunvn5kwb882YBbtHGd7Gl0v7U+Umn/N4mZdjNa0/eR5w2T3qDNzf6Vp3uyB9XxS6ECb6uiNjHbi3RNpdcuh7IJn0CfBZa/NO6Jwvhs654tD6nkBaL0vf3KdQmEjryBjAe4TWNn7R/mLXNFmRvnX+ee+aOoPBbm3+Pt71q0veNXF9LZ55M/SNyPjuPuM69Z3SF/NVNfV17u/spjPrvP2EPuM6dS7SF0N9N+LsL2+fM0IuRdpAtAU4XlD9/YG3P8t1n33/UYdv0F7x4tv7lpEaD6gych5tvmuPr3HP3xoU8zIkbQ1/G5/rzdr0UD926Pk1bV5yTHt/ap8exXPW5u01/a30h7aJb+b+I2MLPX5lv5NfNTl33PO3evlitn651rPvV548HretvTNtfL3OIT5X1x6ZtsZrD3x/op6PjZG9g5+G/hW0ntb5TlRH8mqKfc+Tx21/FvAF+UMmaEM437sLafMAaPNvITd1HTD2s8n5QNPEftLOp8/ggtzz/LDenrLxf9pGQXr8Zj2f1aC+yWsTjJEIDexaBb5R50FH4mv1fOYFH5UbfJd1zsXydHrNMWmqc9MPelrg7IK380ycOrGLgbF9a03rSnFvOyrmmXyqDkw95P8Ml5Kd+/uLyeQa7misQR2d604cmz5n6nNa+6upTsqz84Lm7IS+MHEW1C7UFx4DfeF/OHZ2F+eze7q06mrevr7yVvIn8ts2Z+pR1zEYPF3Hy1+J0sEj+ShlqM0Lw8PLHVnO50WVj4I+WfVR6Dvt00exnacKH0WQbujmjqjPjrkjnh/yHtB22jgqnkln64QxTW30bS/uIVAXGdbVh+gniM6h0/2RIv9K5NkRhCsidopzzXAsq1u8MiUMxLGHWj6u707z/Qn3IWlz1MHlRgWv1Gd5vgDlI31GZfLKxm9qm0fs00fa3E33zj6n5D14eiL5iuFneFG/j5TJRbF8lMnW5vNqymSu5d20b2BzhzI5Sn54Mo2y2D51LyF630DXmLdvoLzHi++0Nl9cMidoQxnu5NOHnTG1f49P0x5T2Gjn9Ol3jMjxIb+jX1Njgpj/QTguOXBU+bGyvjxbNajWxyaPTfO+lAex1oe1+YoKHpsKftRFDT/DK3Vw5jxJ5Z7Xv/1N+l2Q/gPpt8nDV/O+yuhnbb6qgn6rgh/36Ay/NP/OtuR1lxz8o2qzl+F/0cH/jTVlWNnet9r3gTJsR65RmvdLGRblZ/Tmg41PGWZtesgtc+WqweLpqirDqLdZm2+rkGGeX7+NDFlJduYW05ZJ0X+EX5/6h8kO2v1KI+4xejkthKmodqjqWNm/jfzvwXSXG0Op9KUu8b/A1/hzT96J152sI9BOyq6N/HMw5RUt29K8rzq6wY/ucfvE5FVfvD1Nxpcn61fQhnqUrQlvH7Jt7CL5la0J6vltdFn6PJlHVYcfkkdE22Rq+zSJ5VrGc9bmFyrWgRdLwjib42i/0Q2eg6yP0xjP3gHjr+33Zzxz3O5XnrwTroh959PJ5DUnf5M3k6cG1QXZhOl4A5h4hmhU/RT6EuvA1Ic/lfsVdWBaAUxRe6B7JaduMQmpU71eh/cHjT2Y5dhF+xLT6vLUpaNqdiwJTDZGInDa1UM80MS5VYv4vHtu1Z4c2z2326t5oTEPdWD04nUi/RDZeCYLOS5jMzq0dQfcX7cxNmNmYNP+NXSloDW5Tv99gjF4kU/wXUTp0LTXGetDe72jsdbr+AGCxh7McmzKNs8P1qR+r+cH07XTtWwjTDZGInDq90j+sSTjGC0IR0djDer4lu6OPdXYpbKNfgwbS23ZMhhXcK9I1nQ4NwtzcdLPHY8dWT+jSfzoe54+bntfDl/223Z9qfyTODU9r43nGNpzJ+S5E/Ic+eWpKWFgzlzZedXU4Tm/po2Rtee8PXk9c60tDJ69Q38648RsPdHnEbUWqHva2lzA3zYmZRzx9Wr2fkY+T7M5+7mfO8bfmy/T2o6cu5HvKpAnDKhrU18I2lea0LVtDL4rb16qrtD1Ppfi6p1NZm2ejvn1a587fq4tz5pWx+N+YVueov7iuvhoXbFAH9uA64ky7HmQmydixt60S1g7jOuW+x3W5tshNx+Ih2/ijNkTgPMhjB3kI16fkzFJB+o51uaLQZsvxZq336PrSrO2V5n8o9xvo1d6+8mRdlhkHBljihOMkQgN7OI5VlF5GZH4Wg7rguCjeR98l3VyLGwe21xvm/NEfxz3k8viTjh3m+jE3Jvm2rF73nmzQTJgrakfnXIpqmZrU59dD7H1Q65X2h5cwx2NtanDV+UW3Ilje3o66U59vUlOeg819Cf0BcZkfMcu1BeuQl/4bkdf4N5GGzu7SF/w8lPb6OrUPRYcuOZK4IrURShnrA+VM3V9ONanV+Od76fL8wY9/5/9Tto0yX2gTNW68oH7T0Nv/ynQPz6x/plr+ePxPkg3h907b2d7zWD9/+89+SCj/X+e7RHtH9jDtv96Xd2TPplomzLSJxe5x0y+r74M+l6tzW/n9Kx7xpvKZS8HNjpmTfWJDM8P7ELd5peeNm77+zPmbapr1NVtymLy6Vexd899hcjasepnsfE55naty2RS96CuZG3+pGQdUFYnSbd8oM+6pkYzr67pfy/Bv+5ZIypH+oz/3y11TY3GK2hTpnd6+yVzDuxeXSTvnCU9v28uaVZ/hOOq/PP2sjydw/o47uCTlOBj98hzgnh5Y18TY58jY+lXGsBUdK5B1/K2SSw9ay9E+r+a1FykzyUovn+dPKgOTFzzpwPppHWFFpNJftDRWKM6fCZo7MEsx6af0OPD5KFN+DDzuKL2lJrmf9B3ERm3buOQhoSjo7HuxvbFj+3G9pmMY40t6kPZVQdGxvYt4J7uk0XHlmvt20zf/vSnjL8/5iljOKJiGJrm4bE+26kYmIb0P9FfTP9TR2ON6vi1gsYezHJsyh/6E9RP09Tvx/PegnSm0ZLAZGMkAqdd1JmizpSnTCQN7zS9ZZ+MXSp/GKdBP312NdXXesghHtDGYD3C50G+BPHyzdhy5qDT58EzO63NEz5v3PaBHD7Wd+K+oe4PMR7P+rW/6ZvU/RTCqPB48bcXpoRhJdnpy6V/19uHaRIHn/Vl53V6Z1Tbc945tDbOqSlhoEw4Cbjs3kXcszVAv0RUvCjXp+mGuoc0l0yeaU18+ay1eT10tq9/yhh/b75MK1+Z6xz5riLjUqlrU58MOh99Qte2MfiuvHmp/LjLff05B1fVHTi/vgXza/mp4+fa8iyN6yc8Ojb70vPbp+EpmrNfFx+7x3kadCb1gOvJxsjewXdCbgb54Nw6scoDKEuPQ25+Tzx8EzoF5fv3x+sU6011in//1HHbf4Q178UinZR7deY4ZTdlnX1nzdAy+Ue5vyz36sYjaG3vQFk6CtyHbJw/zLqpUfnDkfhabPkxBx/iyndZJx7cs/Gn9TFTT+X+lvWvemxTnZj7nrZ2TuKerR3qDkEyYK2pr4FyKbIexMkGMLEeRGRu/YLQ4E6syTDLsT09nXSnvt4kFrCHukIT+gLzO399F+oL74S+8O8dfYH+nzZ2dpG+4MWut9HVqXscc+CaK4ErUhehnDEYVM7U9eFoTDdlHd8P63xY/03WBuWO4X8M/fN367+OTWT3ys7GVd2tSxuUcpTj9e2D/NMe9rj4TnT9n3De05uw/v+8Jx9ktP/Psz2i/QN72PZfr6t70icTbVNG+uQC98bWyffVl8G4xu0YlpyeRbHlaquoXOb8595f5H616hMZnheeGj52Y93mc8HbUszbWfA27wyuOrqNzh3qLZRp9u65rxAVf0SdSHUbjmm6tsWWa0w87fhPK1kHC0nMHmtkTnTWn55HaTRjDr21GZXgz9hyxotqbLnKkT5jy7ffNWLL52No655HaeNTf/fOozzutNP9kjkHdi+uSmswdaFPcFyVf95elqdzLOJ3e75NTaesL6u3T53yWc/c+k7+x3hvrROjvnPy0qeBR39NhW7RZj+R/NjTD8mj28Q3kB/TBlR+TDuO+26R59go/7f3oGNml/Fo+425Gtbm+SU8ijnQfGeX5J63dr0zwoxH9nBGmHsOiOHvnQPycIXOlgp+RpcLwM87wyoNxE/znBZk/Hm0eWlNWcT9NpVFqiv1KYu8s5EjZZHmOTGmNruY58RzSGxNsFZNm/VCWTePe14MF38nPdi/J+vsHvVY423km+pnIV+PtEs8u1ptA8qLQ0mxbLI2b6xYB96e8AXIMLWFp/FxltkBEf5Lz+/IvFbKsKC1tcm3WJuF72sen9bmLRV8WetsaG4gc3S5hvvMPzVYvPzT76rJl+kn2k35p7uFL7Oel+afBvrZhp6+arBwTLWbPf+ttXl7yZwokjFa25Njav+UAVo/p2ifYFoZU9de4z680oj+9j72s3RvpEt7IjKuhXaC8qBlwGltfqqCx+p+k9GFfaqvKDJ+gPJP8WO8ibX5uT2u+9rcIY+N5GeqW9j45LHWpg//tLfGPD3Q3p/yWPomrc2vVvBY1c2473PCGVP7L9v3KdpL/PUZxPZF+7PJ67XWAvVRwnHYgaNKllGP7eG8g1FTPfY/N9RjjS5leixx9urRNanVyHdRlD8a7Uv36Gdt/qSCfmpPG11IP/U/2X27PDshSIaNyvBfcPD/i71lJ4zq2AmRflKdD56dYG0YPzJrO8FgKbMTtuuO5THzVXaCVyeu6Zkdds+LnaUdEhE7S7lksoM59J6d8P1O3Av3M3TP2Z7lGqRu0WXs0lwyuedHGnm5EWeRG/GYz9uJ117Y89Z4vro6Au2k7NrIPwdTXn37uLh+7dPafELJOt4L+8Qmr/ri7arLaPzwSuLX1tWaftTpuV6a6PTkV96+bRtdln4Z6ul1+CF5RGD+1AQPMzw0v4u851Di81nyo42KdaDPai5b5LnapwSeOfl7Ht+ZEx8U7zZxrjb5tN2jTtEkVoG6UBQ9ac+r7uvF0z2tZF54vgGjB3V/m5Pefj7lZ5t4a8oy2gt16K71kruI+ea75H6l9d/Gl0v7k3KzDi/zcqym9SczNsjuUWfg/k7Xuts90rfu0xImxu5FxjpcErrZ+Dqm0ZN46LPZ9c+gc74UOucph9bzgbQ+IX3bWJ6eSlpHxgDOC730zIno+ad2ic4/711rfSO+63+Ad/2akndNXF+PZ94CfSPIB9x7XKe+U/pivqamvs5cFNXXVRb0qa9vx0vMKK5T5yJ9Mcyt8GIXu4rFjJZLkTYQbYGi3McOec7A25/lus++v8vhG1V1A/qWkSlg92TkPNp89x5f456/NSjmZUjaGv56ptwK2rDGa1C+3tDjCzYvdcxNOkkb8gtr88M1/a2eP7RtfS3GFnr8ir9b/01iC+v6W+lbfRfW/X1PG4/b1t6ZtqYU7dS29kgbvyblSg98v/B8o5+B/hWZA8c5ULRWrM33PW3c9j2ALyr/j7QhnP9mF9LmQdDmfZCbXv58m1onTfIXNPaTdj59BvfIPc8P6+0pG++kbRSkx2/W87kS1Dd5bYIxEqGBXVeAb5BOM4zE1+r5HBZ81Nbku9TYTPu7Kh/J+tJzN9hXmc5N3r0icHbB2y/jXll8PGPfgvSaNfoHE4yRCD6JwBkZ80w+VQemHvJ/hlyv5KFcwx2NNaijc92JY9PnTH1Oa3811Ul5znbQnJ3QF+j7+egu1Bc+A/pCkn+nnR2Ri6K+V08HL8pX0T2HunsoXr55Vb2dovyVKB08ko9Shtq8MDy83JEj+Vyo8lHs1rPLtm1v+Cgiz85T/UR9dswd8fyQ86DttHED1Ke9fIs2+jbjHriWonwsdfUh+gmi88B1f6TIvxJ5dkTXtZDK4s4NR2+uefEo09bXpu9uL+V9PqaCV3p5n89z6mvTZ1Qmr2z8prZ5xD59pM3ddO/sySXvwdMTtWYrfQrUMyNl8j0F+FEmW5un15TJXMu7ad/Aq/kS6aNXmWbjk3/qXkKgbj701pjq5h7vOSUwkvc8r2RO0IZizRnlN035NO0xhY12Tp9+x4gcH/I7+jUNV/o173HguOzAUeXHYq0P2qop+uiax67mfSkPSgGntXl1BY9dFfyMLuSxhteqgzPnyarc8/q3v0m/e6T/QPpt8nDzX5bRz9p8TQX9rgh+RhfSz/BiW/K6yw7+UbXZy/C/5OD/ppoyrGzvW+37PnONjKaUYVF+Rm8+2PiUYdaG+yCRclX9Ld7e93aMgLRh/pm1+fsVMszz67fJQ6S89/z6q+g/wq9PuaTnW1KW0rb9N44sPe7ApGuPMj7yrB6NodSz26hLvA2+xvc+bSded7KOQDspuzbyz8GUV7Rsa6IbvGuP2ycmr/ri7arLqKxfQRvql7YmvH3ItrGL5Fe2Jqjnt9Fl6fOk374OPySPiLbJ1PbxbDKjhcoz5t5Zm1+sWAdeLMnPOHye46+gbdH41uZXwWfnnr6zX/ol1Vc5l1TX/lzGWIu4Z9+Po3/ljV3wWeag2Hyhv4y5jFE+BfX/ckyby+o7pK1sbT5QMleW0Y7vTPcRdqFd2Vh2/EFDu9LoUmZXLuB7BH6p4Kd25zzafKQD2WhrbrfIxosxtHVjfm18ykFrQ9lka4Ky0Z7hemliK/BMCONj1FXtd/K4i9L/Rad/3cvyYj6ze6wxlF3k6wvJTh/+Rv73YLqrVDZyTKNFmWzcbpPD3UQ2fuBzt76zjgz54YLc82xULyZAc7YpdyjD5uXeHO5Z/3X2SiivKMO8fdWgtVWaj0QdbFsXLXlf7Mue8/YrtUZl37kYBouXi3GhYj4aX14GvMqXVT/aj3yZfMHasN7JYiBMWivAy4vQ2jeqt82jzSeWzIkiGaN8iWNq/5QBds+TMdwPnlbGUJ54+WqGq5dfwpoIPw5e7Plt2tQAoj2xjE/7HmFPBOYluvXbvD08a/P4Ch5bVL+NPNarL9ZHnnLZvry1+ZyaPHa36r42d8hjl2No6+4R2/jksdaG8zlSD9Q15umBRfvW1IOszbMreKxXT2faGKpl9OXlOn2Hw9u8+mZNeHwT3qa6Zxd6LPVMw5W+8XkHDq+mmcrYCw4cWgcvUBcZNdVjv6yhHmt0KdNjiTPnieabe/17Z5jMS//RdoDGA3v0szavqaBfUe100k/9T9bWLs9OiIwtK8L/Hgf/r95bdsKojp0Q6SfVd+zZCbTHDKZIO0HlahM7gXqbtfnmmnYC962ntRNW8Gn8mXaI/U7evSL9rzj92z3WMNW6U7QTGE/mxYA9BFlaFuNma8/eAffAqVt0vW+tdW5sLPqsrM33PH0M6089fSde5P0rcq8O/alvUFfQdzmNjmDzp6mOQDspuzbyz8GUV98+Lptfnm7wj2vy9t2a6+LV44jk7UX1j3mOoHe+lOanUKfnemmi05Nf8bxz67+NLruS7DzToi4/JI9YSOJqNJKHGR4aJ0Xecyjx+Sz50c9WrAN9djOP4XPHuAblxa1x7ARjJIK/XUV1i7qkP31RnPd2j++gSU1Wyr8oenr+mxWhHW2gX63Q/VWvIj2yi/LH2wuh/GyzV+f5v+rSnfk808DA/ULGLNg9yvA2vlzan5SbdXiZjXPPlDDQn0z+qHWCdX+na91N6x9eFroQJvLsFM9F2dLzQrvUoe+BZNInwGetzf3P2PrM1udHoHMuOrS+GEjrBenbxvLifkjryJypi0JrjYeLnn+L0rfOP+9dLwjd+K5P413/ecm7Jq4fhU1y6hljvIPs595z0/Wd0hcz94xJuvCivs79HdXXVRbMej8hcs9WfTE6F+mLob7LfFyD3ehG2dhEv/H2OSPkUqQNRFuA42nt5o7GG3j7s1z32fdr+XePH9PWp++/bxm5Ctg9GTmPNpf2+BrfLbHkXG/Whr6gyLM01K9p81LH3KSTtKG9YG0+uWROFMVltIlv5v6jl8dDfmW/k181iYv3/K3kwdTzsotrPfv+Q88Yj9vW3mkTP7eS7IypmMYeaRPXQbnSA98fcD4xJuaJ0L+C1tM634nqSLTZrc3qM8dtnwT4gvwhE7QhnE/ZhbT5v7B+ng65qeuAsZ9aEyVBv/Z3F7GftPPpM7gk9zw/rLenbPy/h3oWmzUy7w3qm7w2wRiJ0MCue4FvGgPTMBJfq5F5QfDRPVO+yzSZpIX97fF/L7aQc7xtbOFxgbML3p7iXp3YxcDYvjX6BxOMkQg++j0y5nlJxqyCqYf8nyHXq429mEyu4Y7GGtTRue7Eselzpj5nYzWtn2v30vwzcM5O6Av0/fytXagv/CvoC2907GzqC238I158svpePR3cyz0nfyK/bVNPm7qOffd0HS9/JUoHj+SjlKF6dpyXO/KWmj4K+mRnWMtkh49iO08VPoo+z/FQnx1zRzw/5EXQdlqblWdbaD56W33bi3sI1EWGdfUh+gmic+h0f6TIv3IafUwDA99pVS56V7FT9G0Zjl7Mnpcr2gYG4khYImMl1Xe3IrgQ7kPSZtnB5acqeKU+m83ZFDGE1g99RmXyysZvaptH7NNH2txN987eV/IePD2RurvhZ3jRjujj/EnFjzLZ2vxaTZnMtbyb9g1s7szq/Dw9950yrYca6ENvjXn7Bsp7vPhOa/N7FfsGmrdCPn2PM6b27/Fp2mMKG+2cPv2OETk+5Hf0a2pMEPM/CEfqwGH3DI7UgcOzVVfRR9c89krel/KgVcBpbf6sgsdeEfy09uUy8Lri4Mx5ckXuef3b36TfJek/kH6bPNz8l2X02/al5nsXRfS7V/AzupB+hhfbktelDv5BMmxUhv9lB/+FEvzr7n2rfR8ow3bkGhlNKcPSJGTsoTcfbHzKMGvTQ26ZK1f1/Ebyc5Vh1NuszcmSOVHk128jQ7zcYtoyV9B/hF+fvgDDlXa/0oh7jF5OC2HStbeAT66l7N9G/vdgusuNoVT6Upd4NPZtn/zMnXjdyToC7aTs2sg/B1Ne0bKtiW5wrSZv3632icmrvni76jIq61eSnecHkh96+5BtYxdT3DuOZ6x/+72JLkufJ2ub1eGH5BHRNpnaPk1iuWgTWZunVawDL5bE4myy38/k95mL9Kxnjn8/l98/g9+fDVqdwXgb+edgyivrV2uEddT3iOdCJRiDF3k/awhFnaXzCMD0pQ+/+ikPv/45N7/sxbduvvrFL3/Zsx5+5Vc+/KpXz2FoDT3jb0WoHMC9Q/h+xvmd11xSfRR24Otaz/oOKlm7aU7YsjGRo8drz6PNAxXmlJbVtvfEctZGe4rq0zH4rTGlnHAmAqddPRz5vtZ0+ZFOUaWLWSa9DkwM844qFcRS1HVgWgFMQdsZ69xeqAMTRU9UmSeKOG6tMDS5m7HWr84l1SHPMWNvhcfMauyMrt5ReZrGXAdGhoT3ED4/2ispz4vJpArd0ViDOqr53bGnGntdb9Bs4pb1tGYT3SxRJopXiiHQrTPwQi8yXezNcN/8fZgbUXpm9n5OJpNXXbMgqjTFEsYx2BZxL0m6lW3HBVf7+0Do2FtrdVZjU7YZjUl3yrYqGOnO4LFBQbrPaElgsjESgdMuyttIvVVLMi4mk2EwHY018MJrNHzo7thTjV0q2+ji7qocW+B6GdDdxfCod0G+BPHyzVIxJzHmPGBhqTRr848/f9z23di+MHccj4s+Kfc4lvbL7QUb/ySeOyPPqX+I/PLclDCs4B7fi93jFs1xuVeHH7McHPWGOmWxbJyTU8LgyYTlZKefiWXq6POIKkPB9WnuZC80kSX2iC+ftTb/Djrb7z5zjL83X6aVr2dwL/JdBeqcE+UIqE8GlWuc0LVtDL4rb14qP+56S1dxVd2B8+uDmF8PP2v8XFueZf1yDq5IXytOX3bvDJ5ry1OsD87TOvio7AiUXQOuJ5Yb/SNnGyhiW/gcxuS6PQMaWZuvgtz8k3j4BkVbZP8vxj4ZSJszQhuD5SRoY202QJu/wJrXLUCWk+TaqJrjlN2UdXrceZX86+JYPeMj9EEHydJRYAjUiCG0CcZIhAZ2MXU3ykcUia+la684+BBXvss6PjSbxzbXabNwjjexWU7inhc2pnpsU53YO7qM5Y1t7fTgi1pr6mugXAryo6+TT9WBqQ//Kdcrj9ngGu5orIEXTqKh9Hfi2J6e3kVKWA97PxP6AkNyPulZ43u7RV84D33hU3P4qC/Q/9PGzi7SF9Q2bKure+XgCddcCVyRugjljMGgcqauD0dLW1LWeSmbpF+TtUE6nsZ363/a8uNeqa4i3a1LG5RytId4hYn1Tx/kU7H+o/a4+E50/R933tNHnjVu+wys/0gfZLT/z7M9ov0De9j2X6+re9InE21TRvrkAvfG1sn31ZexAhpYm5fl9CyKN1RbReUy5z/3/oL0iyF5G/c6XrULdZt3gbe9dsa8TXWNurqNzh3qLfSr2LvnvkJUbBN1ItVtOKbp2hbirmUZaMd/fck6oKxOkm75wHwMjTbnqh5rynLm9mltvqUEf6a6nAO8muqicqTPVJftd41Ul0MxtB2Stoa/d7yItSnTO739kjkH9kNCW+oTLIUzrT7BcVX+eXtZns6hR23NJdXx/UU2xdn8O3XKHwCvD4prH1HOJBgjETwSwTVwH2DIuPZzoNtp0MbGPS1w2t/euzvf8rkjLZ+zd7qU/yM+2d+PzL9T1v7TZ41//zi0tc9H5N8fiWfe9sqt75STzDnQWAndY6HMfTdk+YcqdNA2+86U254dEX20LfdNvCNC+khXs77tPXBM40smy+23c8DZ2ry3RJYxP4bvTI9A9Xh8nTJ8GS5B5fQmjlPROXsBcFqbX67Q7bV0i9GFvgPDi+VkIo8CvCD4Lcj482jz/po6C/mx6iyqU/eps9jc6Utn0XTweeCcXStow/RWPTK07XqhTnQI97xYP/udPO6Q9O/pROzXPsnb7J7648jXI+1Xz/+iNiTlxaGkWDZZmw9XrAMvduBVkGHqM5nGF15mL0b4uT3/tFdaInBtrVt/2aV8+RDwsTYfreDL80IHe2/ky1oWInC/3OXLBgtLGm+Xl/j8YvzIl+lPVL6s+tF+5MvU8a0N9w+D/JND+k4MJvXh06+qPIpzc9ufWzInimRMG1/uisBl97z9pGllTF27nvEaSiPuy/Sx76l7aF3aE5HxT7QTlAfRr7VdmqdkvrEve87oQh6rPsXIOBPKP8WPcUnW5lNq8tjdqvtu+5vAYyOPX1bdwsYnj/VyhqN8OZ5/X/U0rkPlsdxvsDafXsFjVTfz8qjqrH3GpzE2xtuX+aSe9uuKeFvEvgf1TKMD90IijxoI1EVGTfXYZ1XwWNVjjS5leixx5jyZl3te//a3F7tCPTnSDtA9F49+1uZ5FfRTe9roQvqp/ylJJnmdZycEybBRGf4LDv4P7S07YVRnzyloP690z4kyzNowzijSTlC52sRO4Nq0Nq+oaScwxnpaO8GLseae2rQx1vO4xxg6+9SjJClLqRP+v06OJvczNDbB3gHXIH1MXca4zSWTe8OkkZdD83cQ9/m2z9+J116IjdC4z7o6Au2k7NrIPwdTXn37uOijNDpZmzfX5O27NZ7A5BV5e+QemOoyGme+gjb0MZwCbQx21bPJG5IC2jLmjzkh3v7+tDVmuG7q8EPyiGib7JzgoXmA5D2HEp/Pkh/9rxXrQJ/VnMegOMG1pnktBkekPkFezDmitnod/uzFtETSk3az1l7w4i7fXaH7qw1u9PBqGHj7+ZSfbWqoUZZ5ufr2nEf3U+hjGhjok6GM7esoP3vOy1mIrL1Fu5g6A/d3utbd5qXve4QuhKmHowMnbOl5od0Fh74HkkmfAJ+1NhefvfWZrc/3Q+c84dD6cCCtj0vfKhcJE2kdZFuuEwajNevF2PiR8++E9K3zz3vXmp/Hd/1XsC9+r+RdE9cP4pmPQt+IqnnQd/yvvlP6Yj5UU19nzpLq6yoL+tTXt22RnvR19cXoXKQvhv4FL8Z12rpGnr4eVRMyKqaftgDHC8rJGxTFAH0UPOBCLi88fuzleM1CRmo8oMrIebSZf/YkbLz2who3vsU1HnkskMZH2vhcb9bmJOgRGTum61Z9mNTRD0kbyvhtP1XJnIiKy2Bsocev7HfyqyaxhYxn1DqzRXmFF6Abfuuzx+O2tXemrT1GO7WtPdLGr0m7uQe+P+B8YnzHJz17fC/IZl/nO1EdiTa7tTn8BeO2nwr4ovJEvdifbOzhLqTNL2L9XIXc9OosqI+ibbxR3fwF2vkRR3IF6vGbdZ+ijjokr00wRiI0sItHCAfpNMNIfK3u04Lgc4/gyndZdYRakU5vc4RzvInOTX/4aYGzC97uHVVVFh/PHNgIX3ST8xMYnxUV80w+VQemHvJ/hlyvjIPnGu5orEEdnetOHNuLAyTdaY820UltTgTO2Ql9gb6fh3ehvvB26AsvduzsiFwU9b16Onh0vgp1HYPB03W8HMwoHbzv3BHDw8sdeX1NH8VuzR3pOyZM9RP12TF3xPNDenFObf2Q87jn5Vu00bcZ90C5H6SLDOvqQ/QTcC+2izzwsnwPw9fzr0SeMVIUX922ZtZJB0f1m3lz7bTA1RYG4kjfXWQOgq4lrbFFuA9Jm5MOLm+r4JX6LM+hoHykz6hMXtn4TW3zqDj4KJu76d7ZO0veg6cnau4EfQq0IyJl8nwBfrrnnl0/VlMmcy3vpn0DL5YvSn54Ms3Gpz6sewnRcdqqL3syRutlefq7tXlPxb4B/QbZxbXftK42Y1CsL4WNdk6ffkfyNvUx1vHdU9dn/I99py6iMUHM/yAcFxw4qvxYWV+erRpU62OTx9oR8MqDWOvD2vxuBY+9JPgZXchjDa9LDs6cJ5fknte//U36zUv/gfTb5OHmvyyjn7X5UAX9Lgt+RhfSz/DStnZdcPCPquFfhv89Dv4f6WDvW+37PnONjLaUYZdiaDv05oONT757Gb8bTEH5365cNVg8XVVlGPU2a/OXNfe+6ddvI0OYL+v59S+g/2n9+pdwT+NpaMfS7lcacY+RsvSoA5OuPZ4TwbXUdbygxlAqfWknPRL7tp/2BTvxupN1BNpJ2bWRfw6mvKJlWxPd4MIXTNKB116wT7ZrYoG3R+0hebqMyvoVtKFPz9aEtw/Ztt4o9yFtTVDPb6PL0ufJ/IE6/JA8InC/ZOj5qNSmKZNnrKVvbUYV68CLJfkk8HmjBXU25fNaoyIwRnNI/OcFnkUH/8eW4M++FBdPN3hczb7sOWvH3HyVCQeSnXJK2zLm8FKN5+w6Js9w79GTSbTxjgGv7ub4cODxmnMCL9+p5oeTB1mbp1a8F52v1gfz96i3Fs0pa/OMivEuF4w37/T1+TX7suesHe1Vg9XaHkgm33nitOWcqnrukvTBZ8hXCdMlGYcxPNm1kX8OprmGgwFhIvyE76LAHm0nKR/QuVs2v8nbrM1DFTzcO9flex8/vqcx6XPoy+ao1V+mDLE2L4au/F2OruydXdIkL3M52Znzy7lKW2he7nk24LzTP+lq9+w7fWderYzIuaL6sr0Hjmlz2eaK/XYWOFmb15XMlWW04ztblXtzuGf929+kaZp/t98yWl0RfDbyvwfTXZv6/715XzpnrwBOa/O1FXz1XsHP6HIW+Ble9wK/ewPxuyL4XZTx59Hm6zuwb+zZWdg3ad4v7ZugGM8haWv42/hG4xW0WcU9WxMpaNtmvazgnic7GRNhv5PHqR5w2enf7nkxCrTZjLdxP/O7YN/QpxNt39h68/xIh5Ji2WRtvq9iHeizGa4/s5Fs08nOKyA/XJZ7Xfh7KMN0T8XbD65TV57yijLM5jRlWNDa2uRbad6X8mXq1NbmRyr4cip0sPdGvmzyLwV+q4H4XSnAbxVwWpt/VpMv85yM3eR3SvN+Z82Xjcbky9xDOhIIk+qrBgvHNFiUR9HXbG1+pmROFMkYe/acM6b2Txng2T/GZ+hDm1bGUJ6oj4gy5iLGVBpl6+mtG2PYvFqkR+TeHO4ZHEcETtoTR3DPvkfYE9H7mprTa7Tkvqa1+a0KHqs5rEYX8ljDq68zPu4pwI++fWvze3tc993234LHRvKzolgzrkfNd4rWA3WNeXqgxj2eFRipH3y4gseqbsYYUS8XQPv3YkSPoC+FLZvHr9sYj+n5SlT37Jq3qe7ZhR7rxRkxN+YeB45LDhx1Ymds7VPuR+UBNtVj55+z9VlXjzW6lOmxxJnzJJV7Xv/2txe7Zb9F2wGmD5fRz9osV9BvVfAzupB+af6dbcnrPDshMnatCP+LDv4nS/DfhXbCqI6dEOkn1flg41OGWRvGS8/aTuDZVkV2grW5UjInaCcw9siePeeMqf17OYj0uxt/TtG//U7efVT6P+r0r/tUtBPon9Ja7EV2whM3xs/a79zP0DxDe9baqj6T/cu77GQunJW+bSz6rKzN6DljWJ/znJ14kffrHnId+nvxWdQbutARqHvYZx0dgXZSdm3kn4Mpr759XLrnSp70WTV5O+fMbspXNHnVF29Pk/FFWc+4SGtDH4OtCfoYVM9uqtOTX9maOIr+2+iy9MvQn1GHH5JHROeDnE0m8TD6c0yjxaHE57PkR19SsQ702QzXz9gY4xoUZ7W25MA0J3/P47vBEalPkB6UyXbPi78yOMti6c4D9ih6Umao7ks9x9q8uEL3L4qjou5/HN/tU/dt6N87J7izf8+/R7jtuTp011iMtjCsJJM+VutT/ZVd2teeb/CiAxfrCE4DA/kiY3TsHnWGFP12rbtdlr5ToQthYgz1Kp6L0jfmhXarDn0PJJP+ez5rbX4FOufXQ+c86tD6UiCtj0jfNpanp5LWkbrdJaG1jc/aVmkgTdQusbH4HvRdHxG68V3/E7zrN5e8a+L6D/DMj0DfCPIB966v6zulvv5dNfV15q7spj1bmwuz0td1LlJfp4/d5B/95m3iBanfePp6hFwK9B0OaQtwPOoeHfKcQZGd8SPgAb/s8A3aK/YO6fvvW0ZqXIbKyHm0+Rd7fI1vx4BijadJyNhuXIaNz/VmbYry+6L9rdQZbEyNy9C4Ys6Tn63pbzXc2/rj6A9Ncc/jV/Y7+VUq/adO/3aPvpNj+G6ftl5t/XKtZ98f94XjcdvaO232NVcSP9ajrT2iseNN5UoPfH/A+cT4jt+B/hVks6/znaiOxLVibX78C8dtPwD4gvwhE7QhnP/nLqTNV4M2H4Lc7Cu2tGpP3uYWfQZt4r8o42kbRe3JZ33fF9Q3eW2CMRKhgV33Ad8gnWYYia/VOb4o+KSCK9/lajJJC/vb4//U6aeNXaS88vYkp+Xtq7hXxwcfqNes0T+YYIxE8EkEzkD9r3Gd4xQwRa0NrleDbTGZXMMdjTWoo3PdiWPT50x9LgUs2dVUJ7U5EThnJ/QFGyOTx6e/cDz2btEXngt94Xz+nXZ2F/mUZXHTc4mvg0fnXFLXsT48XUd1mEgdPJKPUoZqTl8K2libT87nQpWPgj5Z9VHoO+3TR7Fte/eUO6L6ifrsGBPm+SEvgbbTxg30ldMX6WNpEpPwOPCtyNhm3R8p8q94sXHT+iGqYqc05roujscdHKtq0BfFo7SBgTjSdzfrvM/tfQxpc9zB5TkVvNLL+5zb2PpO+UifUZm8svvT5H3u1Tj4sr2zWyXvwdMTjS5cW16cdhqDn1sjU/VG8uKX1JTJuzWf04vli/TRq0yz8akP615CoG7u1jZT3dzjPRq/TN7z2pI5QRuKcYnKb5ryadpjChvtnD79juRt6mOs47v38gzJ76iLaExQdu+yA8eqA4fqiasOHGn+nbbqFfTRNY/VWib2Tq8ATmvz9yp4bFEtE/JYw+teB2fOk3vlnte//U36XZb+o2vB3Jf3VUY/a/NdFfS7T/BLk8n2y8CLbcnrVh380yQE/1EZ/qmD//9cU4aV7X2rfd9nrpHRlDIsys/ozQcbn3LD2nAfJFKuzgtM3t631olibJh9Wpt3VMgwz6+vtaOa2rCeX/9e9B/h16cvwGQH7X6lEfcYKUu92oS69qytzoXs30b+92C6y42hpK1uuFibn4av8T/uMx2BdlJ2beSfgymvvuuclekGv7zH7ZM077cv3q66jI1P3m5tyLe8Gi3Txi6SX3k1WtrosvR5zuNeHX5IHhFtk6nt49lkRguVZ7SlrM1/qlgHXizJ74DPq18+G1/PKLT5wHxua/Nh8NkLz93ZL/2S6qucwz3r1/4mH7SxGHOltXOJq1fv0/r3ckbVJ0e/Z4p7RkPa733E/Vnf6hPP7ttctrliv9FnZW3+smSuLKMd35nuI9S1K20N9mBXurLD8Pdkxz3PLaaDxyuNLqS/Z/f0WSNzRcafR5vFEvwoG7m3qLJR68j3KRtt7lA2Rp6lYnQj/kkyqbdbG8ou+ucNdnuG66WJbGSNfuNj1FX1LFzyAOt/0enf7jE/Mc2/UwZpvi75evYeIs9iUJ3Y2zs0WhxKimWTtVmtWAf6bIbrmx639T1b45ZDSn6o+ytzyc78Yfub/NBgYi6n1nOgv5Tvd9raSCnuaf5I4Npyz1Y0mnNv1doMK/jyvNDB3hv5su5l9Z2LYbBQF7U299fky+cBr/Jl1Y/2I1+mfWJtGCdwLhAm9Qt4viF7f8qjODetzRNL5kSRjFG+xDG1f8oAu+fJmLPof1oZ4+XDMS5L413Ji41G2Xp6AXixVx/svNyrQwfaE+dxz75H2BOB+QIjzy9ntKS9aG2eV8FjVVcxuvD9qM3ad4yh+lUpEx/c47qvzR3y2PMxtHX9EVq7zosLitYDdY15euD2/n7i7/1RP3h5BY9V3Yw+23POmNo/eaDdO4++FLZsHj/W4W3UM9vw+Ca8zaslNq0em+Ke7tV7ewr0vROONr73QF1k1FSP/YaGeqzRpUyPJc6cJ/Nyz+vf/vbipKknR9oBpg+X0c/avLmCfquCn9GF9FP/U5JM8jrPTgiSYaMy/Fcc/L9zb9kJozp2QqSfVOeDZydYG+5VRtoJKleb2Alcm9bmB2vaCYy9mtZOYDy3nqeyhN/Ju5ucR8n92zT/Tv+U1sihLKVOuABZqrWAKLf1rEPGMFC36HrfWuss2Vje2eTvfu4Y1t967k68yPsvyL069Ke+wfeg73IaHcHmT1MdgXZSdm3kn4Mpr759XDa/PN3gvTV5O+eM8nbVO/u0T0xe9cXbVZfRvWfGndLH4J2poXp2U52e/MrWhFdTtokuu4J753Evzb+X8UPyiMg6PeRhhofWICXv0bMduRdpbf6PinWgz27mMTxujGuQ7F4jX00wRiL422VwRNrppAdlsp7Zy/0Ru696IJ87CNij6EmZobov4bc2H67Q/VX+GD2o+3s183Xfhv49r86r9e/59wxu5vDUobue6dUWhpVkZ84s5Sll+Ircq7MfSfvQyxWw57y4fRvn6JQwcE+Ue1pV+1dd624az0jfucKUAqZVPNe1vqF6hcZVzQk9iQeftTbP+qKtz2x9Ln7RGK8LDq1XAml9XvrWuFjClAKmIP1jnTCob7jI79Q1TdQu0fnnvWu13/iu1/CuT5S8a+J6Gs8Mv2iMd5APeBD9To2GBxP/nXJ/60KOb5W+XlbTfpZ7tts+BujrkfGNuk/o+RL0jDzKRvrN28QLUr9h/E6kXArc3xt6e6ias9whzxkU2RlD8IBnOnwjTcb37B3S99+3jCyKl7Mx59Hmxh5f49vxwjOKy9A8DMZlsJ5gpL9V7XiNGabtcEja0A9nbT67ZE6QXzFuvY0/jv5QLy6D/GrauAzq9Gn+nTzY1qutX6717Pu//qLxuG3tnWl90k1rWnh01NjxpnKlB74/4Hyir/uF0L+C1tM634nqSLTZrc1jv3jc9iHAF+QPmaAN4by9C2mTgDYvgdzsK7Y0xb1Z7MkH6fHhNTLJV22MRGhg133AN0in6aVG5hHBR+sf8V2uJpO0sL89/k+dftr4eOr2xwTOLnj7Ku6l+fcyH/xCMqkXdu2LVv2jbB7yzL+o/S7yqTowMSc1am1wvZ7FuFzDHY01qKNz3Ylj0+fsxQrTHm2ik9qcCJyzE/oCfT9v3YX6wm9D3/4+x87uIp+yLG56LvF18OicS+o6BoOn65TFDET4IfuMidOzRShXf6Smj4I+WfVR6Du9k+MGVD9Rnx1jwjw/JOMGprVZvbgBr/5E27gByv0gXWTYJCbhX4NvRcY26/5IkX8lMjauKHZKY67r4njRwVHjOrwYFS8epQ0MxJG+u1nnfRbFSl50cPmtCl7p5X2+5zO3vlM+0mdUJq9s/GnyPrvap4+0uZvunX2o5D14eqLRhX0aXrQjImXycgF+lMnW5g9ryuTdms/pnZ8XJT88maY1fCnTOJ8j9w10jXn7Bsp7LgiM5D1/UbFvoHna5NNHnTG1f49P0x5T2Gjn7JecdubPEI5VB44qPxbrotBWvYI+uuaxWsvE3ukVwGltjuX+5bq1TIwu5LGG170Ozpwn98o9r3+vRuay9B9dC+a+vK8y+lmbCxX0u0/w244LAX5ejUzyulUH/8hctSL8Fx387y3Bv+7et9r3feYa7ZYameS71ob7IJE15lWuar38sr1v6m3WZlAyJ4r8+m1kyArueX591siM8OtX1SRQGnGPkbI0dWDStWdtVcfK/m3kfw+mu9wYSqUvdYknYG/y1hfvxOtOr3vDdbORfw6mvPquc1amGzyzJm/frfbJdm27nnh7Ud038nbqSHbP1oS3D9k2dpH8yqvR0kaXpc+zaY0W8ohom0xtnyaxXOfxnLV5ccU68GJJXgg+r+dr02dl61D3H5VGXfN5xnYTHvJ5a/PKCh33QgEuqdPXq2v2Zc9pzSEv//RAsjMWT9tybR6reI7f9Wx2z+/PcYyPLuDZbuf4cHMf9xhgJM05pubTafwf38vfbviOladQ3s7LM5xT1uZNFeMdKRgvdfr6xpp92XPq16YPnjqC+sS1LedU1XP8flGeYbzrhZJxmKOZXRv552CaazgYKPy6Jii3GLsY6dPXd6aylGtA5zfnobX5zgoe7p3v/pufsfXdi03j3jX95XX2rr16SJTDHdLyatYfz/LK+j6U/00+YG3+l4q1pOeR5arVdp/UqXlG2okY/DZ12pMF+J0AnNbmh2vqtMxx2U1nRRpNqdMGzZ0haWv4b4+fjOlkbXqoV+fW9zJYOOYK4GQb1veyNv+8wl9h65v2rPIDjqn9e3GItF0Vtmwef/SxW98zWj4SY3RIy834wKVk8pqTv+fx3eAIzAG7uoRx6sDUw77lkO/bYFtMJt93R2MN6syju2PfOWNnfdoatLnF+Wa/NeUvXAtV8ZSB63lA/kZfwPvhCwhat5u6zyMxJuUA/dbW5pPeMG77m/Bn8r3YZ5v3w70s0lv3crz3sxBDo7WmuQoL+IyZM2ubc2ahAUyUAUshMG3lTxDfA931PYjTl9YGZX5wozFtGc4z01HKzuuif7JrH9Ux6dvGot1i3/8oX6+MkeD7qrLLMhz/AH0wXshopPG1dfYYVpLJWA3rM2g/b21JYLIxEoHTLr734yEwba3nJnkotBujbJtIfD07+bjQO6PJCbnn2bInHJqcQvuu19xJ6dvGOglctr9/ydbnCuDkmrN7ieDCNfdXWHNHHBqVnflu/XpnviuvCPRBbPLvkzF9X+U70DnBd2JtHvklkzTkxb7sOdNtrM9l0O4UaHcqBL+1TdqdDuz7TEjfWzYhfSM2RiL0tctwPJI/dxwPWT+p3aMj6iTumZPJOsucQy95w3jwMzK4/X0AfahzLJtU5/NJE8cUh7fnZEwq4zykYrsNlPHLOXzLyViILjo4UTDbvUTGojKuzsvIQJu+nbyaWEVG+QkVTEIZrDEJOrz13UUK1DjmvRbJvDeZBDfqbIxE6GuX4WhM4hAe0g2wCSZBb6IxCeuMTCKOk28tcAPYJqGNxUlCbt+19kJGQnhO4761uVFzESguJ5y+HttwQdn7sj6LFlQMw5jUUBU/j2E8oQQ/zkNa37prYsw2ftdkbaC7JrbAuWsSpA0Ovfdt4xuNqaHSO2YCjEK/jXBbSXYK+kBGt7aA8SKEm82dg0LPQ6CBtfn8irW4ILQz4WZ9LgvN7DPGA7clgJYC+44RylvCjfPQxkiEvnYZjibcTuAh6ydlY2Mqh3BvXhiNasBVpmGkGUi3MDXdB6Fdx2iXW8JX3XUGC7c8rc0HXj9ue9vRrumy8rZXd5l2vb6btOuX39WuJ/q+q10n+0+7/toOtes33uHa9Tfd1a7rXq21awokuo409r6OEkFBSaa8JM8tOc95sf5nHBiqXHlZXzaX6OPUuOBj8hytjONTwrCCe1xLVX7/Om24H0BrSOM0uX9ufZXVi6JmH5VD2bcy4sV1W5v/raUywnh7o3WTuR4dt8bcKxsjEZjsIhxV8y7QYlprGtvWxz4oeWAdmLifFrm30kSxOwOYoupPkEfWgakoj6drmJrUUuz7rKE6MBGOKp5SV27onjFz4O7BvTPox+7xrKHsCqTVgPl6Hh3mCujAmGTGp2i+8VzSrH44x1X9zaOzes4IwyNbwkD53Hmuy2Ar14W5TPaeWatKz1vsauysL56PQtrwLMkrGL+7+bb+YPZ+0mTyKlubzGVbDYFpi1/YOGn+uSg06C7W7urE2Q6Gr/19IHz8+0ezHf/a7RnjvzZj/IczHv/+GY9/dbbjb/lGZjj/Zrz+rz20z9f/aH/Pv2u3Zkz/q/t7/e37+Tdr+XtX/iT7mf5319/+fv/Xrt21f+7y3xniP2v+O+P5N3P9c9byd5/Lv2s3Zjz+w/vb/zJz/jdr+u9z/8O+l7/X9zn/u8v/Zzv+Puf/s9a/Zq7/7vP5f/8oG8/2oB983tZntr97L8brcM/5oSXB18ZIhAZ2sWa7fb8CuhDOg53BubU3X3UWRUan+2Lo9CDjfFPQwGJ4SReL/TVYsnjcp7whHsYyGtmYR/G+Hgu6xdQK3UowuDew7yshfW/FPVxKJq8668KSFw7iIesnZUdVTCZD7lGByN2X1EfO4ODhFwzI+fhAOB/VAM6PB5yPcuB8dCCcH98Azkc7MCUdwrMCeKx/Zr+xEPrrIGTSEPpsFcRexZjzgCUFfazNjyL77aty+LKgOVsjNgeX8f1RyU48uqQpA8867HfAQuRT9DvUG6TtAXznWFW/e20v45lVp112Pcppc19Bv1fkGX5nACAD8+z3b87nhhc8T7pGrPeDMl7Zer/kwJR0B89moOpBZ6zLgfg34csGB/ky4UwD4bzcAM7UgSlJuuXLl52xLgbib4oJD7T47nCev+by/HsFd/L8bwLP/37AF3RIw+04um/hrgcyXJL3wEDrt5XwMfZlz1lQOQ9E1EN1M95rAeNcAwfwN7PEmYR5EPfsO+Vr0MECV5vylQuAKab8w9YauiA0YEA8y2q0DeZv8tzBls9dbvlc/IES69ciS59kdGaigo2RCA3sOgl8o5JwIgsSZu8rc8Q8SvDRQ0MOYPyqw2jjSqBs6b8HY/reDObQg2qW8Lfha23eU8GHtZgsD5zPLvJQrhvqihvd4DZxKMzBZCfvjtT/AhPIN98ZD1qYBx4sPmBtfrninWlhYXtn1iffGdseLaHtXDJZUYVzg9VcrM2Hnjd+/v3hus3WmgqS0Zvv5zToQd2Gh5ZZm9+qeD+n8Tffj6fbWNtA/IZxRUK2aKcFhA2PU6CBtflABe1OFtCOiYZGMyYBmh5+GfdWHRrrYaMb3dBhwEQ3+qL+EGsjwtdShTuT/C7F4D4k7pcKcA+yB9eb2sMXC+jRtX590aE/ddTaY42Ga2vrw9H9D167Prh+dXDroetrD1+/efXqzRtX126NbnFON+n39tpg7eq12w8Prt5Yv3VjdONj3Y2GD9382A+Dmw/eHl5lYZ9G8Aot9EaS+Icocqyq37221O9OO+0y/f+i3J9LJvVo8hvqia3ocPP6Q/evPXxtcGvwsf9uX711fTC6Orpxa3T99vpg1P69Da4NR4MHb1x/+Nb9w/tv3njw6vrazdvX1gcPDa+uD+6/MWw9z2q8t9MOjTlW1e9eW763C047vjfKx6r3tphM8pwueX2gHdXYtuMh3VH6wxLG4QGNdo8bllV2F5+7D7BHHda3JDDZGEX0ZDGAmCLxobbGemDFw7XMHnhEstN2sTlh4xq97wEcqhOTVxi9gza+Aw+72ToMkodMcd+bh4Jam3PPn6QVL/Zlz+ka4/4gDyGKOvww0E+ySbtFoZ0eXDOPNqsVtFssoN0R0M5oxsN2gvBbC/ThrtNeVz/QAmhgbT6hgnaHCmhHP9D24fb554Fk52HZJmupA5D/HkBbLRwZ6DfblAPkQTZGInjb1UMxnuGRZNJ2NZstzT91nSvdyF/r+DtjgrS25qLui2lcA/fF7q+Yi6uCi+FLHqg0C5TXa011CPobVgNhajKfSaegeTCk36EOTNT/gg6DbBwXRpkaVKxxnXFLdWCirEoD6bQoNFhMJmVqR2Ote7JaC2gGjT2Y5di0fXiYp41FOdOkwGiafwbGV46WBCYbIxE47eLeepBMn4jZWcQn99s7Gmtz3jxKcGVM2N2xpx57XW9kc/w0xsguvnPK+yoYGad1EPdMXnFvk2uoS78RY40Jy5c+f/z9Rc8fwxHkn15vWpSvr/g7DSpfTEJiCzflzyXB1f4+EDv2YJZjU/6k+SfpTvlTBeMK7nl7HBHyp0nyAuOoImMRbRyDbTHpxP++46oT43R37KnGLpU/9n75zil/msSfcQ8yaL0MmATHOLtvgnwJ4uWbMQEpxqQ/4DJoZG3+x2vHbb81h4+5EfRFXZZ7c8nk/i9ja4z2y8nOWH/CqPB4exVXpoTBi5P24kC4/9NknzLrS+Nx6/JxG+fylDBwr46xLnbvPtyzOUm/RFD84CYPYSwK1yfH5JolvnzW2rwdOtu7nj/G35sv1g/nSxNaprgX+a4CZeWAunYR/4vStcn/3gX+ovNS46S6jJGZc3A9JfTg/PoxzK/HvGD8XJqMryY8S+MkmsqsFM+15SnWB+dpmlTjY/e8nKMIuanrInsH74HcTGPGnigUZnJTeQBl6a9Abv5CPHwDr3B6Nvb74nWK9aY6xVtAm3+HNW+/U6doY/9QdlPW2fdV3CuTf5T7J+XeXLIzHvKkA4fxEcb5B8nSUeB+6aaNx8M2bIxEaJCAZoZv5BnqUfhmPqfs4BDNnzkhuPJdauy3/e3x/xT92hzhHD8lfZ1y+rJ7zHc8LXBSJ+bcbaITH8U9WzuXcM/WTg/xm41jsCiXIuOYmvg/GMcUtTa4Xun/4BruaKxNHb7qIJ47cWxPTyfdqa/XOajI7tmcCJyzE/oCTydOXjAee7foCy+DvjCfw0d9gXlRbezsIn1BbcO2ujp1jwsOXHMlcEXqIpQzBoPKmbo+HOvT5ANlHd+PzTXSr8naoNzROGa+f9Kmib+ch4YaLkW6W5c2KOUoxwvKDZpY/zZGtr6uYP1H5YXwnej6v+i8p8dj/X881n+kDzLa/+fZHtH+gT1s+6/X1T3pk4m2KSN9coH7D+vk++rLYE6ltXliTs+imEC1VdL8O+e68tfo/WrVJzI8n7wLdZtD4G2fN2Pe1mbvjHyMeaD2nX4Ve/fcV4g8GFz9LHqoPG32Q8mk7sF9BWvzvJJ1QFmdJN3ygaD4y825yvoE1BtXgL+1uVmCPwtWXgG8ejB9mv92AHSLOZh+sK4H02+/64Xx2FG5GaSt4W/jk8bWpkzv9PZL5hzYjwhtqU/Y2F3oExxX5Z+3l+XpHDY2eU2T/DT6moJkcOM47qJDY2fp/2L8T+Qhz03yvJkXGbX+muYFxNcd2vITHmkAE+OkIv2Euq6D4oVGdfjMnRgnRR7IHLppY5XoJ4zaU1oSmGyMROC0i76L+2JgGtIHZrAtJpM+sI7GGswl1b61u2NPNbYb26c2Bd855X0VjCu4Rz+L5kkH+vYmYntZj+cfvWD8/W2wTSPlj+mWCcZIhIZ2Uf6kMTBNyB+D7a786XZsyh+jcRfyJ80/d6v8CfKd35U/d9bYvckf+j6j4mnp+6SseQ/kSxoz9mZs+SrGpO8zBY2szf/vK8dtf8HxfdI3mcq9OnsUy8nOvH3CqPB4PosrU8LAfZJVwGX3uDeqMaeeb133Z+lrJb+rw8c1frEtDIxFog9Y45q4T0y/RJBtOxEbYv5HG59jcs0SXz5rbT4Ine2PXjDG35sv1g/nSxNaruJe5LuK3Gemrl3E//rQtf8I/EXnpe5DdAjPjn0IzkmvBud/w/x67QvHz7XlWW1iRSizVvFcW55ifXCe1sHH7nGeRuZk6brI3sHcC8djr8aM7caWKw+gLH0q5ObBePgmdArK9wWMnQbSpolOcQS0Wcrhox7QxX5nmn/39ju5x1om/yj3j8o97ksaHEcdOLx4wSBZOgqslzVq6hdfwGdUbZpIfC22/KTgc0Rw5btcSSZpYX97/J82vs0RzvEm8XYp7l0UOKkTc+6m0n/q9M9+7VPPFKEsp+4QJAPWKAMSjJEIPonAGVnDsKn/g/tYkXWbjggNFpPJNdzRWJs6vJ6DoPvcd+LYnp5OulNfr4JxBfd6qEs5oS/wzIjH7kJ94b+8etx2w9EXjM5ch03s7CJ9QW3DaeK6y/Kl50rgitRFKGcMBpUzdX041qeX58T3Y3ON9GuyNih3DH+eY6A1IuraRHbvBO5pbpXqbl3aoF4c0CxyS16A9R/kb1jnO9H179UK+Cms/wex/iN9kNH+P8/2iPYP7GHbf72u7kmfTLRNGemTC9x/WCffV1/GSdDA2nxtTs+i2HK1VVQuc/5zLz+NwW9YlGf/pl2o27wRvO2bKuZtG181563He7y8ryY5kdRRTuCe5pB5OkKk/UO9wvpmjrTdt9heiy2333hml7X5zpJ1sCD3N7rBY9B3DXTapoa/tfneEvwZW04f526KLd9+14gtD6pRPCRtDX8bn3aenjNHOcd2to6oDyrsXo1b8g/7nDaum+OqjPL0EK0DxZht8pqqMy6ID+XU4fz7v8jn52adIsfnnl0b+edgyqvI3/4PX7n1nXx3GXhflHtzSb3cRJsTfN76eCT6Py/36rxbL496GX0cxz37fgz37PsZ3LPvZ3HPvp/LPxnvnl0b+edgyotjHAQs3EsMqlM14Dyez/s2WOgfjdkDWH+Q9kKCMXjRF9mDrTmkz8JgWxQaHOhsvKvrdfwhcePfP5rt+Nduzxj/tRnjP5zx+PfPePyrsx1/66z7Gc6/Ga//aw/t8/U/2t/z79qtGdP/6v5ef/t+/s1a/t6VP8l+pv/d9be/3/+1a3ftn7v8d4b4z5r/znj+zVz/nLX83efy79qNGY//8P72v8yc/82a/vvc/7Dv5e/1fc7/7vL/2Y6/z/n/rPWvmeu/+3z+3z9i7MQzHtj6jMslWH9oSfC1MRKhgV3MTbLvR0EXwrkZ898JnPVyReJi0rb25i1GijHrFv9EuljclMGSxbg85Q3xMJbRiLFx9r4eC7qdC4FpbRA3d7f6PhrS91bcQ5PalEfwmc2PM3jI+knZURWTCTx8ZxM5JjzaGEXIGRwreI4BOVGBeAz8qwPnIuBccuAMCsbchHOxAZwLDkxJh/CsAB6OdTgG/wETEWyMzcO9HxiPHRNsP9wUDOcxphfEzsC5ZyNo+6UPbH1fTiYTOeyefedhW2QKG53gsJUMHVXcuoMCTkO9kSSTAZ4a2Fnnd68tA+DPOe2ya8lps1LQ73l5ht8ZXMiAVPv99Q9sfapylF0LeDaClzQJAjzjwJR0B8+AyUgcK7L4WxOez8LeSw6cpwPhbJLMftqBKUm65fmnnLEiA0ONzzIh6ZsfGI8ds0a2jHQGCZPnnwHtrc3fAM//nx4Ywxckk27H0X3SQaEJYCyoZW3e8sDWp8fHPD00zb8z4cjmE3VUPeDCaJrOAO/UwfutD0zCXIX3ck289YAibXsS92goZlegwXK1Kd88CpiWY2CaCB6nDXFUaFjHHuJzl1s+1/QwUbt3seVzloQRmDRwLdCuWWNSdoIxEqFBAjztM0ruBOJ7NTPeM7tpSfCxd5fmnwcwflWSZeBhFYNA/WYzEIYF/uaTnTyfSWM/8cAkrXixL3suzb+zoJcWhQjSlQaJ4KY8PdBW3py/h2L6XjOnq+E1DzwOgfbW5mcf2PosemcH8TffmfXJd8a2B0toO5dMJsnpPLOxrM3vPDD+7Rfy79EHw0WuqaKD4bimrM0vP7D1WfR+6hwM5xUHjbKJAgsfrHn6n5dQam1+44Fy2hXpvadBO6MZdRizM3jYkpckGFTwdNPXZjYO7a4PPjAeO03GV5fjGu6pg3sK3C/H4D4k7pcLcA+a2+tND2GiLAniVRObFCzM0MqXOBqura0PR/c/eO364PrVwa2Hrq89fP3m1as3b1xduzW61daXeHttsHb12u2HB1dvrN+6Mbrxse5Gw4dufuyHwc0Hbw+vcq00gldooTeSZNKfqDZynd+9tkySP+G0Y6I7eUBVgnxrOty8/tD9aw9fG9wafOy/21dvXR+Mro5u3Bpdv70+GLV/b4Nrw9HgwRvXH751//D+mzcevLq+dvP2tfXBQ8Or64P7b3Tls3bf2wmHxhyr6nevLd/bKaedV/SszntbTCZ5Tpe8PlKeNt3g7Pvgj9N4L3aPB+w1KaLFooxBvo71pn77ZcAUaStH4Ru4P72W2eGPSCZtw+zSgihG73sARx17PKhw0SBwL3wzMcL8Eab/Gh6LwNfarNzc+izSfxeETrpWuCdKv07UXn+gze0WSzI8DoMG1uZUBe0OFdBuEbQzmh0C7YLwW1tIxrZzBO3mhXbc4zcaWJuLFbSbL6AdfQr0VWTXAbSj72QumdQByH8PoK3aYhm97hGYNvK/B9Nd6yzGRrwTwdsugyNQ1g8zfkr7zWw2r7hO4tCNtKqSuyzaFDEXNdbD+NUqYLI2f6NiLmpxJRaQzS7ORU/3sHl/Vp5bkPZd2sCUcXOCh1cA8k9vbX1m9Fq/OYYv8gBlexekNS/Of9qtkQdNN7HdedB05KHOTQ6a5hqNCdZsfqgzi4FF+l3ONYCJfpfIGJ3TQgPagUnSLc9rYoN2OPZglmOzSLHRmHSnjGlSfJCxQZGHau4F2/ruwZZ7dmz3UE3dn+U7p7zfZYdqDr0DASL3ULyirJsF6m+Ovz8EXSmqmD73MxKMkcj7SZx30Udco8G2mITEJ697e5haBDto7MEsx6ZsMxqT7pRtTQ6c7CHuc9Q07rXoAPiu56zuAywmnewr7bjq+Bjvjj3V2KWyjYWobSzKtiaHrxXJmi59wrRfKGu+DvIlMt7kDMZkTDTjTazNSx4at/3GHL5lPGN8qa0ezuLSxPmMPHdGnou2BRi/y7iONroT40bI7+rw8Uj9jfHILBSuB0fEJWwOJmK4zXdm43NMrlniy2etzQ9AZ/uRm2P8vfniHbrbhJZncG+P6tqD3aJr/wj4i85LjZeO9p9qfDjn17swv649OH6uLc+yfjkHm8gs+rTa8hSNoaqLj93jPI06RInriTGT/wpyM8i/t2mXaH6R8gDK0sdAbv5cPHwTOgXl+8/H6xTrTXWKv35w3PYXsebtd+oUbewfyu6yQ5Kq5B/l/hG5N5dUF5/gIUk8iCdIloYfGN2kPgDjA6JyiSLxtQOjTwg+K4Ir3+VyMkkL+9vj/7TxbY5wjjfJKWJcFA/stP5Vj22qEy/jnh7+Q1neg896rWlMFeVSUIzPelP/Rw+xZxP1POj/4BruaKxNHb7qsPQ7cWxPTyfdqa/XOUyeMQbZFRmXRn3Bxsjk8V/uQn3hP0Bf+GtHX2BObRs7u0hfUNuwra5O3eOEA9dcCVyRugjljMGgcqauD8f6NPlAWcf3o7E5TdcG5Y7hfwL92++kTRN/+VHcM1yKdLcubVDKUY4XlBs+sf6ZQ3XxwfHYkQfWas6b1nbhe3oH1v9q/j3aBxnt//Nsj2j/wB62/dfr6p70yUTblJE+ucD9h4mC+urL8OqFPC6nZ928SZXLXt5k9H616hMZnk98MHzsxrrNV4C3PWnGvK3N3lmbA6O5rzDrA6NN1y47MNrafGHJOliQ+xvd4NF7/ojRzMsfeV4J/iyGylhUPTBa5Uj2c18HRm+/64Xx2FH1NElbw9/GZwFWrSfi6Z1FB0Yr7KyDZ88Zr+ChxdYX+UiTA6M5bp0Doz2dw8Ymr1lNJmFYLcGHNkWaf6dO+We3tr6T/3mHUyuPpi/f2rwGPPrtFbpFm/3EqlpR5NFt6h2RHx/FPeXHtOO47xblo6LtZ32fAyx2f/ug92RyHZ0DztbmTSU8ahnt+M4W5J63du1v0rTHeqpuvprh7+WrfWuFzlZ0mD3p7+WrBdWp2cTvsOC3IuPPo81basoi7repLPLy7fuSRTZ3+pJFRjfDn3WR7fMw6GD3bE0sgrZt1gtlHeu+GR8jP7ffyeOWpH9P1tk95mwZb6N8VT8L+XqkXeLZ1WobUF4cSoplk7X5xxXrwNsTfiJkmNrC0/g4y+yACP+l53dkjWbKsKC1tcm3bG0oX14CPtbmX1bw5UWhg7038mWTf5Q/QfugLl9mjpfBaW1+piZfpp9I+bKXP7rf+DL3ZpgHbTBF5QR5+qrWsvLsZs9/a21+uWROFMkYe3bVGVP7pwygnWP3vH2CaWVMXXuN+/BKI/rb+9jP0r2RLu2JyLgW2gnKg44ATmvznyp4rO43GV3IY9VXFBk/QPmn+DHexNp8eI/rvjZ3yGMj+ZnqFjY+aawHF0XrgbrGPD3Q3p/yWPomrc2fV/BY1c2473PSGVP7L9v3KdpL/Etnr556ZkRsX7Q/m3qm4Uof9xEHjmUHjipZRj2Wcj9IFxk11WOP5vGtdfVYo0uZHkucOU8W5Z7Xv/3txSRQT460A9SX7tHP2pyvoJ/a00YX0k/9T0kyyes8OyFIho3K8F9x8L9Sgv8utBNGdeyESD+pzgfPTrA2jB+ZtZ1gsJTZCdbm00rmRFHsrD276oyp/VOG2T0vdpZ2SETsLP1TJjtYT9izE34estR+536G7jnbs0X1WLJ/G/nfg+muzblwTvrWfDq++8cjN+Khh3biRd6/W/e8NZ6vro5AOym7NvLPwZRX3z4u2qhGJ2vzjJq8fbfuE2/vO/TE21WX0fjhFbShj2EV3w121bOb6vTkV96+bRtdln4Zxm7V4YfkEZH1m8jDDA/N7yLvOZT4fJb86EUV60Cf1Vy2u3V+x/eOYdwm+bPcu4yiJ2VGWTyrtXlNhe6v8kfrilG+efKH8rNNbhFtYMYf16H7qsDVRX4TYyLUX0l+TZ5UFVNO+5A2UR3d0cY5OiUMjGvnnlbV/lXXutuy9E3fucLE2L3IuDTqFaTdokPfA8mkHOKz1uZ3oHO+BTrnaYfWK4G0PiV921ienkpaB+kf64RBfcNFfqeuaaJ2ic4/711rfSO+65/Eu/6+kndNXH8Az/xL6BtBPuBB9Ds1Guq5OMvA3dq8vaa+ztjD3bRna3OB+npkXLHuE+pc5D4hcy9M/tFvPm39EcbvRMqlwP29YVGuVVC9j0GRnfEvwQN+2+EbtOvtHdL337eMVH+rykj6W392j6/x3RK7zfVmbVg/NurcDo8veGcKMWaSbWiHWJt/V9PfSr1q2vpaXlwG+dW0cRnU6bWmEdc9Y8V/G+v+qbfG47a1d6at2Ug7ta09Mm3dqR74/oDzifEP/xn6V585qN5asTbvvTVu+4eAL7LWke5zZ2P/111Im28Gbf4b5GZfsaWz3pMP0uM36/kEneEyIq9NMEYiNLDrIPCNPO8nCl+r53NE8FkSXPkuq2IMinR6jWFoqnNTXnHO2ue0vJ2x/3V88IF6zRr9gwnGSASfROCM3O8in6oD0xJgilobXK8GG88lT7oba1BH57oTx6bP2YsVpj3aRCftIf5oQl+g7+e+W+Oxd4u+8DD0hU/Iv9POpr7QNp+yLG56LvF18OicS+o6BoOn65TFDET4IfuMGzgCuhrtrM31W5P04kUfBX2y6qPQd7of4wZoA1sbzw8ZHTfAGJFp4wYo96N8LE1iEp4KvhUZ26z7I0X+FRsn4uyIotipNrW2SC/iqHEd3lzz4lGmrfdF392s8z639zGkzRkHl4cqeKWX92nnC1A+0mdUJq9s/GnyPrvap4+0uZvunb2y5D14eqLRhX2SDxt+kTJ5uQA/ymRr89qaMnm35nNuxx9DJkf66FWmeXHGupcQqJsPvTWmurnHe04LjOQ9X1cyJ2hDUddTftOUT9MeU9ho5+yXnHbmzxCORQeOOrkynq26gD665rGaU85zqgxOa/M9FTxWc6iNLuSxerY3ceY8OSz3vP7tb9JvWfqPzsk3/2UZ/azN2yvod1DwM7qQfnq+t923a9HBPzJXrQj/JQf/d9SUYWV732rf95lrZDSlDIvyM3rzwcYn37U23AeJlKvqb/H2vrUmgbXxavn9RIUM8/z609Yk8Pz6h9F/hF+/qiaB0oh7jJSlFx2YdO2xLmrQ2UFuDKWe3UZd4n3wNX5kn+kItJOyayP/HEx5Rcu2JrrBb+9x+8TkVV+8XXUZlfUryc56M+SH3j5kE998Eb/yarS00WXp82xao4U8ItomU9vHs8m262QkPp8lP/qTinXgxZJYnE32e4qx7Pc/Ay0uxtBic7/vMvDJ/p3N/2Yc5XmM37U8OSt921iEy9r89IvG9PmrePps7o8bHAnG4DWP70U06xqmiw1gojw6FwPT5v74+QYwMS/6bCBM5xrAdBYwRdUnX8I4dWCi7I3KvSR/MtgWk8m40o7GGs0l1fGqQWMPZjk2ZazRmHRvW9+A+ydB8nK0JDDZGInAades8lUXk0n9p6OxBnX0qrtjTzW2e764yTj6lmwszx4ugpE6bw9nh0ycJcS1EGSTb9LKO8/8bzw8/v4pD4/hiDojhnEMCcZI5P0kzruIPItE95oXk0n9v6OxRnX2VILGHsxybMo2L/6hbWwAdZ8g3+ZoSWCyMRKB0y7GwUTxD/rCDLbFZNIX1tFYgzo+trtjTzV2qWyjf1vzKerAuJLs9L8GrpcB7RfKmqdBvgTx8jXG8Zhv0mDxznYafem47bNy+DKfWpr/Tt9wmzPYljE+bbOz8txZeY78Mp0SBsYAngVceuYK+Rzn17QxcfacZ6PYOGemhKEoJs6rG6xn+mXz8TjG6tp3xvPaqHtyTOqjxJfPWpuXQmd73cNj/L35Mq18PYt7ke8qMk/PyylV2Ryla3Mf7nXgLzovo/fjFFfVHTi/vhrzK7k9fq4tz5p2z5S+v7Y8Rf3VdfFR2REouwZcTzz76pshN4P8oJt7einG5Lo9Cxptt4Hc/J/i4Rtw/+Ms4Hwzxg7yfa7PyZikA+N+rc0v3B63/YdY8/Y7dYo2vr2q2pmMPyuTf5T7x+XeHO4ZHMcdOIyP2G+BsnQUGVOc0eBYMnmV2XiMqQk6/3kYia/l2p4UfI4JrnyXderBef7rNvVbabMwL+aiwEmd2Ku1a/2X6cTeuVPca9eayZH2S1NfA+XSsRiY1pv69o8Bpqi1wfVK3z7XcEdjberwxwRX+/vAHTy2p6eT7tTXq2BcwT3mrAfN2Ql9wcbI5PF7dqG+8DboC7/g6Av0/7Sxs4v0Be88jja6OnWPkw5ccyVwReoilDMGg8qZuj4c65PxSEYjvh+ba6Rfk7VBuaO1kfj+vXNyrf+yvWAvZ7JId+vSBqUc5XiRPshUcM7W14d62OPiO9H1f8p5T6/F+v8vPfkgo/1/nu0R7R/Yw7b/el3dkz6ZaJsy0icXXetCa31rrQnKgsWcnnVrfatc5vzn3l9kLFaa98W9juXb4WM31m0eC952DPPWnumTt7WJC/HqlFBvoV/F3j33FYL02yF1ItVtOKbNaYtPtt+4r7Bd+71kHVBWJ0m3fGAlhkZuHrXRjDmz1ubjS/BnnkIKeDVPQeVIn3kK2+8aeQpR9YBJW8PfxieNtTaIp3d6+yVzDux919Wk7mMweHtZns5hY5PXXBYYLpfgQ5tiNf9OnfJJr9j6Tv7HWHLdA0/zv+nLtzYb4NGvqNAtuqon4uWttY1vqMrvoj/c5hz33aJ8VLT9rO80/5tj6vlr9lsKnK3N00t4FHPO9tjZlm4dqhQ4GJzW5gsrdLaisy1T4GR4MZ++j/MyDL9jMv482jy/pizifttuP58rUhYZ3Qx/G99ozFp/Xh0sr85W2xgbr741+bnmhZIHWP9l5yF6tbIpX9XPQr4eaZd4dnWaf+eYWsfE2lA2WZuvrFgH+iztoKKaWG19nGV2QIT/0vM7ZvdsTlOGBa2tibNnlC9757q/qYIvrwgd7L2lwI/7cYZf0D6oy5cJi8Fpbb6lJl/eS/UPZ8GX0/yTfJn7QlE5QbSJDSaDxdtTUR7FOhXW5jtL5kSRjJk2p6vsDIUuZExde4378Gn+nXUqPtTjfpbujXRpT0TGtdBOUB50HHBam39awWN1v8nokgI/9RVFxg9Q/il+jDexNv9ij+u+2+dagsdG1q1U3cLGT/PPFbTpwz/trTGDxYuBVx5L36S1+dkKHqu6Gfd9Tjljav9l+z5Fe4nvmUFsX7Q/m3qm4Uof93EHjqMOHHVqb3vxIEG6yKipHvvbDfVYo0sK/FSPJc5d1FxVX3a0HaC+9DT/m/SzNv9XBf3U/2R0SYGf+p+SZJLXeXZCkAwbleF/zMH/w3vLThjVsRMi/aQ6Hzw7wdowfiTSTlC5arDUsROot1mbP69pJ0TUfqCd4Pm6uoydpX9Kc84pS6kTvtmJe+F+hu452zuwtqrPZP828r8H012bcyGVvjWfju/+EciN+JQv3YnXXtjz1ni+ujoC7aTs2sg/B1Neffu4bH55usG5/J3u1X1ik1d98XbVZTR+eAVtqNPYmqCPQfXspjq9V2+O+7ZtdNkV3GPsVh1+SB4RWeeKPMzw0Pwu8p5Dic9nyY/WKtaBPqu5bEHxX2t7pRYRYw68XGCDsyxWIQXsUfSkPa859V483UbJvGBf9pzWFaMsq6rX2ibemrKM9kIduns1MKeN+aaMtXuU4W18uV5N2rq8zMuxmtaffBRw2T3qDNzf6Vp3W5G+l4UuhImxe5GxDtxbIu2WHPoeSCZ9AnzW2rwdOufzoXOedmh9JJDWWvdZz9bw8lSjYwCPCK3Jf238yPl3WvrW+ee9a8274rv+erzrF5W8a+L6UjzzJugbUbnsfcd16julL+YVNfX1srMFZll/ejteYkZxnToX6Yuhf8GLXewqFjNaLkXaQLQFinIfO+Q5A29/lus++/6DDt+oqhvQt4xsci7lt+7xNe75W4NiXlqfSxloY7jn73k5pUX11pl7Ym3eWjInouIyGFvo8Sv7nfyqKhaX/Nbzt5IHe/liP4h1f+pF43Hb2jvT1pTi+2xrj0xb47UHvj9x3jNjYt4F/SsyB45zwFtPfE/f9qJx23cDvqj8Py/2Jxv7J3YhbZ4N2vwU5KaXP9+m1kmT/AWN/aSdT5/Bitzz/LDenrJ3jmeQHr9Zz+dwUN/ktQnGSIQGdvVwJtowEl+r53NU8FkWXPkul5JJWtjfVflIbc5IKopf59lI1v+0vH0J98ri4xn7FlSHYK1pXSnGZ0XFPJNP1YGph/yfIdfrdl52MrmGOxprUEfnuhPHps+Z+pyNRXu0iU5qcyJwzk7oC/T9fGQX6gufBn3hjx07OyIXRX2vng5elK+iew5191C8fPOqejtF+StROnjfuSPc5zDabcvVfF7s1dwR75zuIN3QzR1Rnx1zRzw/JP1F0+b0reDTy7doo28z7oFyP+qM1rr6EP0E3IvtIg+8LN/D8PX8K5FnRxTFV7ethXTGwVFj7b255p1lM219bfruInMQdC1pDD3hPiRtzji4fEoFr9Rneb4A5SN9RmXyysZvaptH7NNH2txN984eU/IePD3R6MK1xX12wy9SJq8U4EeZbG0eX1Mmcy3vpn0Dr+ZL5BnfKtO8uDfdS4jeN9A15u0bKO/RPErynqeVzAnaUKw5o/ymKZ+mPaaw0c7p0+8YkeNDfke/psYEMf+DcCw5cFT5sVjrg7ZqUK2PTR6bL8cdPIi1PqzN7QoeuyD4GV3I14iX4sx5siD3vP7tb9JvRfoPpF/p+eKkn7V5RQX99DxtowvpZ3ixLXndkoN/kAwbleG/7OD/2poyrGzvW+37PnONjKaUYVF+Rm8+2PiUYYfx3WCKrOWnctVg8XRVlWHU26zN11XIMM+vP22dfs+vv4D+I/z69AWY7KDdrzTiHiNl6XkHJl17rP8feVaPxlAqfalLfDt8jT/2op143ck6Au2k7NrIPwdTXtGyrYlu8IN73D4xedUXb1ddRmX9CtrQp2drwtuHbBu7SH5la4J6fhtdlj5P1jarww/JI6JtMrV9msRysUa6tfnfK9aBF0vCOJvzaL/RDZ6DrI+LGM/ex3nAb78/8RXjdj/7op1wRew7X0wmr7I9XsZ0nguE6XwDmMjno/LiljBOHZjOAqbI+t5nG8BEH2/UmQbcQ6kDUw9nJfV5bvd6HX/OnXpud/S5n3fP7b57dvYeHds9t1vPmuU7p7xvY1tH7w9rfrrGZnRo6w68vPzNmBnYtH8Sr682Pt9uVvnii8mk/dHRWOt17JqgsQezHLtoz31aPxV1n6C4ptGSwGRjJAKnXcx3iOIf9AEZbIvJpM3W0ViDOr6lu2NPNXapbKOPQ311dWBkzZQiWdPh3BzQfqGsOfHi8dhBvHyNMU7m89MYIfo/fvxl47ZncvhYP4o+1zbnATJGibZZnXg4GyedEgbmzLGGleaiks95Pnrrv2mMrD3n2Sh6DttSSxg8mUB/OuudeHW0otZC1h9rFlL35JjUR4kvn7U2w3yeZnP2M188xt+bL9PKV8ZkRr6rQJ1zIke7SLeP0rVZy+czwV90XgbmqE/UCLa+tR4O59dnYX6998Xj59ryrDZ1wWmPeedZ2HN1eYr14Z3bVIaPyo5A2TXgeqJv/RmQm5FnDaYYk+uWMaPW5pshN58dD9/EGbOMQ/1CjB11XuhcUnzGF2vGWJungTZfgjXf9xmwVfKPcr+NXuntJ0faYZFxZBkNGNtoYyRCA7t4jlVUXkYkvpbDekLwOSK48l1q3IyXY+H5r9vkPDH206vz6MWdcO420Ym5N601HSjLe/BFrVEGJBgjEXwSgXMhiavZSj5VB6YeYuuHXK/07XMNdzTWpg5flVtwJ47t6emkO/X1JjnpjPMLmrMT+gJjMr5lF+oLnwh94e85+gL9P23s7CJ9wctPbXuGj8bWa2xdEVyRugjljMGgcqauD8f6NPlQlJs4bY00yh3NH+T7J22a7AUzjslwKdLdurRBvf2nwDjfifXPXMt3YP33mcNusHhxpR/98nHbH+3JBxnt//Nsj2j/wB62/dfr6p70yUTblJE+ucC9sXXyffVl8Lwra/MrOT3rnvGmctnLgY2OxUrzvrjX8f5dqNv8DHjbb86Yt7WJC6mKyadfpcezYifO1lTdhmOarm1xv/Yb9xWszYdK1gFldZJ0yweWYmjk1jVlHqnhb20+XIJ/1r7OWSO77RzwWdQ1ZVy8tSnTO739kjkHdq8uknfOkvVFPtLk3BKOq/LP28vydA7r47yDT1KCj92jrymIlzf2NTGONDKWvkl8GGPpo+b6UtIslp61FyL9X8sNYKLPJSi+f508qA5M3Pu8GEgn2h/ZtZhM8oOOxhrV4TNBYw9mOTb9hB4fJg9twoeZ1xoZ29ck/6Pv2D6D7W583Z4d243t03OY+M4p79vE9nn7ZNGx5VozPdO3P/Ul4++f9pIxHJHyp0keHuVPUB7e0NNH78qfbsem/KE/YVr5Qzs+Mm+qifzp40x5+koof+7mLu3JsWvLH60n19YPH7heJvZ1GFv5DMiXqJzqrD/moNP3yXPArM21Lxu3fXYOH32f3DfU+NS5ZDJXeh5/0zd5UcYnjAqPF3+bTgkD/TmsL2/3vH2YJnHwWV9af7IuH9cz2trCwL0g79zMZXzq/mw2H3neaJdrgevT/I82PsfkXg/x5bPW5suhs73hJWP8vfmi+yBNaUnfXeS7ioxLpa5dVBsgStfmHvMbwF90Xs6qhpJXa/ZvYX4deOn4ubY8q23eibdH2panaF5jXXzsHudpkG00kZNlY2Tv4O9Cbgb54NzYcuUBlKWHITe/LR6+CZ2C8v0t8TrFelOd4hdfOm77HVjzXixSG/uHspuyzr6zRliZ/KPcPy735nDP4DjuwGF8xH4LlKWjwH3IEWOgE4yRCA0S0MzwjTonMxJfiy0/JfgcE1z5Luv4ucriFb1aV9ZXmc3CeD6tA0mdmHO3iU7snSHI/QhbO9QdgmTAGmVAgjESwScROAPj9Nab+j8YXxO1Nrhe6f+IiH/w4os0RvVOHNvT00l36utNckVmGVv687tQX3g79IVfdPQF5um0sbOL9IUuY9et31MOXHMlcEXqIpQzBoPKmbo+HOvT5IOXf821Qfo1WRuUOxrryfdP2jTxl3v7T0W6W5c2KOUox+vbB/mfsf4j83Rpv3H9n3He0+ux/v+wJx9ktP/Psz2i/QN72PZfr6t70icTbVNG+uQi4/TJ98vqy1ibR+T0LIotV1tF5TLnP/f+Iver07yvc8DzyEvDx26s23wmeNsJzFt7pk/eprpGXd1G586yfLdPjV0P1G+H1IlUt+GY2+chJZO6B/cVrM29JeuAsjpJuuUDQfGX7nmURrMV4G9tPqEE/7qx5SpH+owt986+isxtMLoZ/jY+aWxtyvROb79kzoHdy8k0XuGdPdVWn+C4dc4p9HQOrVU5l7Sr6ZT1ZfX2qVN+dl4/nfyP8d6UC+TR9OVbmyeAR39FhW7RZj+R/NjTD8mj28Q3eLnNHj+mHcd9tygfFW0/6zvN/+aY2+fIJpPrKAXO1uaZJTyKZ4LwnS3JPW/t2t+kKeOEs6vvc0DS/G/vHJAvqtDZFgQ/o0sK/IiXfS4E4qd5Tsdk/Hm0eWFNWcT9NpVFqivNOs8pUhYV5Tkxp2kR9LN7Xkx8m/VCWccaGlrTkfUHyOO6qj/g+VnI1yPtEs+uTvPvHNNocSgplk3W5rUV60CfpR1Eu6wLH2eZHRDhv/T8jsxhpQyLqiuU9WdrQ/ky61BZm2+o4MsrQgetNcA6HsyH6jP/1GDx8k+/tSZfpp9ot+efzoIvp/kn+TL3haLOt/H0VYOFY6rdbG3ov7U2by2ZE0UyRuuCzyXN8kg8GePVf2orY+raa9yHT/Pv9FX+5x73s3RvpEt7IjKuhXaC8qDjgNPavLOCx+p+k9ElBX7qK4qMH6D8U/wYb2JtfmyP677bZ2uDx0byM9UtbPw0/1xBmz78094aM1i8GHjlsfRNWpv3VPBY1c2473PGGVP7L9v3KdpL/PkZxPZF+7OpZ9KXYp/HHTja5EQW1aUN0kVGTfXY322oxxpdUuCneixx5jxZkXte//a3F5PQQ61G15ee5n+TftbmQxX0U3va6JICP/U/Jckkr/PshCAZNirD/5iD/0f2lp0wqmMnRPpJdT54doK1YfzIrO0Eg6XMTrA2f1nTTmDsrD170hlT+6cMs3te7CzXVUTsLP1TJjtYHzPNv9NOeIsT98L9DN1ztmetreoz2b+N/O/BdNfmXEilb82n47t/5JeNYf20L9uJ117Y89Z4vro6Au2k7NrIPwdTXn37uGx+ebrBhfyd7tV9YpNXffF21WU0fngFbajT6Pk61Om5Xpro9ORX3r7ttPU9GLtVhx+SR0TWWCIPMzw0v4u851Di81nyo1HFOtBnNZctKLZsjXw1wRiJ4G9XD3kdQ9KDMtnu0bfUtu5tFD1pz5fFs1qbJ5TMC/Zlzxk90vyT8s3bz6f8bBNvTRuY9kIdumud0S5ivhkToedptPXl0v6k3KzDy7wcq2n9yUcB1xF8zy7d3+lad1uRvnWfljAxdi8y1oF7S6TdokPfA8mkT4DPWpsfhs75Quic1A8NryOBtD4rfdtYnp5KWkfGAB4RWpP/2viR80/tEp1/3rvW+kZ819+Id/2SkndNXL8cz3wD9I0gH3DvcZ36TumL+Yqa+jpzUXbTnq3NhVnFdepcpC+GuRd6lkDbeEHqN94+Z4RcirSBaAsU5T52yHMG3v4s1332/YccvkG7nnsP9tm3jNR4QJWR82jz9/b4Gvf8rUExL0PS1vC38bnerA1rvEbVU/X4gs1LjqmxshpXzHnyPSVzoiguY9r6Wowt9PiV/U5+1SS20PO30o9i65Wx4j+EdX/my8fjtrV3pq3ZSDu1rT0ybd2pHvj+gPOJNVf/OfSvPnNQvbVibf4+zgD5ccAXWetI97mzsX9yF9LmOaDNv4Lc9GJL29Q6oT+iKn9BYz9p59NnsCL3PD+st6fsnf8XpMdv1vM5FNQ3eW2CMRKhgV2HgG+QTjOMxNfq+RwVfJYEV75Ljc20vz3+T51+2rMlKa84Z+1zWt6+iHtl8fGMfQvSa9boH0wwRiL4JAJnZMwz+VQdmHrI/xlyvfK8Y67hjsYa1NG57sSx6XOmPmdj0R5topPynO2gOTuhL9D38193ob4whL7w3xw7u4t8yrK46bnE18GLci51z6HuHoqXb15Vb6cofyVKB+87d6Ts7LL5fF5U+Sjok1Ufhb7TPn0U27Y3fBRBuqGbO6I+O+aOeH5Inj8/bdzACj69nL42+jbjHij3o3wsdfUh+gmiY5t1f6TIvxJ5dkRR7FSbWlukF3HUuA5vrnnxKNPW+6LvbtZ5n9v7GNLmooPLp1XwSn2W5wtQPtJnVCavbPymtnnEPn2kzd107+wzSt6DpydqzVb6FGhHRMrklQL8KJOtzWfVlMm7NZ/Tq/kS6aNXmWbjcw7pXkKgbj701pjq5h7vOScwkvc8o2RO0Iairqf8pimfpj2msNHO6dPvGJHjQ35Hv6bGBDH/g3AsOnBU+bFY64O26gL66JrHHs77Uh7EWh/W5kUVPPaw4Gd0IY81vA47OHOeHJZ7Xv/2N+m3Iv1H10ox/2UZ/azNV1TQ75DgZ3Qh/QwvtiWvW3TwD5JhozL8lxz8X19ThpXtfat932eu0TbtIcOi/IzefLDxKcMO4bvBFClX1d/i7X1vxwhIG++c+K+vkGGeX79NHiLlvefXP4z+I/z69AWY7KC+qTTiHiNl6XkHJl17rIsaeVaPxlB6Z/VYm++Er/EnvnwnXneyjkA7Kbs28s/BlFe0bGuiG/zQHrdPTF71xdtVl1FZv4I29OlxndjntLGL5Fe2Jqjnt9Fl6fNkbbM6/JA8ItomU9vHs8mMFirPzuI5a/PTFevAiyX55+DzmnuTjX8abemPIp+1Nu8Bn/3TL9/ZL/2S6qucS6prfy5jrJO4Z9/Po/9jcq/tfg15L3VhzWWL9vNrLHOa/80xbS7bXNH88Hm0eX/JXFlGO74z3UfYhXalKztSjGtwWpvfaWhXGl1S4OfZPYcD8SuK+T0MOK3NB2vKRvIclY225naLbFyOoa0b86t5KIz5peziOrFPe4brpUkM0DLuGR+jDLbfyeOWpf9lp3/Nr2VsLuWl8TbGZf4pZCNlctfvoaiuhFcruqyuhLX5i5p7JbRr3v/ire/M6/fObOP7rWMraLywF8dIW4Hvd1pbwdtzoAwLWlultXGYi2VtPu5lkzjwYl/2nOZRe7Vx+s7FMFi8XIwjJfiRL7PWu/Jl1Y/2I19O80/yZfqjTgbCpH4fg8Wrmas8ivuI27ylZE4UyRjv/N8mdfw9GUP7a1oZQ3ni1cMx3kN/VIrfsytbT+8AL+7yTDatC+rVcOnSngiM4xpRv1AedBRwWpurFTxWdRWtmUhZw33MyBo0Rwvw4x6ltXlMTR67W3XfbdsfPDboPKihp1vY+Gn+yRounM+ReqCuMYPF848rj6XP39o8qYLHerlc0/q4WG8zFdiyefwtDm8jr2/D45vwNtU9u9BjqWfquY2e75p7K4SjbT5OkC4yaqrHPtBQj9VzTTw9ljhznizJPa9/jVHnu6CeHGkHFNWSJ/2szUsq6FcU/5qiT/U/aX+enRBZY7UI/yMO/q/cW3bCqI6d0Gc8tGcneLX0I+0ElasGSx07gXqbtfmamnYCY6+ntRNYF5M82z7td/Lu09L/aad/rbdJO4H+KS9WNc2/Uyf8QshS+907V8XWnp61qvpM1/vWqfStcfJ899/2sjGs73zZTrzI+0/LvTr093JdqDd0oSOUnTlWpiPQTsqujfxzMOXVt4+L+1RGJ2vz/TV5ewp4d9O+dd+5LqrLaI5tUQ0IWxP0MXh1HZvo9ORXtia83PImuizjhFgPsw4/JI+I3rdOk0k89DxG8p5Dic9nyY/eXbEO9NnNPIYXj3GNzEs+JfDMyd/z+M78pCh9gryYc6RN3gafSwF7FD09/43GTdEGek+F7q96ldGDtSJtjnl7IZSfbfbqKMtoL9Shu9ba7WK/kDJW61C19eXS/qTcrMPLbJwjU8JAfzJhsXvUGbi/07XutiR9LwIWhYnxapGxDtxbIu04JulJPPistfnkl299Zuvzg9A5Tzm0Xg6k9Unp28byfFmkdWTO1LLQmn49Gz9y/p2SvnX+ee/6pNCN7/oReNd/WPKuiet/hU3ycS8f4x3kl+49N13fKX0xf1pTX+f+jurrKgv61Ne34yV62rNVX4zORfpi6AfwcqnbxFpQv/H2OSPkUqQNRFuA4wXVKh54+7Nc99n3T3r5mL7Kj7lHQN9/3zJS4wFVRs6jzbEcn726xndLLDnXhbU5DXpE5gmp30t9ULQdDkmb03jO2lwumRNRcRleHg/5lf1OftUkLt7zt5IHa24M13r2/btfPh63rb3TJgbc26Odxh5p49ekXOmB7w84nxgTcx36V9B6Wuc7UR2JNru1OfmKcdvHAr4gf8jAi/3Jxn7cLqTNb2H9fBbkple3RX0Unr/Di/20cZvGftLOp89gSe55flhvT3kZfWRXZC5w1vfBoL7JaxOMkQgN7DoIfIN0mmEkvlYjc0XwWRRc+S4Xkkla2N8e//fi1znHm+jc3vnbi+h/Wt7OeNI6sYuBsX1r9A8mGCMRfBKBMzLmmXyqDkw95P8MuV6PYlyu4Y7GGtTRue7Eselzpj5nY9EebaKTLuAzaM5O6Av0/bxqF+oL/wz6wmsdOzsiF0V9r54OTj2DuoLuOdTdQyk7g8tg8HQdL38lSgfvO3fE8PByR76hpo9it+aOmPye1Tke6rNj7ojnh6QuO63NuoR7Xr5FG33bi3sI1EWGdfUh+gm4F9tFHnhZvofh6/lXbJzTU8LAd1oVX6356XVxPO3gqLH2XkydnqnaFgbiSN9dZA6C+u40hp5w6/mrpx1c3lnBK/XZbM6eQAyhVye3TF7Z+E1t84h9+kibu+ne2b8qeQ+enmjtuLYML+qLfZw/qfhRJlub99aUyVzLu2nfwOZOX+ddq0zz4t50LyF630DXmLdvoLxH8yjJe369Yt9A81bIp484Y2r/Hp+mPaaw0c7p0+8YkeNDfke/psYEMf+DcCw4cFT5sbK+PFs1qNaHW+PQ3ilrfVib/1LBY4tqPHKeGF6HHJw5Tw7JPa9/+5v0W5L+A+m3ycPNf1lGP2vzpxX0Oyj4GV1IP74vu8jrFhz8g2TYqAz/RQf/j3aw9632fZ+5RkZTyrAoP6M3H2x8yrCDoJ/B1Oe5tAaLp6uqDKPetu07zffzqva+ad+2kSEruOf59XlWV4Rfn74APdeVspQ64eMcWXrOgUnX3knAwbXUdbygxlAqfalLnMe+7We8Yided7KOQDspuzbyz8GUV7Rsa6IbfFLJOt4L9onJq754u+oyKutXkp3nB5IfevuQbWMXya+0hmVbXZY+T66bOvyQPCLaJlPbp0ks10k8Z22eULEOvFgSi7PJfr+c30/x+2e/Yvz7an7/Mn5/EmiVYryN/HMw5ZX1G3QG7Yg4JxiDF/d4yVMvxsA0fEQy9td96cOvfsrDr3/OzS978a2br37xy1/2rIdf+ZUPv+rVcxj6soDJ34pQOYB7j8T31Pmd11xSfWRW4OtaD0z9G9E9ayJHj9ijS/rZJUuNfdlz9p7Iboz2dD9fjsFvM8TiogNnInDadRkwBZXAWWu6/EinqBRQppvXgekMYIraOqArvw5MpwBT1HY/xUkdmGaVPrqYTKoj3Yy1frWOmhMz9lZ4zKzGphpIs3FaNZBmI9N8uxb3hMnGSAROu1gG7HgMTJtzVo/kXUwmS4N1NNbmvKkq63d37KnGXtcb2Rw3GcdQCBuL8r4KxhXcs/kYuF42QyFMFhaVeOzQrbNJK5NzTKV/E9w3Xw9zI0rPzN6PmZsJxkjk/dhFsyDqiM2lZOdRNdmc5TELG/nnYKprS7ZVHV0XM/bWWp3V2JRtdNnpUap1YKRrgamAQbrPaElgsjESgdMuyttIvVVTJBeTSbdHR2MN6mwl3x17qrFLZRuPEbOxKNvahJxFp1aleV90h/0Q5EsQL98sFXMeY84DlnOgkbX5ga8Yt/3H2L5YzX/n9sV5ucextF9uL6T5d7pZU3kulefIL1enhIHu3xRw2b3L6P+s3KvDj7O+yo4et+e8o8dtnPNTwuDJhOVkp5+JoZY9pBVP8BDbDvFc0Qw5Jb581tr8HHS2X33FGH9vvkwrX1Pci3xXgTrngLo29Ukti9LleBp+ynflzUvlx11v6Squqjtwfv3/Mb++6JXj59JkfDXhWdOmtKd4ri1PsT44T9OkGh+7x3kaJLsGXE82RvYO/k9nGyhiW3gVY3LdpqCRtfkKyM0PxcM34BZZCjj/b4x9PpA2qdDGYDkP2liba6DNR7Dm7XfqFOfkXp05TtlNWaflGKrkH+X+CblXx8fopYEFytJRYJrWpo13PJm8ymw8lm+I8hFF4mvp2loe4rjgyndZx4dm8zjNP7tIkzmPe5cFTurEnLtNdGIeNWNrh+EMtnZ68EWtNfU1UC4F+dHXyafqwNSH/5Tr1WBbTCbXcEdjberwxwVX+/vAHTy2p6eT7tTXq2Bcwb0e9n4m9AUbI5PHl145Hnu36AtHoS9cyeGjvkD/Txs7u0hfUNuwra5O3eOUA9dcCVyRugjljMGgcqauD0ePZKes4/uxuUb6NVkblDuGP/eC7XfSpo5NZPdY8lyPzVbdrUsblHK0h3iFifVPH+QG1n/UHhffia7/s857+v1Xjts+Ees/0gcZ7f/zbI9o/8Aetv3X6+qe9MlE25SRPrnAvTG3XIrhwXLG1ubBnJ5F8YZqq6T5d8515a+B+sWQvI17HV+6C3Wb/xW87aUz5m2qa9TVbXTuUG+hX8UreRAV20SdSHUbjmm6toW422/cV7A2byhZB5TVSdItH4g89pPl6Kg38sg0a/O3SvBnqssq4NVUlzT/bRapLtvvuqdUfKOb4a+xditoU6Z3evslc0l1KSfqEzzea1p9guOq/PP2sjydw8Ymr6mK7y+yKa7k36lT/kPw+qC49hHlTIIxEsEjEVwD9wGGjGtfBd3s3r0Y97LAaX977+5Sy+cutHzO3mmGz8cJPtm9R+Tf0/wze+dve+X4d0sT+zg8ky/77Wc3eVb+nWll9s4W0AflKHMSNJZC92Aok98BWf+7FTpqm31pynXPzqCsbxMn45WH8uQ6/QHcv43yddKHYH3be+CYms5mv60CZ2vzkyWyjum1fGcrcs+TAXXSaxeSsOMjNmW+5f7onGWpFWvzcxW6/yMFP2vHPg2vRwK/Rwbityz4HZfx59Hm39bUaVLAqzqN6tx96jTeUYGROo3RzfC38Y3GK4lfBtA7KrDNeqHOxBJ5Xizg9jED6L9JuQTu/WnJOM9fR74ead96/hm1MSkvDiXFssnafLBiHeiztKdp33fhKy+zJyP84J7/Ortnc5oyLGhtbfItlnfk+zoKfKzNH1fwZS0Pm+bfyZdN/rHMdtB+usuXqZ8anNbmv9fky/Q3Kl9W/Wg/8mXS2NpwfzHIfzmkb8VgUh8//a7Ko47huW27Lt8HrCqZQxnTxtfL/SBPxnC/aVoZU9fuZzyH0oj7Nn3si+oeW5f2RGR8FO0E5UEs3bO9R1ky39iXPWd0IY9Vn2NkHArln+LHuCVrc28JfntB97W5Qx4blQPn6RY2Pnmsl1OcBsKk/n/V07gOlcdyP8LaDCp4rOpmXp5VnbXP+DXGzihsjEnpM0Y0el+EeqbRgXslJxw42uTtUo8tyqPtmsc20WOfVMFjVY81upTpscQ54ijqaDtA92Q8+lmbZ1XQT+1powvpp/6nJJnkdZ6dECTDRmX4H3fw/6KaMmyX2AmjOntSkWUsi/akKMOsDeOQIu0ElatN7ATqbdbmdk07Ic0/u7ATvBhs7rlNG4PNNWqyg/4pkx0sF6o0Yj4IYwy4n5GiLdeGtVW/VvZvI/97MN21ORdWpW/Ny+S7fx3iQt/6FTvx2guxExoXWldHoJ2UXRv552DKq28fl80vTzf4hpq8nXNmN8UbmLwib4/cA1NdRuPQV9CGPgZbE/QxpPl3rpdU+k+FtowJZM6It/8/bQ0axgDW4YfkEdE22WoyiYfmCZL3HEp8Pkt+9P0V60Cf1ZzIoDjCtaZ5L6ytEKVPkBdzjqitXoc/8znuXUbRk3az1mbw4jLfUaH7qw1u9EjzT8oybz+/i2PwynL57bmy46ROTgkDfTKUsZH2tecb9HIaImtz0S6mzkDbomvdTWtzHRG6ECbGgEbuOTGOkbRbceh7IJn03/PZbfq+auszW5//FjrnOYfWxwJpfVb6Vrno5TtH63bHhNa6hxI9/85J3zr/vHet+Xt8138C++I3St41cf1NPPPH0DeiaiL0ra/rO6W+/rs19fWyUvgqC/rU17fjJWakr+tcpL5O/4IXAztt3SNPX4+qGRkV809bgOMF5ewNimKA/hg84FguL5rUn+hbRmpchspIxmX8xR5f49sxoD35WzUuw8Ynja3NedAjMnZM1636MKmjH5I2lPHbx6Lkc7zK38qjNab1t9If6vEr+538qmqvh/yW8Yxah7Yo7/AYdMM3vmo8blt7Z9raZLRT29ojbfyatJt74PsDzifGd6SvGo8dmUvJOcB5S5vd2vwV5sh9gC8qj9SL/cnGfvQupM3PgDafDLnp1WHo6njruvkLtPPpM2gT/0UZT9soak8+6zvqKETy2gRjJEIDu3jMZ5BOM4zE1+pCHRd8jgiufJe65+rFtHs6vc0RzvEmOjf94ZcFzi54O+P768THB9azWGt6vgLjs6Lya8mn6sDUQxz2kOvVYFtMJtdwR2MN6uhcd+LYXhwg6U57tIlOyvywoDk7oS/Q9/Mlu1Bf+B7oCy907OyIXBT1vXo6+G6o21SUgxmlg/ddp8Dw8OoUvLzEHt0LuSO7pU4BbWBr4/khvTintn7IvvItAnWRYZN8wTeCbyntpskDL8v3MHw9/0rkGSRF8dVta2qdd3BUv5k31y4LXG1hII703UXmIOhaSgUXwn1I2px3cHlrBa/UZ3lOBeUjfUZl8srGb2qb3wlx8GV7Zz9c8h48PVFzJ4ryOSNl8tEC/CiTrc2P1JTJXMu7ad/Ai+WLkh+eTPPqX+peQnScturLnozRelqe/m5t/mXFvoHxD8Ylag2lpj4R2mMKG+2cPv2O5G3qY6zju6euz/gf+06/psYEsZYJ4Vhx4KjyY/Vcy2STxy7lfSkPYi0Ta/PrFTx2SfCzduzT8FpycOY8WZJ7Xv/2N+l3VPqPrgVj/ssy+lmb362g36LgZ3Rhn4YX27K/FQf/IBk2KsP/iIP/79eUYWV732rf95lrZLSlDFuKoe3Qmw82PmWYteE+SFD+tytXDRZPV1UZRr3N2vw/Nfe+vTPq2p734Pn1uW6m9esv4Z7G09COpd2vNOIeI2XpaQcmXXs8RyLyzCeNoVT60k6659VjWB/16p143ck6Au2k7NrIPwdTXtGyrYlucCx/p3vVPvHqzUTtIXm6jMr6FbShT8+r0TJtPVLuQ9qaoJ7fRpf18mDr8kPyiMD9kgkeZnioTVMmz1hr39p8UsU68GJJGGdzJgTX4W3Pf2ljreL+acHVfmOstrUZluAap4esDcp8J8xntjZXS+D0dJo0/05+ZzjTN27fT+N5tqUc0hya7Dri9MX9LMJ1Wp6hPkPdj/pB1zQv8sfZmORjj6+gufrjTKaQ5ppHciDZqSdpW8+uJM1PO30RFn7X90uefKRknBB5PxwMFP4jAid5OmOfI+NzOffJLzhmUe0Bzhtr86wK/qnPZnPxmx/Y+s49Dcpu1ZOtD55DEXUuDeXHvMBDXmVtvrhi3ZwswOWI09fza/ZlzxlNrU9Ppz6Q7NTztS3t1oWK5wjDeXmGOoSn09PHERPvPdzkewuAkTQvi/deFVyog72k4r3ofLU+KL8Po9+iOWVtXlYx3uGC8Y44fb2yZl/2HPlQdnGeWNsD+L3OnKp6ju/rpDxDHk6YFmSchWQSl438czDNlfPwkw78hG9RYF9AuwgernxA527Z/PbOD//bNXk4edmXPrD1nfVHvPOUbI5eyf9exfjW5hvga3j3q3f2exqwqLysYzuxrolXd6SLvO+yGruXcc9oTN4ZabeqLmHvgWPa+rK5Yr9dAc7W5ttL5gr93XxnC3LP49GUO9YX17Z9HhJ8NvK/B9Ndm/6Tg3lfOmcPAU5r830VfPWg4Gd0uQL8FjCe4XcwEL9Dgt8RGX8ebd5W0z9EW3Q31aKxudOX79/oZvhrnPwK2lBfsjXB8zjarJcV3KM/2/gYfd1t9uoohxnjpTlUXmwb+XrftWhsvXFMlY2ebLI2P1mxDvTZDNc3vXDre7bG7TwY8kPNv+nCX04ZdlTueT4TL0fH3uFR3NO9ctrPlGFBa8vds70CXA0fa/O+Cr6se3T23siXTf5R/gTpcy5fvoJxDU5r82s1+TLPIdpNfvvdwpepBx3Cd4PpQiBMqq8aLBxze+9a2nCvztr8XsmcKJIx9uxpZ0zt39sj8GQM7fxpZQzlifEe+s20TiR5Me3xF4AXr8rv2TMX5N4c7hmcFwRO2hMXcM++R9gTfcduGi292M0/a+grNrqQx3o1hvuM3bwi41Mm/tUe132397/AYyP5meoWNj55rO6XROuBusY8PdDen/JY+uSszcd95dZnEY9V3Yx+k1POmNo/eaDdu4C+FLZsHj/W4W3UM1X37Jq3RcZ9kEewFu1RB44VB462sZtBusioqR57pWS+eXqstSvTY4kz58mi3PP6t7+92E3qyZF2AP0lRfSzNn+jgn5qTxtdSD/1P2l/np0QGbtZhP8RB//1Evx3oZ0wqmMnRPpJdT54doK14f79rO2E7fpOSbGdYG02KmSY7ifSl3DaGVP7pwyzeynuGX+mHWK/t627XBYLRTuB+VqenbAAWWq/cz+D/h2uDdrqKdpn/zbyvwfTXZtz4Yr0bWPRZ2VtnvWVY1hf/ZU78SLvT+VeHfpT30hxz753oSPYHG+qI4TEcgy2Yjf79HFpbDJ50s2avJ1zRnm76p13cuxmUZ4G4yk1Lp/8kD4G1bOb6vTkV965HG10WfplLuBeHX5IHrGQTNq0Xb+HK8kkHl6N8jT/fijx+Sz50esr1oE+m+E698IxrpF14lOBZ07+nsd3xqFF6ROkR5p/0m69B+M2iUW+BNj7rBPv6TnW5hsqdH+VP2n+nbq/zcmyumn075EfRNaJ11jVtjAw39SrE9/FOWIaD1pXd7RxTkwJA2sJcU+rav+qa91tRfoui0m9DJiCarpN5IrMC+0WHfoeSCblEJ+1Nn8InfNt0DnTZCetI2uiX5C+baw02QkTaR2kf7g1+W38Ir9T1zRJpW+df967viB047v+Jbzrf1LyronrO/HM+6BvELYO6T6Ifqeaa2V4rAB3a/Pumvp6WR7tLPdsbS70VUNa9wl1LnKfcBX3TP7Rb94mXpD6DX3EkXIpcH9v6O2hBsbQD4rsjPeBB3zY4Ru06+0d0vfft4xUf6vKSPpb37/H13jfufLqb7Xxud6szSroEVmDRvlCmux8Z9u+C2lDO8Ta/Mea/lbqVWn+vYk/jv5QLy6D/GrauIyyenVc97Z+udaz789/zXjctvZOm33NlcSP9Whrj0ybw9sD3x9wPjH+4S+gf0XWNuUcKFor1ubfv2bc9n8AviB/yARtCOfca3Yfbb4btDmYf+8ztnTWe/JBevwoMN5+RF6bYIxEaGAXcwCCdJphJL5WJ/6o4LMkuPJdVsUYFOn0GsPQVOemvOKctc9pefsi7tXxwQfqNVPViY/a7yKfqgMT8/+i1gbXK+vEcw13NNagjs51J45Nn7MXK0x7tIlO2kP80YS+QN/P1V2oL7wG+sIN6Av2TBf5lGVx03OJr4NH51xS1zEYPF2nLGYgwg/ZZ9yA1tWgXH1yPheqfBQp4FUfhb7T/Rg3QBvY2qziXl9xA4wRmTZugHI/ysfSJCbh+eBbSrsuY5t1f6TIv+LFxk3rh0gduC46/V9s0D/pRRxX8b1ornnxKG1gII703aUCw0b+92C6q3be5/Y+hrRZdXB5dQWv1GezOfueF2x9p3yMrhMfsU8faXM33Tv7OyXvgX3Zc0aXFPiRDxt+kTJ5pQA/ymRr8401ZfJuzefcjj+GTI700atM8+KMdS8hUDd3z7U2WDzdWPcNGBtgbf5hyZygDUVdT/lNUz5NeywV2Gjn7JecdubPEI5FB446uTKerbqAPrrmsZpTnmJcg9PavKOCx2oOtdElBX7b+RoOzpwnh+Se17/9TfqtSP/ROflaCybFuAantXl3Bf2KasGkwI/vyy7yukUH/8hctSL8lxz8f6qmDCvb+55lnXijKWVYlJ/Rmw82fpp/rqAN90Ei5ar6WwwWjsk1yDbMl7U2v1ghwzy//rQ1CTy//iH0H+HXr6pJkObfadvOObLUq12va8/a6lzI/m3kfw+mu9wYSq9OvLX5Xfga/3qf6Qi0k7JrI/8cTHlFy7YmusGH97h9YvKqL96uuozK+pVkZ70Z8kNvH7Jt7CL5lVejpY0uS59n0xot5BHRNpnaPmn+nWNqnXhrcwHPbdfLfO0kfryKYkn+wolxXMX4l9HW81nNo83HvXbc9tNfu7Nfnl+pZ1rO4Z71a3+TD9pYF3HPvkfsGZG3r+Ke0fy+/DMyNpa6j/Vt74Fjatyf1lugb+1syVzx5Aj5FN9Z1R4o7aIe9shLazB4MbGrJXRgX/acV4OBeNlnpGzU/bQTMj554qMreEKd/TRbc7sl5jcyrr/ofCzKEdYGsHtaI557xlwvTXLeGGdmfMzzpbeNMWIervE22ifG25jXaHw9ew+0B7p+D2kyiYetN45J+6lINlmbx1WsA302w/XJ2CuxHFLyQ43/r+PPpLzyahdF2yKUYTbPKMP6PC/eaO6dF//0Cr6sNneafydfpp5n+PUZ52CweHEOX1CTL18CvMqXVT/aj3zZaEy+zLj1i4Ewqd1usHBMe3/Ko1iz0No8WDInimSM8iWOqf1TBtg9T8ZExbEa72FchfEer/YN43SvgBen+X3Kwktyrw4daE9cwj37HmFPBPpIR9QvlAfxTAVr84YKHqu6itGFPFZrBGjOXtc8tqjGgnfuzdfucd3Xy2m9FENb98wOrYm6kuz0s0brgUX1xbxzPMrqi1mbb63gsaqb0W/Stv7XJfSlsG3uoTi8jXpmGx7fhLe1jVMr02OpZxqu9+GeV6ekTR03zzceqIuMmuqxP9hQj9W6tJ4e68UHUyc7X9K/l890UvqPtgM0tsqjn7X5JxX0U/+T0YX0U/9TkkzyOs9OCJJhozL8Tzj4/4u9ZSfUOt880k+q88GzEzSHJtpOULnaxE6g3mZtframnZDmn13YCTzT3MsJt9/Juy9L/5ed/r09GZMd9E+Z7GA8udJos37D87e+s5Yk9zNStOXasLaqz3S9b31F+rax0mRMJ2vzG9hP+bPX7sSLvP+y3KtD/6K6Fvoup9ERbP401RFoJ2XXRv45mPLq28elZ2uTJ/1+Td7OObObavibvOqLt6suozlZXq6Il7tBnZ7rJZX+U6EtdXqvBudl9D9tTeJLuFeHH5JHROcxXEkm8dCcDPKeQ4nPZ8mPPlqxDvTZzTyG549xDZLda+SrCcZIBH+7DI5IO530oEy+KPBwf8Tuqx7I5+4F7FH0pMxQ3ZfwW5uPe93WZ5Hur/LH6EHdP82/e/KH8vOU3Kvr39M8t7p01xo0bWFgLA1jItRfSX7dtA5om5wg8sVTU8Lg5WTX2b/qWnc7Kn0fEboQplXAFJSn5NZt5D610vdAMimH+Ky1eUW+5rL1+ejXjfG67NA68nzzS9K3d07tZYfWQfrHOmFQ33CR36lrmqhdovPPe9dqv/FdPwPveq3kXRPXq3jm6a8b4x3kAx5Ev1M9U0zfKfe3Pr1EHtWNM53lnu22jwH6epCfy80583wJWvuWspF+8zbxgtRvyBcj5VJkDoS3h6oxqh3ynEGRnfF08ICXO3yDdr29Q/r++5aR6m9VGUl/6xfu8TXu5br2WQdXz9CjvzUFPSL9ranApDHDtB0OSZsUz1mbWyVzgvyKua5t/HH0h3pxGeRX08Zl0D9i6zDFPVuvtn651rPvH3jdeNy29s60Pukm5/UU0VFjx5vKlR74/oDzib7ur4b+FbSe1vlOVEeizW5tvvj147Z/G/AF+UMmaEM4v24X0uYSaPONkJt9xZaW+dv72JMP0uNHkXnq5LUJxkiEBgnwtM8gnWYYia/VyDwp+BwRXPkuq2IMinT6aePj6ff36llNy9uZ+1bHB7+QhNUCXqN/MMEYieCTCJyR+13kU3Vg6qF2z5Dr1WBbTCbXcEdjDeroXHfi2PQ5e7HCtEeb6KQ9xB9N6Av0/fzYLtQX/hz69k86dnYX+ZRlcdNzia+DR+dcUtcxGMrqdNInHaWD9x03YHh4cQPvq+mjoE9WfRT6Tvdj3ABtYGuT4p4XNzCtzerFDXj1IdrGDVDuR53T2CQm4QPgW2l+PyK2WfdHivwrkbFxRbFTGnNdF8c02Yljiu9FMSpePEobGIhjmn/uhrzPoljJ1MHlzyp4pT6bzdlvev7Wd8pH+ozK5JWNP03eZ1f79JE2d9O9s4Ovn/yNl6cnas0h+hRoR0TK5KMF+FEmW5tHlOC3F/I5t+uMQCZHyQ9Ppuk5LpRpnM+R+wa6xrx9A+U9lwVG8p7/r7xz520iCOK4CY5zdkgOHIkEwiNWgPoSCQlRhYIOUSLxEEIUCApECykoaOgoaJH4CpRIfAEKJCpqehokKlq0yY3z899zDye3SYCTotusZ2dndmf++95bKrEJjqF4343izaQ4zfGYysZxzv9ypp3nZyhH6shR56yMN1aNecehnilnm25yGk1WgbF6htq7P8z06jo60066Eufx9+4YPSH8Y5/Jt/nLsvIzmqsV5ZeIfvqtx3nRyx7ySx39Y55VK9L/uKP/tZpt2CG5R23srNHw/lG0YbHmGT17sPzZhhkN10Fi3imm7ap+/7Bs7Zv9NqO5WdGGefP6u2lD0tb4Pf4cy/DOnRjz+lV3EmgZcY2RbenAkUl9z2i1jxX+NvL/s7097h5KLV/2JR5gbfLVi3G9/vV7b2jfG/k72+Oz3/fNlPUNnv3l45PD8l0dYrveN0M89NYhd7t3kXgV+07iOnhIjIg9JtOxzyR7uc4hndG8rvADby8J99msRNF17VHgNxDeltcq4nX8ab+tQFejeVOia7x6W89YJ4ZNppt3zudtRb9b2xbrUxHTdfw7hTBtiLTTiNMzVeFZdnjRbxnWdjIFf54LIwY0Xea6tjgQmWgb7yvKXP3Oa0fPiu5TrfF6VtqLiNP5c8pKXpRlgLDiagr+lHMg+bAewrORv7O9PGtZRpkoP+VT/Epa437fiDw5fmo7syrlU4YpXj/xQwV+atpgi+/ubYdZFxeQ/wpo2VZxLYtY1XQ/mWdjKA/1N5qPFX5zvkCXVYfXp5q8LB3PBIfHO78/1Rrfy6y0lxC/XJGOYc+eLwgd8zFfjGfja1u4R19mmTNPPY+sd+WwXj5PWMe6tznQLIIv09CmjOZLRX6LBfmtOry+1uRl6bTd8tYwp/A7bZK0tKmqdAyvSBpi+PmSfNgXC89G/s728uQYTvnVJ1LIsAhZYq6Jap2lUj70AbVv2qHRfK/AcE0b7O45MLyfx3OMo2tzddcsvTWe/fyGjN4XEWhsPKRlyTUeo/lR4W/6nRTqae8l0DfdtikOmTxLiDeanxPiEOfHlNevCXHIvjfBs9S6nyyU1WnwaLr/vCz6Wb2fhpxG87vmfEof8up8iu7jiTefsp7pfIqVKedTTkUp22071DZa75Di3AnnI/ScE/cZEmsmuSfhFHipb4e6f3h3O8y5Qs4/9yXuCOIs/77kH3gt5GH7Lfa+N5XJfMzbu98Rmj7SDfubm6Pp+ZDXtJQB98fz3ELTWEccojwJ4o1moUKXYwW6LDq8TtbkZemsrTGeRd/I2E+ss3r3sO5MiX7EOp4lV6wz2z8IrLMyPSisG+afv4l1xD/9rsQxlBuxZkH4a9mmiCPWqW+Hul8G1s2B1t5ql/Qry9/bJzEPWcITcZ37cuCne7VMV2+v1nqFv+oaquEHvxtqenFdtx9Rv4UC/YjTRnOlpr/OQV71V6u/fVjruXzQZ9jVn4b552/6E+15PqJM6mO0PctzDnK2W+PfbGuD5nqJTfCMPs+wKx4wT+VP7LE4jg9VtmDH3+5sh0NZzsSxra22Lkl28mwjr2nYVxf5N90vSYS35ZXA5yx8a3OHtpuMlrX5rckfbMF8hPJrurakS0HTQboZSWf/W92G8ruRy9fLaawMb2/u0Nzld2vz34+iDp44v9tzZPTfrTyGYdRXEtFeumIvw3pC/r2I9qK22JM6biP8GPbSK7CXBPZidUr5NV1H0qWgoZ8mki5x7OU+7OIJbCdpjdpeg3W4zvbsaGvUBzoFPt+0DfXEhroO5sxGtCG1z1mp9zbCL2FDswU21HUwx2iDH8+IjxBPrHwVT8poWDezNXAwEZnq6JKCJpkgP6brlOBu1/GHp/CBP7yf+WG7SxIA","debug_symbols":"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RYMbPvE1Y1+vOmmLBjd8ioZu+BQN3fApGgPNGRq64VM0dMOnaOiGT9Hghk/R4IbP0HT2spqmaHDDp2hww6docMOnaAw0Z2hww6docMOnaHDDp2hww6docMNnaDp73VBTNLjhUzS44VM0uOFTNAaaMzS44VM0eX3NWm9HCq91PYLJ62pWm29g5vkAZszraRwweR2NAybvzuSAybsvOWDydjQOmLwNjQMmsY+5BoOPeQwm8Zt7HDD4mBMweXsZB0zeVsYBY3nBrNMNzHZM14nf1+OASex8r8Ekdr7XYBI732swiZ3vJZjEb+lxwCR2vtdgEjvfazCJne81GAPMYzA43xMwON8TMDjfEzA43xMwON/HYBK/kccBg/M9AYPzPQGD8z0BY4B5DAbnewIG53sCBoN3AgaD9xhM4tcTOWAweCdgMHgnYNS3a9vuYKb1h+s/B1DfVt0B1IsfdwD1/dsdQH2f9QaQf2mJO4D6vuUOoL6/uAOoB313AHv3Ad59J5Z/OYU7wLvvxPIvenAHUN+Jx+k+gK3e9fMw3i6fy5fPjZbv48q/YqHxuOq7fONx1T1B43HVHUTjcS3XuOrupPG46l6m8bjqzqfxuOo+qfG4qVyVyR/V33jcVK7K5I/UbzxuKldlg+UaN5WrMvkj6huPm8pVmfxR8o3HzeWq5I98bzxuX67q4150u9zGw4u/TP5k9rbT9uWpPp7d3actx2k723Snsv/Dnepx2s72XGfazrZcZ9rOdtzraeVPlf7Nabf5vu7tOG1nLYYzbWclhjNtZx2GM631Ne39k6lLPXqp2td+uy775es2HaaVPxX3t6atZT81upbjqdEmf9Rt22m7uie703Z1T3an7eqe7E7bVavsTttVvnWn7Wq/daftKt+603aVb71p5U/mbTttKi8lf4Zu22k781LzuE/7z2J/ntZSTduZl3Km7cxLOdN25qWcaTvzUs60nXmp62nlz3ptO21nXsqZtjMv5UybykvJn5/adtrOns1fPxmRP7ey7bSdPZu/nlb+hMnffOpV9yea63TMt/LHRradtq9n8960fT2b96btar91p+3r2wXetH19ztGbtrPPXTjT9uWlvGn78lLOtPKHObadNpWXkj92semnw5bOvJQzraWatjMv5UzbmZdypk31GVb54zrbTtuZl7qeVv4g0LbTdualnGlTeSn580jb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"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"initialize","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Counter::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Counter::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Counter::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Counter::increment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::increment_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Counter::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Counter::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::initialize_parameters","fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000906cb9c3"},{"kind":"string","value":"EcdsaPublicKeyNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000906cb9c3"},{"kind":"string","value":"EcdsaPublicKeyNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000906cb9c3"},{"kind":"string","value":"EcdsaPublicKeyNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"public_key","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]},{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"counters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}}]}]}},"file_map":{"2":{"source":"use crate::cmp::Ord;\nuse crate::option::Option;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n","path":"std/array.nr"},"5":{"source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\nuse sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"53":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"59":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"62":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"64":{"source":"\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\ncontract Counter {\n    use dep::aztec::prelude::{AztecAddress, Map, FunctionSelector, EthAddress, PublicMutable, SharedImmutable};\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n    use dep::token::Token;\n    \n    #[aztec(storage)]\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n\n     // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[aztec(private)]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        dep::aztec::oracle::debug_log::debug_log_format(\"Incrementing counter for owner {0}\", [owner.to_field()]);\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        Counter::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n\n}","path":"/home/lima.linux/aztec/aztec-starter/contracts/counter/src/main.nr"},"82":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"83":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"84":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"86":{"source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"101":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_data_tree_index\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"103":{"source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr"},"104":{"source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"},"107":{"source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr"},"109":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"110":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash,\n    hash::{\n    pedersen_hash, compute_siloed_nullifier, sha256_to_field, pedersen_commitment,\n    poseidon2_hash_with_separator\n}\n};\n// Note: pedersen_commitment is used only as a re-export here\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"119":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"128":{"source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N, M> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N, M> + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N, M> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"129":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"130":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once. \n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"133":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"135":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"136":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"139":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"141":{"source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"142":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"143":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage,\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, public_data_tree_index: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"145":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<let N: u32>(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<let N: u32>(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"146":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"147":{"source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr"},"148":{"source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\npub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"152":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"154":{"source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"158":{"source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"159":{"source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        /// 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        /// the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        /// implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        /// 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr"},"160":{"source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr"},"161":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"162":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"166":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result = pk.x.to_be_bytes(32);\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result.as_array()\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"167":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"172":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"173":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"176":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"181":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"188":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"189":{"source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"190":{"source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"191":{"source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"192":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"197":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"199":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"216":{"source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"233":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"261":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"277":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"279":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"281":{"source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"291":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"292":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"293":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"315":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"317":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"321":{"source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n    keys::getters::get_current_public_keys\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl<Context> EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_keys.npk_m.hash());\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_keys.npk_m.hash());\n        self.set.insert(&mut result_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr"},"323":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/value-note/src/value_note.nr"},"324":{"source":"use dep::aztec::{\n    context::UnconstrainedContext, state_vars::PrivateSet,\n    note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions}\n};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote, UnconstrainedContext>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/value-note/src/balance_utils.nr"},"328":{"source":"use dep::aztec::prelude::{AztecAddress, FunctionSelector, NoteHeader, NoteInterface, NoteGetterOptions, PrivateContext};\n\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal ECDSA_PUBLIC_KEY_NOTE_LEN: Field = 5;\n// ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ECDSA_PUBLIC_KEY_NOTE_BYTES_LEN: Field = 5 * 32 + 64;\n\n// Stores an ECDSA public key composed of two 32-byte elements\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[aztec(note)]\nstruct EcdsaPublicKeyNote {\n    x: [u8; 32],\n    y: [u8; 32],\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NoteInterface<ECDSA_PUBLIC_KEY_NOTE_LEN, ECDSA_PUBLIC_KEY_NOTE_BYTES_LEN> for EcdsaPublicKeyNote {\n    // Cannot use the automatic serialization since x and y don't fit. Serialize the note as 5 fields where:\n    // [0] = x[0..31] (upper bound excluded)\n    // [1] = x[31]\n    // [2] = y[0..31]\n    // [3] = y[31]\n    // [4] = npk_m_hash\n    fn serialize_content(self) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n\n        for i in 1..32 {\n          let byte_x: Field = self.x[31 - i] as Field;\n          x = x + (byte_x * mul);\n          let byte_y: Field = self.y[31 - i] as Field;\n          y = y + (byte_y * mul);\n          mul *= 256;\n        }\n\n        let last_x = self.x[31] as Field;\n        let last_y = self.y[31] as Field;\n        \n        [x, last_x, y, last_y, self.npk_m_hash]\n    }\n\n    // Cannot use the automatic deserialization for the aforementioned reasons\n    fn deserialize_content(serialized_note: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> EcdsaPublicKeyNote {\n        let mut x: [u8; 32] = [0; 32];\n        let mut y: [u8; 32] = [0; 32];\n\n        let part_x = serialized_note[0].to_be_bytes(32);\n        for i in 0..31 {\n            x[i] = part_x[i + 1];\n        }\n        x[31] = serialized_note[1].to_be_bytes(32)[31];\n\n        let part_y = serialized_note[2].to_be_bytes(32);\n        for i in 0..31 {\n            y[i] = part_y[i + 1];\n        }\n        y[31] = serialized_note[3].to_be_bytes(32)[31];\n\n        EcdsaPublicKeyNote { x, y, npk_m_hash: serialized_note[4], header: NoteHeader::empty() }\n    }\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl EcdsaPublicKeyNote {\n    pub fn new(x: [u8; 32], y: [u8; 32], npk_m_hash: Field) -> Self {\n        EcdsaPublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/ecdsa_public_key_note/src/lib.nr"},"341":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr"},"342":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr"},"343":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        prelude::{\n        NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n        FunctionSelector, NoteHeader, Point\n    },\n        encrypted_logs::{\n        encrypted_note_emission::{encode_and_encrypt_note_with_keys, encode_and_encrypt_note_with_keys_unconstrained},\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    },\n        keys::getters::get_current_public_keys\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote,\n        token_note::{TokenNote, TOKEN_NOTE_LEN, TokenNoteHidingPoint}, balances_map::BalancesMap\n    };\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES = 8;\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_current_public_keys(&mut context, caller);\n        storage.balances.add(caller, caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_with_keys(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller)\n        );\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n        storage.balances.add(to, to_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n\n        storage.balances.add(from, from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from)\n        );\n\n        storage.balances.add(to, to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32\n    ) -> U128 {\n        let subtracted = storage.balances.try_sub(account, amount, max_notes);\n\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128\n    ) -> PrivateCallInterface<25, U128, (AztecAddress, Field)> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[aztec(internal)]\n    #[aztec(private)]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, from_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, to_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness) - G_npk * fee_payer_npk =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness) - G_rnd * randomness =\n    ///                          = G_npk * user_npk\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payer npk values of these known contracts is a feasible attack.\n    ///\n    /// `fee_payer_point` and `user_point` above are public information because they are passed as args to the public\n    /// `complete_refund(...)` function.\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_npk_m_hash = get_current_public_keys(&mut context, fee_payer).npk_m.hash();\n        let user_keys = get_current_public_keys(&mut context, user);\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded \n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n        storage.balances.add(user, user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, user_keys.ovpk_m, user_keys.ivpk_m, user)\n        );\n\n        // 4. We create the partial notes for the fee payer and the user.\n        // --> Called \"partial\" because they don't have the amount set yet (that will be done in `complete_refund(...)`).\n        let fee_payer_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(fee_payer).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: fee_payer_npk_m_hash,\n            randomness: fee_payer_randomness\n        };\n        let user_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(user).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: user_npk_m_hash,\n            randomness: user_randomness\n        };\n\n        // 5. Now we get the note hiding points.\n        let mut fee_payer_point = fee_payer_partial_note.to_note_hiding_point();\n        let mut user_point = user_partial_note.to_note_hiding_point();\n\n        // 6. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"complete_refund(((Field,Field,bool)),((Field,Field,bool)),Field)\"),\n            [\n            fee_payer_point.inner.x, fee_payer_point.inner.y, fee_payer_point.inner.is_infinite as Field, user_point.inner.x, user_point.inner.y, user_point.inner.is_infinite as Field, funded_amount\n        ]\n        );\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        // TODO(#7771): the following makes macros crash --> try getting it work once we migrate to metaprogramming\n        // mut fee_payer_point: TokenNoteHidingPoint,\n        // mut user_point: TokenNoteHidingPoint,\n        fee_payer_point_immutable: TokenNoteHidingPoint,\n        user_point_immutable: TokenNoteHidingPoint,\n        funded_amount: Field\n    ) {\n        // TODO(#7771): nuke the following 2 lines once we have mutable args\n        let mut fee_payer_point = fee_payer_point_immutable;\n        let mut user_point = user_point_immutable;\n\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We add fee to the fee payer point and refund amount to the user point.\n        fee_payer_point.add_amount(tx_fee);\n        user_point.add_amount(refund_amount);\n\n        // 4. We finalize the hiding points to get the note hashes.\n        let fee_payer_note_hash = fee_payer_point.finalize();\n        let user_note_hash = user_point.finalize();\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_note_hash);\n        context.push_note_hash(user_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"348":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}