{"noir_version":"0.33.0+2d702155f9341cac08a960f271e3ed5450740729","name":"Counter","functions":[{"name":"increment","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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qX3lJbNlA3onoceGDeh1cI+0zN4OnPbAKXs7cNrBPdIyeztw2gGnhb0dOFW891phDwaeNHlirwSezrmrVWGvBPROQk9AD/TOQY+9EtA754Zqhb0S0DsJPbY/NNFLZeHDZRe+oPdRbix+1XIjoyuWO0041arlRjm+qtxT3Cg3Rq5qubFQVcstlLtmubENVctNh1213HSVVctNV1m13HSVNcvt6Cqrlpuusmq56Sqrlpuusmq5hXLXLDddZdVy01VWLTddZdVy01VWLTddZc1ye7rKquWmq6xabrrKquWmq6xabqHcNctNV1m13HSVVctNV1m13HSVVctNV1mz3IGusmq56Sqrlpuusmq56Sqrllsod81y01VWLTddZdVy01VWLTddZdVy01W+qtxbP/QTusqq5aarrFpuusqq5aarrFpuodw1y01XWbXcdJWa5b5z56KPctNVVi03XWXVctNV1iz3TFdZtdx0lVXLTVdZtdx0lVXLLZS7ZrnpKquWm66yarnpKquWm66yarnpKmuWO9JVVi03XWXVctNVVi03XWXVcgvlrlluusqq5aarrFpuusqq5aarrFpuusqa5U50lVXLTVdZtdx0lVXLTVdZtdxCuWuWm66yarnpKquWm66yarnpKquWm66yZrkzXWXVctNVVi03XWXVctNVVi23UO6a5aarrFpuusqq5aarrFpuusqq5aarrFnuQldZtdx0lVXLTVdZtdx0lVXLLZS7ZrnpKquWm66yarnpKquWm66yarnpKiuWO090lVXLTVdZtdx0lVXLTVdZtdxCuWuWm66yarnpKquWm66yarnpKquWm66yZrkdXWXVctNVVi03XWXVctNVVi23UO6a5aarrFpuusqq5aarrFpuusqq5aarrFluT1dZtdx0lVXLTVdZtdx0lVXLLZS7ZrnpKquWm66yarnpKquWm66yarnpKmuWO9BVVi03XWXVctNVVi03XWXVcgvlrlluusqq5aarrFpuusqq5aarrFpuusqa5Ra6yqrlpqusWm66yqrlpqusWm6h3DXLTVdZtdx0lVXLTVdZtdx0lVXLTVdZs9wzXWXVctNVVi03XWXVctNVVi23UO6a5aarrFpuusqq5aarrFpuusqq5aarrFnuSFdZtdx0lVXLTVdZtdx0lVXLLZS7ZrnpKquWm66yarnpKquWm66yarnpKmuWO9FVVi03XWXVctNVVi03XWXVcgvlrlluusqq5aarrFpuusqq5aarrFpuusqa5c50lVXLTVdZtdx0lVXLTVdZtdxCuWuWm66yarnpKquWm66yarnpKquWm66yZrkLXWXVctNVVi03XWXVctNVVi23UO6a5aarrFpuusqq5aarrFpuusqq5aarrFjuMtFVVi03XWXVctNVVi03XWXVcgvlrlluusqq5aarrFpuusqq5aarrFpuusqa5XZ0lVXLTVdZtdx0lVXLTVdZtdxCuWuWm66yarnpKquWm66yarnpKquWm66yZrk9XWXVctNVVi03XWXVctNVVi23UO6a5aarrFpuusqq5aarrFpuusqq5aarrFnuQFdZtdx0lVXLTVdZtdx0lVXLLZS7ZrnpKquWm66yarnpKquWm66yarnpKmuWW+gqq5abrrJquekqq5abrrJquYVy1yw3XWXVctNVVi03XWXVctNVVi03XWXNcs90lVXLTVdZtdx0lVXLTVdZtdxCuWuWm66yarnpKquWm66yarnpKquWm66yZrkjXWXVctNVVi03XWXVco/YVcp8LXcu9w8uYSnFBc31UJ+X+omN+s0+rfWb/RGuOS2nvvx3vmKVw2Y2zi2jvvz3TUEuh38U0Ujzd24RjbR0PypicJNfxhzc/KWI/+3yj3/9j7/89a9/+V///a9//7d/+cdf/v63/3x78fT2/8j85529vmleKubyzQc+vZX57VX5V68qv3nVzgbC0avcr17lf/Wq8KtXya9etflnIuUFxOzd1qviD191+Zd7OzKFP2//UDiWhbkUp5tLqn97x7dXpV+9Kv/qVeU3r9r+Ed3hq9yvXrXDlVuz3nxV+NWr5Fevmn/1qvirV6VfvSr/6lXbf3PSekVIZeNVO1+FPXqV+9Wr/K9eFX71KvnVq+ZfvWqbjZyXV5W09ar0q1flX72q/OZVO9ejo1e5X73K/+pVm2yUtWUqfuuTsn09OnzV/KtXxV+9Kv3qVflXryq/edW2lrp91VZe23bl8FX+V6/aZkPWBk+2PsvbHd7hq+ZfvSr+6lXpV6/Kv3pV+c2r0jYbcVnpu0nmLy/7p58c/PkersJ7+ArvESq8h1R4j7nCe8QK75EqvEeu8B7l9e+RK3zOc4XPea7wOc8VPue5wuc8V/ic5wqf81zhc54rfM5zhc95qfA5LxU+5+X5z8ecloPnm60En9zyFvPr3+J5quK0LODiFLfeorz8Ldw0VXgPV+E9fnrx+Hydyy8nxbny+vfwU4X3cBXe4/lFQFz3bKIPm+8RKryHVHiPucJ7xArvkRT+PpT1PWTzPXKF9yivf48wVXgPV+E9fIX3CK+/7gSp8B5zhfeIFd4jVXiPXOE9KqzLpMK6TCqsy8RXeI8Kn3Op8DmXCp9zqfA5lwqfc6nwOZcKn/O5wud8rvA5nyt8zueXfs4v//JvR+bpz5tsuXledkHdnG6+KrP1zbG8flErp3j/0EsLGpfz+ulmISNv876MpjQ1mu3H1p43HNfWcHxbwwltDUfaGs7c1nBiW8NJbQ2nrT/Krq2/yr6tv8q+rb/Kvq2/yr6tv8q+rb/K/oV/lT/f4fk/tMUt378tfn52wqmt4eS2hlOaGk6Y2hqOa2s4vq3hhLaGI20NZ25rOG39VQ5t/VUObf1VDm39VZa2/ipLW3+Vpa2/yvLCv8qf7yAvf4f55e8QX/4O6eXvkF/+DuXV7zBPL38H9/J38C9/h+dpdZOTVeTfflFkfY/0+veIz6ft/LxuSPjkN95DKsxjrvAeFTKPReE98rS+x83P19b3SFOF93AV3sNXeI9Q4T00Ph/JX98jb7zHXOE9YoX3SBXeI1d4j/L698hThfdwFd7DV3iPUOE9FD7nl4vtcrCb3cZ7zBXeI1Z4j1ThPXKF9yivf48yVXgPV+E9fIX3UPicu/WuLs6VsvEeUuE95grvkV/fG5Ty+vfY+c2P9pu4Gm8iNd5krvEmscabpBpv8tqPyeUf4e3Q7Le/ppfWl6bs7r+NTMuQxB8cmte1zO1N495+dvBfP/Sffvv7fO0Pe/uLfx2M23U6bt/puEOn45ZOxz13Ou7Y6bhTp+Pu9HLpOr1e+k6vl77T66Xv9HrpO71e+k6vl/5l18vP8z99XVvvCC2zbJw/vfj8+cXnL689f5hefP6n/z7mBWbJYeP8/sXnDy8+v7z4/M9+fudpvQfJlDfOH198/vTi8+cXn7+89vzyLJ+zXy4As986v7z4/M/mG8N6X4vZb5w/v/b884vrMz/9+ZWVnzltnD+++PzpxefPLz5/ee354/Ti87sXn9+/+PzhxeeXF59f8fMb48b544vP//znd/37lrbO//Tnd/37vH3+8trzp+nF53/28xun9X5iU9k4v3/x+cOLzy8vPv/84vM//fkty3cW4s0TNq7nTy8+f37x+ctrz5+nF5/fvfj8/sXnDy8+v7z4/LPi+Tc+vzm++PzPf36X74xHv3X+pz+/q0DcPn957fnL9OLzP339vd8/Fv/i84cXn19efP75xeePLz7/i/1GeZ3fuPxD3g7MZecWX1HWr0vGeHQjC3HrRoP4bxMpe7em+tl73D409eBgvZtwlL37WPUx9tDx2KXjsc8djz12PPbU8dhzx2Mv/Y59535hfYy94+uq7/i66ju+rvqOr6u+4+uq7/i66ju+rvpWrqufw6l8qdS7XU3Zu+NbH2N3HY/ddzz20PHYpeOxzx2PPXY89tTx2HPHY+/4uiodX1el4+uqdHxdlY6vq9LxdVU6vq5KK9fVz+G0cqn8HE4rV7/P4bRyQfsYztzKNepzOK1cdj6H08qV5HM4rVwcPofTyt/7z+G08if8cziVP+gHd5ose3f+PHFAlXE+uLNL2bvf54kVSq0NKDc2oORqD+juvT3L3j1KTxxQaG1A0tqA5tYGVP3v0N0bWZa9m7CeOKDc2oBKYwPKU2sDcq0NyLc2oNDagKS1Ac2tDaj2X+r7tzste7fRPXFAubUBlcYGVKbWBuRaG5BvbUChtQFJawOq/Zf6/r2Ny86PRs4cUGpsQHt3TT7Px+zdYvnMEfnmRtSaRdu70/OZI0rNjSg3N6LS2ohcQ3+PLv+Y3w6Vee9R5NGtqjK6ct0QuAxhc2D++ts6uf4I+u2nf99PPa2/N/bXOVwYeqvU+4icxojiqlolpYMRrQYrTdPmiDb/TsZw/eWuTO5gRMUtcZR4HY+bN2+KOK9K7bZPS5sbN7Nfd27m299avt158fvRecVtCjcGOq1TDeNMVcaZ6jzOVOM4U03jTDWPM9UyzFS3f6thc6punKmOs1oK46yWgsJqyU1yswNRDiYbw3rn7hjk6NxpPTjdfIHJxbBOYO59ArH3CaTeJ5B7n0DpfAIy9T4B1/sEfO8TCL1PoPcrsfR+JZber8TS+5VYer8SS+9X4rn3K/Hc+5V47v1KPPd+JZ57vxLPvV+J596vxHPvV+K59yvx3PuVOPZ+JY69X4lj71fi2PuVOPZ+JY69X4lj71fi2PuVOPZ+JY69X4lT71fi1PuVOPV+JU69X4lT71fi1PuVOPV+JU69X4lT71fi1PuVOPd+Jc69X4lz71fi3PuVOPd+Jc69X4lz71fi3PuVOPd+Jc69X4lL71fi0vuVuPR+JS69X4lL71fi0vuVuPR+JS69X4lL71fi0vuVeOeWGF3NoPdr8c4tN7qaQe9X48ubdz+D3q/HO7dV6WoGvV+Rd27b0tUMur8mu+6vya77a7Lr/prsur8mu+6vya77a7Lr/prsur8mu+6vya77a7Lv/prsu78m++6vyb77a7LGDdJOnkH312Tf/TXZd39N9t1fk3331+TQ/TU5dH9NDt1fk0P31+Tub8Plur8Pl+v+Rlyu+ztxue5vxeW6vxeX6/5mXK77u3G57m/H5bq/H5fr/oZcrvs7crnub8nlur8nl+v+plyu+7tyue5vy+W6vy+X6/7GXK77O3O57m/N5bq/N5fr/uZcrvu7c7nub8/lur8/l+v+Bl2u+zt0ue5v0eW6v0eX6/4mXa77u3S57m/T5bq/T5fr/kZdrvs7dbnub9Xlur9Xl+v+Zl2u+7t1ue5v1+W6v1+X6/6GXa77O3a57m/Z5bq/Z5fr/qZdrvu7drnub9vlur9vl+v+xl2u+zt3ue5v3eW6v3eX6/7mXa77u3e57m/f5bq/f5fr/gZervs7eLnub+Hlur+Hl+v+Jl7ugbt4ufloBvO8Pqp7ztOX9/l+tL/sn34e7d3N0W8PBP9+6hLccupyU5zNg2NeZ3tbGbf1dHGJy3kl+y/HrpXJY1Ym5AXHecrblSlUZrMy/oH7mY1aGUdldirjqcxOZQKV2amMUJmdysxUZqcykcrsVGbQNfADlWENvFcZ1sA7lXGsgfcqY2kNnMJaGf98ZU5YA4uslSnz/cn6ME3LweGL0HHXKYT+pyD9T2Hufwqx/ymk/qeQ+59C6X4Kfup/Cq7/KfR/dfb9X50fuPdh81Po/+rs+786+/6vzr7/q7Pv/+oc+r86h/6vzqH/q3No/bpwPTjEeXsKrV8XHphC43+RRBY95SXGzSlI43+RHplC43+RHplC43+RHplC4/2ClLQcPIf0ZQob/jW4Zdgh+JtvmEm8TlhGm3Dj1xz9CTd+hdKfcON9jv6EG++K9Cfc+opFe8Jz6+ubn004hHXCErcn3PpqSH3Cra+d1Cdsa6X1wIRltAnbWmk9MGFbK60HJmxrpbX+NCSEJNsTtrXSemDCtlZaxxOOtlZaD0zY1krrgQnbWmk9MGFbK60HJixWJ3z7k8XbCdtaaT0wYVsrrQcmbGqlJdelpewsLaOpldYjEza10npgwsnUSuuRCZtaaT0yYVMrrUcmbGql9ciExdSE5/U6LHF7aZlMrbQembCpldYjE7a10npgwrZWWg9M2NZK63jC2dZK64EJ21pppbJOuGy3h9nWSuuBCdtaaT0wYRltwrZWWg9M2NZK64EJ21ppPTBhWyut64TnadqesK2V1vGEi62V1gMTNrXSmq9Ly3lnaVlMrbQembCpldYjE5bRJmxqpfXIhE2ttB6ZsKmV1iMTNrXSmuP1OryzP1xMrbSOJxwmUyutRyZsa6X1wIRtrbQemLCtldYDE5bRJmxrpbUeHaKbtidsa6X1wIRtrbQemLCtldYDE7a10jqesLO10npgwrZWWg9M2NZK63bCeXvCtlZaD0xYRpuwqZVWjNcJ553PsKmV1iMTNrXSemTCplZaj0zY1ErrgQm3ftdb/QmbWmk9MmFTK62Y53XCpWxP2NRK65EJy2gTtrXSemDCtlZaD0zY1krrgQnbWmk9MGFTK63kllOH5Lfbw9bvYKw/YVMrrUcmbGql9ciETa20HpmwjDZhUyutRyZsaqV1O+EQtydsaqX1yIRNrbQemHDrt6Y5vl18aP1mM49Mofub9ofWbwjzyBRa//BP19vFT2V7Cq03TsdTaP42LA9MofXm5oEptN6uPDCF1huQB6bQ+tU5Xx+pU/L2FFq/Oj8whdavzg9MofWr8wNTaP1Raw9MofVHrR1PofVbdzwyhdYftfbAFFp/1NoDU2j9QagPTKH/q3PrN7V4ZAr9X51bv/HEI1Po/+rc+s0hHphC67d7eGQK/V+dW78lwyNT6P/q3PptE+5N4fKv+Hbs7NKft791Ks5/vlrexrK82Mnb/N9etv3dzeOXud+9zP/uZeGHL7v8K70d6fw0/Xnzwu/jkq9PN1JlSu8vzh8vDv7P21/In9PiZGK8+cmk8++vLh+vlvLn7Z/kyErL7NzNq6e3+X68zv/ydeGXr5Nfvm7+5eviL1+3uQK6ILK8bs5fXrfxUZ3SEryb8vXD5yd3fZdc5V1KjXfZ/nyrv4ur8i6+yruEKu8iz79LmdZ3ufmC3Jd3mau8S6zyLqnKu+Qq71JqvEuYqrzL8599t34B4XIJDdvv4qu8S6jyLlLlXeYq7xKrvEuq8i5Z9V2C236XUuNdZKryLgqf/fn6LnE7F/FV3iVUeRep8i5zlXeJVd4lvfRdLv96u1PEf/0pzDn9ed5eMV1009pq3sgAVy6vv/zz//2X//jLv/zrX//9Py8vefu//p+//ds//vL3v33+8x//3//++L9cDv7/AQ=="},{"name":"initialize","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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muWmq6xabrrKquWmq6xabrrKquWmq6xZ7khXWbXcdJVVy01XWbXcdJVVyy2Uu2a56Sqrlpuusmq56Sqrlpuusmq56SprljvRVVYtN11l1XLTVVYtN11l1XIL5a5ZbrrKquWmq6xabrrKquWmq6xabrrKmuWe6Sqrlpuusmq56Sqrlpuusmq5hXLXLDddZdVy01VWLTddZdVy01VWLTddZc1yZ7rKquWmq6xabrrKquWmq6xabqHcNctNV1m13HSVVctNV1m13HSVVctNV1mz3IWusmq56Sqrlpuusmq56Sqrllsod81y01VWLTddZdVy01VWLTddZdVy01VWLHeZ6Cqrlpuusmq56Sqrlpuusmq5hXLXLDddZdVy01VWLTddZdVy01VWLTddZc1yO7rKquWmq6xabrrKquWmq6xabqHcNctNV1m13HSVVctNV1m13HSVVctNV1mz3J6usmq56Sqrlpuusmq56Sqrllsod81y01VWLTddZdVy01VWLTddZdVy01XWLHegq6xabrrKquWmq6xabrrKquUWyl2z3HSVVctNV1m13HSVVctNV1m13HSVNcstdJVVy01XWbXcdJVVy01XWbXcQrlrlpuusmq56Sqrlpuusmq56Sqrlpuusma5I11l1XLTVVYtN11l1XLTVVYtt1DumuWmq6xabrrKquWmq6xabrrKquWmq6xZ7kRXWbXcdJVVy01XWbXcdJVVyy2Uu2a56Sqrlpuusmq56Sqrlpuusmq56Sprlnumq6xabrrKquWmq6xabrrKquUWyl2z3HSVVctNV1m13HSVVctNV1m13HSVNcud6Sqrlpuusmq56Sqrlpuusmq5hXLXLDddZdVy01VWLTddZdVy01VWLTddZc1yF7rKquWmq6xabrrKquWmq6xabqHcNctNV1m13HSVVctNV1m13HSVVctNV1mv3DJNdJVVy01XWbXcdJVVy01XWbXcQrlrlpuusmq56Sqrlpuusmq56Sqrlpuusma5HV1l1XLTVVYtN11l1XLTVVYtt1DumuWmq6xabrrKquWmq6xabrrKquWmq6xZbk9XWbXcdJVVy01XWbXcdJVVyy2Uu2a56Sqrlpuusmq56SqrlnvErlLitdy53D+4hOnXsSX59VCfl/oZaROjn9f6RX+Ea56Xt778d75ilcNmNs4to778t/jbw9+LGIw0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"},{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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x3PvjufeHc+9O557dzz37nDu3RKce7cE594twbl3S3Du3RKce7cE594twbl3S3Du3RKce7eE596C596C596C596C596C596C596C596C596C596C594Zz70znntnPPfOeO6d8dw747l3xnPvjOfeGc+9M557Fzz3LnjuXfDcu+C5d8Fz74Ln3gXPvQueexc89y547q147q147q147q147q147q147q147q147q147q147m147m147m147m147m147m147m147m147m147m147l3x3LviuXfFc++K594Vz70rnntXPPeueO5d8dy74rl3w3PvhufeDc+9G557Nzz3bnju3fDcu+G5d8Nz74bn3nh3LRveXcuGd9ey4d21bHh3LRveXcuGd9ey4d21bHh3LRveXcuGd9ey4d21bHh3LRveXcuGd9ey4d21bHh3LRveXcuGd9ey4d21dLy7lo5319Lx7lo63l1LT3Du7Xh3LR3vrqXj3bV0vLuWjnfX0vHuWjreXUvHu2vpeHctHe+upePdtXS8u5aOd9fS8e5aOt5dS8e7a+l4dy0d766l4921dLy7lo5319Lx7lo63l1Lx7tr6Xh3LR3vrqXj3bV0vLuWjnfX0vHuWjreXUvHu2vpb3CL0OxR0qtM/3tJb3CLcFjSZ++4nh8l9WInJSleSYZXUsUrqeGV9DvnpZdVp9ZR1V9W1Sonq84vKw1Xnf53bO2osHk6W9UGq3o/WXV+k2K4SqZWnU4Xbscqb+VsVZlapVOrbGrV6X+v21vh+yo9W9WmVvnUqj6z6vx72sNVMrUqT60qU6t0apVNrZo6G23qbLSps9GmzoZPnQ2fOhs+dTZ86mz41NnwqbPhU2fDp86GT50Nnzobfeps9Kmz0afORp86G33qbPSps9GnzkafOht96mz0mbPRU5paJVOr8tSqMrVKp1bZ1Ko6tapNrfKpVVNnQ6bOhkydDZk6GzJ1NmTqbMjU2ZCpsyFTZ0Omzsb5R3su8slV55++DVflqVWnP8PajjeWtaezVX1m1fnvpZscfzN8K6M3yLdPlA81pd6ftWN/Cd4/B+9fgvfX4P0teP8avH8L3t+D9++x+2tw/2pw/2pw/2pw/2pw/57/mrelw9WbnhHk/Dexw1U+tarPrDrPvxqukqlVeWrV5/9Iy+vjV8fpQevjV8f9DSKMhiU1vJIc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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Counter::increment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::increment_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Counter::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::initialize_parameters","fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"counters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}]}},"file_map":{"2":{"source":"use crate::cmp::Ord;\nuse crate::option::Option;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n","path":"std/array.nr"},"5":{"source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"61":{"source":"\n\ncontract Counter {\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n    \n    #[aztec(storage)]\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>\n    }\n\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n\n    #[aztec(private)]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        dep::aztec::oracle::debug_log::debug_log_format(\"Incrementing counter for owner {0}\", [owner.to_field()]);\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n\n\n}","path":"/Users/satyam/web3/noir/sample-counter-2024/contracts/counter/src/main.nr"},"66":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"67":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"69":{"source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"72":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"81":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"83":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"88":{"source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        /// 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        /// the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        /// implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        /// 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr"},"89":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"90":{"source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"91":{"source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr"},"93":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"107":{"source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr"},"108":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"110":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"112":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<let N: u32>(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<let N: u32>(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"114":{"source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\npub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"118":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"119":{"source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"122":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage,\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, public_data_tree_index: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"123":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"128":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result = pk.x.to_be_bytes(32);\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result.as_array()\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"133":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_data_tree_index\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"138":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/initializer.nr"},"139":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash,\n    hash::{\n    pedersen_hash, compute_siloed_nullifier, sha256_to_field, pedersen_commitment,\n    poseidon2_hash_with_separator\n}\n};\n// Note: pedersen_commitment is used only as a re-export here\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"141":{"source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr"},"143":{"source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"},"145":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"146":{"source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr"},"154":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"163":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"166":{"source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N, M> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N, M> + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N, M> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"201":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"245":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"257":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"271":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"272":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"273":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"275":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"279":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"280":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"282":{"source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"283":{"source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"287":{"source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"288":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"289":{"source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"301":{"source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n    keys::getters::get_current_public_keys\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl<Context> EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_keys.npk_m.hash());\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_keys.npk_m.hash());\n        self.set.insert(&mut result_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr"},"303":{"source":"use dep::aztec::{\n    context::UnconstrainedContext, state_vars::PrivateSet,\n    note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions}\n};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote, UnconstrainedContext>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/value-note/src/balance_utils.nr"},"306":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/Users/satyam/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.50.1/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}