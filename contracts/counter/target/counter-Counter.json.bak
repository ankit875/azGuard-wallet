{"noir_version":"0.33.0+61d6f251ea67204af2d17175f120e17f2e9e9156","name":"Counter","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"7L3fjuTKl533Lr9rXTCCm2RQr2IYhmzLwgCCZEjylaB3d52uTmb14Z/o0xWZezH2NxeDMwN2dexvVTPWWswM/s9//d//8f/8//7T//Fv/+X/+a///V///n/7n//6z//1//oP/+Pf/ut/+fi//uf/+nf/+j//27/95//8b//p//j6//7X8Nf/yuXH9f/9//0P/+Wv//O//4//8N/+x7/+/TQs/+5f//G//N8f/1XSx5//f/7tP//Hf/372f7X//7v/pXXf/onxnz0J5Z1/fknSln+/ifGf/wn5qM/kVJ6/JGP/5r+/meWf/5nbDj8M2bl8WdsGv/+Z9If/Jn8B39m/IM/Y3/wZ6Y/+DPzH/yZ5Q/+TPmDP7P+8z8z/cHvwfQHvwfTH/weTH/wezD9we/B9Ae/B9Mf/B5Mf/B7MP3B78H0B78H8x/8Hsx/8Hsw/8HvwfwHvwfzH/wezH/wezD/we/B/Ae/B/Mf/B7Mf/B7sPzB78HyB78Hyx/8Hix/8Huw/MHvwfIHvwfLH/weLH/we7D8we/B8ge/B+UPfg/KH/welD/4PSh/8HtQ/uD3oPzB70H5g9+D8ge/B+UPfg/KH/werH/we7D+we/B+ge/B+sf/B6sf/B7sP7B78H6B78H6x/8Hqx/8Huw/sHvQRqGP/lDf/CbkNIxhpymxx8a11+i2b/bXTynKf28eE7r829Y5oOLUyrz4yfnwbaL88/lFK3lrFLLyYPWcpLWcrLWckat5ZjWciat5cxay9G6K2etu3LWuiuPWnflUeuuPGrdlUetu/KodVce3/wPfVqeDwDW52LK9LmaVWk19uZf5HkYHtcO8341o9RqTGo1k9RqZqnVtHAW45fVWOWGY9tzsfn5+G0c0+dqitRqVqXVTIPUapLUarLUakap1dibVzPmbTXll9Xsr81zfiw9z9PzB4/DenC1jdugNi7Dc8354OJletRcS9n5mmmCyY7JDJMdkwUmOyYFJjsmaz9MVnswsSF/ZfLXoPMQZdDUzaC2LePjP5fdoLmjQYdtUJt3g45RBrU3D1oeg+Zh2NnPeZJazSy1mkVqNUVqNavSapZBajVv3pxyHh+rsbRfTZZazSi1GpNazSS1mllqNYvUal56L/7xN6yv/hvK8PK/Ib38b8gv/xvGl/8N9vK/YXr53zC//G9YXv43vPzfdHn5v+n15f+m15f/m15f/m96ffm/6fXl/6bXl/+bXl/+b3p9+b/p9eX/ptdX/5vOw/DyvyG9/G9o8G86Px+Uf/y5Sj67/NxMHkat5ZjWciat5cxay1m0llO0lrNKLSc1uHeO+fFkaR6nUlnOWraieEi/5saDoniaHiHTpi8l9GdRnFPSXrxdLj6/e/FLei7eaov/mO+x+OFLoZ+Xw0eLj88ZLl+OPcjj4c99rNhy5dKyPCrEUsrX39t//ks+gvpdqA3U70I9gfpdqGdQvwv1Aup3oS6g/nLpDyRrSCRfXLb9HUkeQPJ3JAkkf0cSM81cIomZOi6RWEgk22dhrIw7JDFd/CWSmG77EklMV3yJJKR7/XLC6FB2SEK610skY0j3eo0kpHu9RhLSvV4jCelLpvwoTKa8RxLSl1wjCbnjzOPjMeA85b8jsZA7zjUS7R0njY8xLS3TVyQ/Fq+9N1QWr91BVBZvd1689v5ZWbz2TldZvHZWrixeO9VWFq/tBp6fwDxa/KS9b6c0Phc/7xYvvsNeL158h71e/Jt32I/nuGVbfMlOds/leXWLg4BA/XuoJ1C/C/UM6nehXkD9LtQF1O9CvYL6y6V/IZmHkEiuPnoxJ5D8HUkGyd+RxEwzl0gMJH9HEjMdXH0aZY7p4i+RxHTbl0hiuuJLJCHd6+VHL5aQ7vUaSUj3eo0kpHu9RhLSvV4jCbkJX35maQm5CV8iKSFvr5efWSohb6/XSLRvr9efTWhxiKDf4rUDd2Xx2tG4snjt/bOyeO2drrJ47WB4vfhVO8JVFq/tBq4/xrVq79vXHyZaxXfY68WL77DXi3/3DpvSw49//B2Dk91zeV69zqB+F+oF1O9CXUD9LtQrqN+DehwGUL8LdQL1l0t/IMkhkVx89GIcRpD8HYmB5O9IYqaZSyQxU8clkpjp4OLTKOMQ08VfIonptq+QpJiu+BJJSPd69dGLMYV0r9dIQrrXayQGkr8jCeler5GE3ISvPrM05pCb8DWSkLfXq88sjTnk7fUaifbt9fKzCWPWjvGVxWsH7sritaNxZfHa++f14kftna6yeO1gWFm8doSrLF7bDVx+jGsctfftyw8TjaP4Dnu9ePEd9nrxb99hl+0zaPnLA8wAz6vHAup3oV5B/SbUNoD6XagTqN+FOoP6XahHUH+59AcSC4nk6qMXNoHk70hmkPwdScw0c4kkZuq4RBIzHVx9GmWK6eIvkcR025dIYrriSyQh3evlRy/efur8DZCEdK/XSEK612skId3rJZI55CZ8+ZmlOeQmfI0k5O318jNLc8jb6zUS7dvr9WcTZu0YX1m8duC+XvyiHY0ri9fePyuL197pKovXDoaVxdudF6/tBq4/xrVo79vXHyZaxHfY68WL77DXi3/3Djttv8V5LrXPoI3JHlePqSzPxecfiy/DnRef7rz4fOfFj3devN158dOdFz/fefHLnRdf7rz4O++w65132PXOO+x65x12vfMO+/bTdZsu/s477HrnHXa98w673nmHXW+8w9pw4x3WhhvvsDbceIe14cY7rA033mFtuPEOa8ONd1gbbrzD2nDjHdaGO++w6c47bLrzDpvuvMOmO++wbz/rruni77zDpjvvsOnOO2y68w6b7rzD5jvvsPnOO2y+8w6b77zDvv24w6aLv/MOm++8w+Y777D5zjtsvvMOO955hx3vvMOOd95hxzvvsG8/mLDp4u+8w4533mHHO++w45132PHOO6zdeYe1O++wducd1u68w779uLCmi7/zDmt33mHtzjus3XmHtTvvsNOdd9jpzjvsdOcddrrzDvv2I42aLv7OO+x05x12uvMOO915h53uvMPOd95h5zvvsPOdd9j5zjvsfOcddr7zDjvfeYed77zDznfeYec777DLnXfY5c477HLnHXa58w779jOdmi7+zjvscucddrnzDrvceYe985lOducznezOZzrZnc90sjuf6WR3PtPJ7nymk935TCe785lOducznezOZzrZnc90MvEznXJ6HDA75jHtFq+9w1YWr73DVhavvcNWFq+9w1YWr73DVhavvcNWFt9ih10f65nNpuvFp3VbTlrLul2c/vrv/dVDSo/XY33895e3Lvx1/Y/1r7de/9TkZCfP9aebrz/ffP3jzddvN1//dPP1zzdf/3Lz9d97/52Gm++/SX3/ncpz/UuqXV+Wbd1lfS5lzJ/Dqm/WTYdV39mbDqtuA5oOa5GGVTcYTYdVdyNNh1W3Lk2HVfc5TYdVN0Uth82RHFSO5KByJAeVIzmoJueS3WbYSA4qR3JQOZKDypEcVI7koMZIDmqM5KDGSA5qjOSgmpw7d5thIzmoMZKDGiM5qDGSgxojOSiL5KAskoOySA7KIjko62qfzWkef17+8Z+2G7arfbY2bFf7bG3Y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9+6mo21P3L4s5njpaRjLuC3D7PmjU1mPrk95W3X66uweo05xRp3jjLrEGbXEGXUNM+qbT/hxHTXFGTXHGXWMM6rFGTWOW7I4bsniuCWL45YsjluaenJL6/Y1oLSu+1F7ckuVUXtyS5VRe3JLlVEtzqg9uaXKqD25pcqoPbml56i/fPvjMWpPbqkyakduKQ/rNmpadqPOHbml2qgduaXaqB25pdqoHbml2qgWZ9SO3FJt1I7c0tdRc96P2pVbGp6jjrtRl4721Y8f87h8tGE/akf7am3UjvbV2qgd7au1UTvaV2ujdrSv1kbtaF+tjdrRvjratI06HeyrHbUQtVE7aiEqo5ae3FJl1J7cUmXUntxSZdSe3NL1qG8+Eu/5Jc15yJVRx2SPXndM5UvUzj+XPt936ct9l17uu/T1rksf33xYV9Olp/suPd936eN9l273Xfptd9NxuO1uOg633U3H4ba76TjcdzdN991N031303Tf3TTddzdN991N031303Tf3TTddzdN991N031303zf3TTfdzfN991N83130zcfRtR06ffdTfN9d9N8390033c3zffdTcf77qbjfXfT8b676Xjf3fTNhxE1XbrwbprT4+IPq5X2SxfeTWtLF95Na0sX3k1rSxfeTStLN+HdtLZ04d20tnTh3TSP22F6+cvLOLelC++mtaUL76a1pSvvppWlK++mlaUr76aVpSvvppWlK++m87QtfVl3S5+Ud9PK0pV308rSlXfTytKVd9PK0pV308rSlXfTytKVd9MvSz9oBCbl3bSydOXdtLL09+6mc3rs7fOXrf3so/rbxWmwX5a+v9hs+1KY2cE/jDef7OE3ZwoyZw4y5xhkTgsy59TLnOvzPb7Dfl958zkefnMuQeYsQebsxg9dz7l044cqczbwQ9vxeLPZdD1nWrdmP63lefs/+XLpkNJ2lMGQvrwy76/rP9efb77+8ebrt5uvf7r5+uebr3+5+frLzde/3nv9Lc4CcV3/zfffcvP9t4jvv1N5rn9JtevLsh3GUb6se/xp9or4Zt12WPGdve2w4jag7bDinqHtsOIGo+2w4m6k6bCruHVpO6y4z2k7rLgpajtsJAe1WqRhIzmoNZKDWiM5qDWSg1oDOSgbAjkoGwI5KBsCOSgbAjkoGyzSsIEclA2BHJQNgRyUDYEclA2RHFSK5KBSJAeVIjmoFMlBtThx8T7DRnJQqad9Nqf58cnDj/+0/bA97bO1YXNP+2x12J722eqwPe2z1WF72merw/a0z1aH7WmfrQ7bU1NRHbanpqI6bCQHlSM5qDGSgxojOagxkoMaIzmoFudv3mfYSA5qjOSgxkgOaozkoMZIDsoiOSiL5KAskoOySA6qxZmr9xk2koOySA7KIjmoSXvryV++Epuz/XL95/q1d5P6+rVvI3n5sv4yf+v6z3m17yTt59W+mbSfVzuRtZ9XO5Q1n3fWzmXt5xXfH5vPK76fNp9XO6C1n9eCzRvMX83B/NUczF/NwfzVHMxfLcH8lfiRnu3nDeavxI8MbT+vBZu3J3+V87aUPKZntfooS8XPL208bE/OKudleA6bd8OKn8z5D4edxsdP//jPsh+2pz23OmxPG2512J522+qwPW211WG72mdrw3a1z9aG7WqfrQ3bU31RHban7qI2rPgBoY2HjeSgxM/MbDysRRo2kqkQP1nxHw5byhbe12H4Ouz+4tHS9tpQs334FT+G0Y/MJH5moyeZrnbApmS6KhyakunKSDQlY5A5IdOVRWlKpquSpCmZrhqVlmTEDxV8IZmS7ee1JZc9l7B7doVL2My0bste92ffTeLHwblxET9f7IVc0pCG588e92TCet8qGYPMCZmw3rdKJqz3rZIJ632rZMJ6mSqZsG6mRkb8HDdPMmGTZJVMYA+8PM4aSCnv2wfx4+Q8yRhkTsgE9sAVMoE9cIVMYA9cIRPYA1fIBPbA12TET+LzJBPYA1fI4IHPyOCBz8gYZE7I4IHPyOCBz8jggc/I4IHPyOCBT8hMcT1wzhuZrwdYbmTieuAambgeuEYmrgeukTHInJCJ64FrZOJ64BqZuB64RiauB66RieuBK2S6Ovm3LRk88BkZPPAZGTzwGRmDzAkZPPAZGTzwCZmuzpP9h2SmJ5lp2ZMJvGtXyAS+Az9/di5pTybwHbhCJvAduEImcAtRIRO4haiQCdxCXJPp66DepmQC+5kKmcAtRIVM4BaiQsYgc0IGD3xGBg98RgYPfEYmiAf+HDaIrf0xbF8HIteGDWI+P4cN4ic/hw1iET+HtUjDBjFyn8MG8WafwwaxW5/DRnJQUY7q/mvYOcrp25/DdrX1rPO8DbscDNvV1lMbtqsb1MeP/Hn5OAx5P2xXN6jKsKmrG1Rt2K4iXm3YriJebdiuIl5t2L722cqwfe2zlWG7ini1YXuKeMtjIcu0H7Qn93Q5aE/O6WrQ3JNruhy0J8d0OWhPbuly0J6c0uWgFmXQnhzS5aA9uaPLQaM4o66O7b4atKtTuC8HjWIYujoj+3LQngzD+Pyu2ZjHeT+sRRq2J+NQHbYn81AdticDUR22p3qlOmxPjqk2bFcnzY55Ktuw874O7erw2OqwXd2gxrQNO457B9XVcZ3VYbu6QVWG7epQzeqwPUW76rA9xbvqsF3ts7Vhu9pna8N2FfFqw3YV8WrD9uWgyvOl78PBsH05qMqwfTmo62G7OpKxOmxfDqoybFcOytJzWNvn2a7OQqwOa5GG7cpB1YbtykHVhu3KQdWG7cpB1YbtykFVhu3qeMzqsF05qNqwkRzUEslBdXU8aXXYSA6qq0NEq8NGclBdHfVZHTaSg+rqQM7qsJEcVFfHZlaHjeSgujrcsjpsJAfV1RGU1WG/76Bsscewk83Xw+ahPC7OOZfqsCk9h01T/uX6z/WXm69/vff6G5zQ6Lv+dPP155uvf7z5+u3m659uvv755uu/+f673nz/XcX33+1T7B//vaTa9WV5mL2PC3afiFgG8c267bDiO3vbYcVtQNthxT1D22Et0rDibqTtsOLWpe2w4j6n7bDipqjtsJEcVIrkoFIkB5UiOagUyUE1OK30RsNGclApkoNKkRxUiuSgUiQHlSM5qBzJQeVIDipHclANTjK90bCRHFSO5KByJAeVIzmoHMlBjZEc1BjJQTU4/FNn2Jzmx9l6H/9p+2F72merw/a0z1aH7WmfrQ7b0z5bHbanfbY2rPW0z1aH7WmfrQ7bU1NRHbanpqI6rEUaNpKDskgOyiI5KIvkoCySg5oiOagpkoOaIjmoKZKDanA68Y2GjeSgpkgOaorkoKZIDmqK5KDmSA5qjuSg5kgOao7koGbtrSd/+UpszvbL9Z/r195NqutftG8j/+z8luvrP+fVvpO0n1f7ZtJ+Xgs2r3Yoaz+vdi5rP6/4/th8XvH9tPm82gGt+bxFO6O1nzeYvyrB/FUJ5q8anOR5r3mD+asSzF+JH+nZft5g/kr8yNDm84ofMdp+3p78Vc7bUch5TM9q9VGWip9f2njYnpxVzsvwHDbvh+1p283T+Fj3x3+W/bA97bnVYXvacKvD9rTbVoYt4geENh62q322NmxX+2xt2K722dqwFmnYnrqL6rCBHFQRPyC08bCRTIX4mZmNh41kKsRPVvyHw37M8/jp6zB8HXZ/ceW1SkX8GEZPMl1tak3JdLUDNiXTVeHQlExXRqIlGfFzJj3JdGVRmpLpqiRpSqarRqUpmbC7dsmPlZS8zwbi5w+6cRE/4+2FXNbt4ei6P/uuiB8H58cl7L+jNKTh+bPHPZmw3rdGRvzkMk8yYb1vlUxY71slE9b7VskYZE7IhHUzVTJh+98qmbBJskomsAdeHmcNpJT37YP4cXKOZMTPnvMkE9gDV8gE9sAVMoE9cIWMQeaETGAPXCET2ANXyAT2wBUyeOAzMnjgEzLipwd6ksEDn5HBA5+RwQOfkTHInJDBA5+RieuBc97IfD3AciMT1wPXyMT1wDUycT1whcwS1wPXyMT1wDUycT1wjUxcD1wjY5A5IRPXA9fI4IHPyOCBz8jggc/I4IFPyHR1QnFbMnjgMzJ44DMygXft6UlmWvZkAu/a12S6OsP0H5J5/uxc0p5M4DtwhUzgO3CFTOAWokLGIHNCJnALUSET2M9UyAT2MxUygVuICpnALcQlmbWvw4WbksEDn5HBA5+RwQOfkbEYZD6HDWJrP4cN4lQ/hw1iPj+HDeInP4cNYhF/DNvX6c+1YYMYuc9hg3izz2GD2K3PYS3SsJEcVJTTt38M29cRwOs8b8MuB8N2tfXUhu3qBrWW9efl4zDk/bBd3aBqw3Z1g6oN21XEqw3bVcSrDdtVxKsMO/a1z1aG7WufrQzbVcSrDdtTxFsezniZ9oNalEF7ck6Xg/bkmi4H7ckxXQ7ak1u6HLQnp3Q1aFeHsl8O2pNDuhy0J3d0OWgUZ9TVsd2Xg0YxDF0dqn05aBTD0NWR1+Pzu2ZjHufdsF2dYl0dtifjUB22J/NQHbYnA1Ed1iIN25Njqg7b19YzlW3YeV+HdnV4bHXYrm5QY9qGHce9g+rquM7qsF3doGrD9hTrqsP2FO2qw/YU76rDdrXPVobt6oDK6rBdRbzasF1FvNqwfTmo8nzp+3AwrEUati8HVRm2LwdVGbYvB1UZtisHZek5rO3zbFdnIdaG7ep4w+qwXTmo2rBdOajasF05qNqwFmnYrhxUbdiuHFRt2K4cVG3YSA6qRHJQXR1PWh02koPq6hDR6rCRHFRXR31Wh43koLo6kLM6bCQH1dWxmdVh4ziodejqcMvqsHEc1MewcRzUx7CvvEF9/g3rq/+Gl5449vk3pJf/Dfnlf8P48r/Bvv03zMPjGJh5Nqv8w5m3bw3kZXguZzw8RHRatn8I0zJN1z/6Y6XDY9EpD5WL82MZaRp+WcUnlQkqB1RmqBxQWaByQKVA5YDKCpU9lQZHwPVIJUHlgEqGygGVESoHVAwqB1TwtkdU8LZHVPC2R1TwtkdU8LYHVEa87REVvO0RFbztERW87REVg8oBFbztERW87REVvO0RFbztERW87QEVw9seUcHbHlHB2x5RwdseUTGoHFDB2x5RwdseUcHbHlHB2x5RwdseUJnwtkdU8LZHVPC2R1TwtkdUDCoHVPC2R1TwtkdU8LZHVPC2R1TwtgdUZrztERW87REVvO0RFbztERWDygEVvO0RFbztERW87REVvO0RFbztAZUFb3tEBW97RAVve0QFb3tExaByQAVve0QFb3tEBW97RAVve0QFb3tApeBtj6jgbY+o4G2PqOBtj6gYVA6o4G2PqOBtj6jgbY+o4G2PqOBtD6iseNsjKnjbIyp42yMqeNsjKgaVAyp42yMqeNsjKnjbIyp42yMqeNs9lTTgbY+o4G2PqOBtj6jgbY+oGFQOqOBtj6jgbY+o4G2PqOBtj6jgbQ+oJLztERW87REVvO0RFbztERWDygEVvO0RFbztERW87REVvO0RFbztARXeS3ZIBW97RAVve0QFb3tExaByQAVve0QFb3tEBW97RAVve0QFb3tAhfeSHVLB2x5RwdseUcHbHlExqBxQwdseUcHbHlHB2x5RwdseUcHbHlDhvWSHVPC2R1TwtkdU8LZHVAwqB1TwtkdU8LZHVPC2R1TwtkdU8LYHVHgv2SEVvO0RFbztERW87REVg8oBlZjeNttjzeMwVVZhQ3qs2YbpOWBeDi5epge5paTnpePhzy2PH5srl5Yl/7y0lPK89EiOlMpjtA8K9vXiT8Fj2vbAgsdMJIEFjxm2AgseM0fGFTzo6w0DCx4z/UsL/ilMzAJCQphpfPzYrz/1IUzMDuQGwhjCaApDEyQqDI2NmzDlYeGsjHthaFZEhaEBERWGpkJTmKAvlVUQZtogT0PZC0PyFxWG5C8qDMlfVBhDGE1hsMtuwuTHGqZ8IAx2WVOYoO8eVRBmHtcHtynvhWHzFxXGEKYmTBofNCwt01dhPhFS0H8bIVX6txFSen8bIX772whxxt9FGPR9tE0RUs5+GyFJ6jcQpkuEZJ46wjQ+Ec57hAbC7yIknXwbYcx0Mtr2Cdultoo0jGXccJg9q7kPS3h0fcobvfS1wXggj5lmXJHHTD+uyGOmJUfkOegbkV2Rx0xjrshjpjdX5DHTnityA/m7kcdMk67ISZ9vR076fDty0ufbkZM+34086DvLXZGTPt+OnPTZHvm6HRf4URvukZM+347cQP5u5KTPtyMnfb4dOenz7chJn29HTvp8JfJfTqv7iTyTPt+OnPTZHPlHcbUhT8seOenz7chJn29HbiB/N3LS59uRkz7fjpz0+XbkpM+XIs95j5z0+YIoNDyRjzvkI768OfKPH/O4fLRhjxxf/nbkBvJ3I8eXvx05vvztyPHlb0eOL387cnx5e+Q2bcinvS83ngq9HTlPhd6OnPT5duSkz7cjN5C/Gznp893Ig745+XlY+DzkyirGZI81j6l8eeSQfyKMGW2aIowZVVoiDPq+3KYIY0aJpghjRoOmCGNa/aYIDYTfRRjTijdFGPPBTlOEpJNvIySdfBsh6eS7CIO+e7MpQtLJtxGSTr6NkHTybYQGwu8iJJ18GyHp5NsISSffRkg6+TZC0sl3ERbSybcRkk6+jZB08m2EpJNvIzQQfhch6eTbCEkn30ZIOvk2QtLJtxGSTr6LMOhLbJsiJJ18GyHp5NsISSffRmgg/C5C0sm3EZJOvo2QdFJFmNPj4jGPaY+QdPJthKSTbyIcg74EtilC0sm3EZJOvo2QdPJthAbCKsJx3hBOwx4h6eTbCEkn30ZIOvk2QtLJtxGSTr6LMOhLQpsiJJ3UEc7ThnBZ9whJJ99GSDr5NkID4XcRkk6+jZB08m2EpJNvIySd/COE+yd4Y9CXTrZEGPQlkk0Rxkwnc9rW/CWyHa8iDdvFabBfEO4vNtsOFTc7uHEGfSOkH++YucePt8H7rbxjJio/3jHjlx/vmFnthbzXx/HX9uEj97xjBjs/3jFToBvvMWZk9ONNvnwvb/Lle3n3ky/z+HxnruWvF39OamEm7SdT1Sbtx+3lYo9Ff4S0ysXr9jnUtJZn6Dh5Bczwcf/ZgKQp/3L9J8d+XJwrx47e/+fLsR/X5cuxHzfly7Ejl+TK0eDYhGNHDs+VYz9tuC/HflpuX47kmTYcyTNNOE7kmd/iOJUnxyXVri/L9krW8oXf+LOSmwg/DtBJSg7QiVUO0A3o74dOYHOATrpzgE4UdIBObnSATsh8P/SOXnN/I+gkUgfoJFIH6CRSB+gG9PdDJ5E6QCeROkAnkTpAJ5E6QCeRvh/6QiJ1gE4idYBOInWATiJ1gG5Afz90EqkDdBKpA3QSqQN0EqkDdBLp+6EXEqkDdBKpA3QSqQN0EqkDdHx6e+g5zY/DUT7+0/bQ8ekO0PHpDtDx6e+HvuLTHaDj0x2g49MdoOPTHaAb0N8PnSdHDtBJpA7QSaQO0EmkDtBJpG+HbgOJ1AE6idQBOonUATqJ1AG6Af390EmkDtBJpA7QSaQO0EmkDtBJpO+HnkikDtBJpA7QSaQO0EmkDtAN6O+HTiJ1gI5l/B3o+cs59DnbL9f/4JhxgW04st39FsflC8cyf+v6T+7seD7c2fR8uNPE+nCnjPXhTh/rwx1/7cJ9xI/7cKeY9eFON+vDnbzqw93g7sKdvOrDnbzqw5286sOdvOrDnbzqwt3Iqz7cyas+3MmrPtzJq+2557xuU47p+ZGMx4cszID+fugk1VdAX4Yn9LyHjm1/AfRpfPz0j/8se+h49vdDnzDsDtBx6w7QseoO0PHpDtAN6O+Hjk93gM7jJAfoPEtygE4idYBOIn0/9Jlw5ACdcOQAnXDkAB3L+ALopWxTrsPwFfr+4tG2IcePB6h7hfCX6gphRtUVwrmKK7Tw4EVdIYKIukKkFnWFiDjqChkKiSvEkyV1hXDbzgqV/Fh2yfvOh/e0i+tDJ+esz7p9CHndvxPbeD2ztj6839ZbnzSk4fmzx71CdAnqCtElqCtEl6CukKGQuEJ0CeoKkYXUFSINqSvE5xPUFaIx1VZo4g3F/gotj3depJTzXiE6BXWF6BTUFaJTUFfIUEhcIToFdYXoFNQVolNQV4hOQV0hOgVxhXjHtLxCdArqCtEpqCtEp6CukKGQuEJ0CuoK0SmoK0SnoK4QnYK3QjlvCn19kfumEJ2CuEKZTkFdIToFdYXoFNQVolNQV8hQSFwhOgV1hegU1BWiU1BXiE5BXSE6BXGFRjoFdYXoFNQVolNQV4hOQV0hQyFxhXDb7gpNT4WmZa8QbltcIcMpuCv0/Nm5pL1COAV1hQyFxBXi6YO6Qjx9UFeIpw/qCpGH1BUiD4krNPH0QV0hnj6oK0SnoK4QnYK6QoZC4grRKagrRKfwVoU+oVMTOEAn+TtAJ8y/H/pMPneATuR2gE6KdoBOMHaAbkB/P3TiqwN0EqkDdBKpA3QS6fuhL1jGF0Bf53mDvhxAxzI6QGcjfQX0sv68fByG/YlpCxupA3Q2UgfoVLvvh16odh2gU+06QMenO0DHpztAN6C/HzrVbnvo24zLtAdOGn0zcJLom4GTQt8MnAT6XuAr6fPNwEmebwZO6nwzcBLnm4EbwN8LnKT5ZuAEnzcDJ/i8GTjB563A54Hg82bgBJ/2wMfnWaFjHuc9dMKPA3QCkAN0A/r7oROEHKDz2M0BOgn0/dATlvEV0KeyQZ/zHjqW0QE6G+kLoI9pgz6O+0Sa2EgdoLOROkCnznWATqX7fuiZWtcBOj7dATo+3QE61a4DdAP6+6GTSF8BvTzWPdpwAJ1E6gCdROoAnUTqAJ1E+n7ovNj9FdAtPaHbvk/nXe0e0EmkDtBJpA7QDejvh04idYBOInWATiJ1gE4idYBOIn0/dCOROkAnkTpAJ5E6QCeROkA3oL8fOonUATqJ1AE6idQBOonUATqJ9P3QJxKpA3QSqQN0EqkDdBKpA3QD+vuh49Pf/+VdXkP/Euhl2KCv6w46L+f2gI57cYCOe3GAbkB/P3T6dAfo9OkO0PHpDtDx6Q7Q6dPfD32hT3eATiJ9xbfr8vbSv3G0PXQSqQN0EqkDdAP6+6GTSB2gk0gdoJNIHaCTSB2gk0jfD72QSF8BfXye4TWlPXQSqQN0EqkDdBKpA3QD+vuhk0gdoJNI338CaSGROkAnkTpAJ5G+H/pKInWATiJ1gE4idYBOInWAbkB/P3QSqQN0EqkDdBKpA3QSqQN0EunboS8DidQBOonUATqJ1AE6idQBugH9/dBJpA7QSaQO0EmkDtAJR++HnghHDtAJRw7QCUcO0AlHDtCxjO2h53V+IMkfXmUPHcvoAJ2HGA7Q8envh57x6Q7Q8ekO0PHpDtDx6Q7QDejvh85DDAfoJNIX1ADDsB1a//FH99BJpA7QSaQO0Emk74c+kkgdoJNIHaCTSF9hGct2stEw5D10EqkDdAP6+6GTSB2gk0gdoJNIHaCTSB2gk0jfD91IpA7QSaQO0EmkDtBJpA7QDejvh04idYBOInWATiJ1gE4idYBOIn0/9IlE6gCdROoAnUTqAJ1E6gDdgP5+6CRSB+gkUgfoJFIH6CTS90Of8ekvgF7KNuU6/PJNjKN1T+PjZ+dp/8HHGVOvrhAJQF0hQyFxhcgW6goRRNQVIrWoK0TEUVeIJ3TuCj3Xnde9QguP89QVolNQV4hOQV0hOgV1hQyFxBWiU3BX6Pmzc0l7hegU1BWiU1BXiE5BXSE6BXGFCp2CukJ0CuoK0SmoK0SnoK6QoZC4QnQK6grRKagrRKegrhCdgrpCdAriCq10CuoK0SmoK0SnoK4QnYK6QoZC4grRKagrRB5yVmhdH9euX1Bv+pCGlPUpA1lIWx+SkLY+5CBtfUhB2voY+kjrQwLS1odnqtr68ERVWx/6A2196A+k9Un0B9r60B9o60N/4P2EYUjD82ePe4VoENQVMhQSV4gWQV0hegR1hWgS1BWiS1BXiDZBXKFMn6CuEI2CukJ0Cu4K5SdsG/YK0SmoK2QoJK4QnYK6QnQK6grRKagrRKeg5LaPFKJTEM9DI52CukJ0CuoK0SmoK0SnoK6QoZC4QnQK6grRKagrRKegrhCdgrpCdAriChmdgrpCdArqCtEpqCtEp6CukKGQuEJ0CuoK0SmoK0SnoK4QnYK6QnQK4gpNdArqCtEpqCtEp6CuEJ2CukKGQuIK0SmoK0Qeclao5MeySy57fUhD3vrYA1+Z550+M1lIWx+SkLY+hj7S+uDgtPXhmZC2PjwR0taH/KOtD/lHWp+F/KOtD/lHWx+eA2nrw1MgbX0MfZz1KY8Zy7rvrxf6A2196A+09aE/0NaH/kBbH/oDaX0K/YG2PvQH2vrQH2jrQ3+grY+hj7Q+9Afa+tAfaOtDf6CtD/2Btj70B9L6rPQH2vrQH2jrQ3+grQ/9gbY+hj7S+tAfaOtDf6CtD/lUWx/yqbI+H38afaT1IZ9q60M+1dYHf/1b+tj61Gcqv1z/yREf3IYjz7vacMT3t+GIP2/CMeGj23DE77bhiC9tw5HnG204GhybcCTPtOFInmnDkTzThiN5pg1H8sxvcRynJ0crtevnYXxcPqcvUw4/qWfSjwd1spIHdZKVB3VymAd1g7oDdTKeB3USoQd18qMHddKmB3WyqQP1kWzqQZ1s6kGdbOpBnWzqQd2g7kCdbOpBnWzqQZ1s6kGdbOpBnWzqQN3Iph7UyaYvoG5Pfjb+8p2dT+hEUwfoJNMXQB/L+ISe9tAx66+4qU9pu6lPeQ8dr+4AHavuAB2n/n7oE0b9FdDXB5K0pHUPHZ/uAB2f7gAdn+4A3YD+AujPkz6WvE+kEz79BdDLsl1evvB7QJ9xL+2h55SGx5Qpj3vouBcH6LgXB+i4FwfoBvT3Q+fTLw7Q6dMdoOPTHaDTpztAp09/P/SFROoAnUTqAJ1E6gCdRPoK6PO4QZ9tD92A/n7oJFIH6CRSB+gkUgfoJFIH6CTS90MvJFIH6CRSB+gkUgfoJFIH6Ab090PHp7//Y3UFn+4AHZ/+fugrPv0VHyDN20ely7Tv01d8ugN0fLoDdHy6A3QD+vuh8+TIATpPjhygk0gdoJNIHaCTSN8NPQ0f/wN1B+pkUg/qhNJ3f3/3L+qkUg/qBnUH6uRSD+oEUw/qJFMP6kRTD+pkUwfqiWzqQZ1s6kGdbOpBnWzqQd2g7kCdbOpBnWzqQR2//gLq0/bh6TSVX86Z3l882jbkaJb3EmXMvbxEJAF5iYgN8hKRMeQlMiRSl4j0Ii8RUUdeIp7ZyUvEAz51iUZMt7NEJT+WXXI5EAjLLS4Q/dz/z97ZJTaOczF2L7MCibr62//GJj1ty6kvVG71RBYQ8rzVg9qle9AlAqBNiQXa9yeRvVag8nJnd4F4xIkFGofjHNd//p6KRIFE7hLRKthLRKtgLxGtgr1EtAr2EpGJ3CXiTdr+EvGdBXuJqE/tJaJdkEu0HhePpbIJwRvA/SWiXbCXiHbBXiLaBXuJaBfsJaJdcJdooV2wl4h2wV4i2gV7iWgX7CUKJHKXiHbBXiLaBXuJaBfsJaJdsJeIdsFdopV2wV4i2gW1RKUcF5cSFYloF+wlol2wlyiQyF0i2gV7iWgX7CWiXbCXiHbBXiLaBXeJNtoFe4loF+wlol2wl4h2wV6iQCJ3iWgX7CWiXbCXiHbBXaId0y2XaH5JNK8ViTDd9hJhF+QSreWQaBsrEmEX7CXCLthLxGaEvURsRphL9CESErlLRC6yl4hcZC8RmxH2EgUSuUtEu3CrRA/qFAbvoL5vz8uXsfb/Oh2AgjqxXkGdpC6gPhK+FdTJ0wrqRGQFdVKvgnpAXUCdbKqgTjZVUCebKqiTTRXUyaZvoL7M40F9rnSOhWyqoE42VVAnmyqok00V1APqAupkUwV1sqmCOtlUQZ1sqqBONhVQn0hJ11Mv4/EtpI8/RoU6KUlBnZSkoB5QF1AnJSmok5IU1ElJCuqkJAV1UpKAerCDp6BONlVQJ5sqqJNNFdQD6gLqZFMFdbKpgjrZVEGdbKqgTjb9KfV/Qc7EzYtAkiAvAkkovAgkOe8ikNhZ8/Nzxxnvay8RRtleIly1u0QLft1eIpKAvURkDHuJSC/2EgUSqSV63XfZaxKx/2UvEe2CvUS0C/YS0S7YS0S74C7RSrvgfpb7SrtgLxHtgr1EtAv2EgUSuUtEu2AvEe2CvUS0C/YS0S7YS0S74C7RRrtgLxHtgr1EtAv2EtEu2EsUSOQuEe2CvUS0C/YS0S7YS0S7YC8R7YK7RDvtgr1E5CKxRPv+JLJ/Qv0SKBDIWyAykblAJCJzgchD5gKRhswFIgtZC1QGkpC5QOyymgvEHqu5QDQJ5gIFAnkLRJNgLhBNgrlANAnqDYdhHF6fPVUkokuwl4g2wV2ikT7BXiIaBXuJ6BTsJaJVsJcokMhdIpoFe4noFuwlol2QS1ResGOoSES7YC8R7YK7RIV2wV4i2gV7iWgX7CWiXXAy3VWJAonMc1GhXbCXiHbBXiLaBXuJaBfsJaJdcJdool2wl4h2wV4i2gV7iWgX7CUKJHKXiHbBXiLaBXuJaBfsJaJdsJeIdsFdoqBdsJeIdsFeItoFe4loF+wlCiRyl4h2wV4i2gV7iWgX7CWiXbCXiHbBXaKZdsFeInKRWKKtPG97K1tFoEAgsUDxxLctS0UgMpG5QCQic4Fwct4CLfg4c4HYIzIXiB0ic4HIQeYCBQJ5C0QOMheIHGQuEPtC5gKxK2QuEE2CWqDt+dHbXmmzV5oEc4FoEswFokkwF4gmwVygQCBvgWgSzAWiSTAXiCbBXCCaBHOBaBK8BdpoEswFokkwF4gmwVwgmgRzgQKBvAWiSTAXiCbBXCCaBHOBaBLMBaJJ8BZop0kwF4gmwVwggqq5QIFA3gIRVM0FIqiaC0RQtRZoGry3G5bn1fM2TQnzZXxePC6f3sL4cfFjVG8/dOmo0c+o3mv0paN6l0r/YdQy7s+bLmXN7mM4nryllPThOIxjOYCMc/nj+gdI7/Ln94AcvUuaXwTSu0z5RSCb8TNqkM24JTXIAOQ1IJtxemqQ3q3JLwLp3W78IpAkm4tAkmyuAVlINn8Fct5eINcxu35bj55z+8TvaCMLMUhBncykoE7AUlAPqAuoE90U1Ml5CuqEQgV1EqSCOnFTQH0imyqok00V1MmmCupkUwX1gLqAOtlUQZ1sqqBONlVQJ5sqqJNNBdSDbKqgTjZVUCebKqiTTRXUA+oC6mRTBXWyqYI62VRBnWyqoE42FVCfyaYK6mRTBXWyqYI62VRBHb9+PfUyHofMfPwxKtTx6wrq+HUFdfy6gPqCX1dQx68rqOPXFdTx6wrqAXUBdfaSFNTJpgrqZFMFdbKpgjrZVEB9JZsqqJNNFdTJpgrqZFMF9YC6gDrZVEGdbKqgTjZVUCebKqiTTQXUN7KpgjrZVEGdbKqgTjZVUA+oC6iTTRXUcY5/Q718Osi+lPjj+n9Bmr9H/ReBZM37K5DrJ5Db8qPrH+BZ9kTgWflE4ClmReDpZkXgqWdF4PHZEvAx4MtF4OlpReCpakXgSa4i8AF4DXiSqwg8yVUEnuQqAk9yFYEnuWrAjyRXEXiSqwg8yVUEnuR6PfhS9mPKaXx9U+P53YsYA+oC6mTWd1Bfhxf1UqGOfX8D9Xk6bmWetgp1vLuAesG4K6jj2hXUsewK6vh1BfWAuoA6fl1BnQ0mBXV2lxTUyaYK6mRTAfWJlKSgTkpSUCclKajjHN9AfduOKfdh+Ez968XTxx7H4+IpolLGT9hMe4nwpPYSYWDdJQp2YuwlIpDYS0R6sZeIqGMvUSCRu0RsNdlLhOkWS7SV551spVL/8PJ3d4Ho58QC7cc3lPfKa7aDFz6bC8T7ctUCjcM4vD57qkhEq2AvEa2CvUS0CvYSBRK5S0SrYC8RmcheIlKRvUR8Z8FeIupTd4l447FeovX50oxxLJVNCF6P7C8R7YK9RLQL9hIFErlLRLtgLxHtgr1EtAv2EtEu2EtEu+AuEe+s9peIdsFeItoFe4loF+wlCiRyl4h2wV4i2gV7iWgX7CWiXVBLVMoh0ec3w78kol1wl2inXbCXiHbBXiLaBXuJaBfsJQokcpeIdsFeItoFe4loF+wlol2wl4h2wVyieaBdsJeIdsFeItoFe4loF+wlCiRylwjTLZdofkk0rxWJMN3uEo3YBblEr88u21iRCLtgL1EgkbtEbEbYS8RmhL1EbEbYS0QuspeIXOQuUWEzwl4iNiPsJaJdsJeIdsFeokAid4loF+wlol24VaIHdQoDBXU6AAV1Yr2A+kRSV1AnfCuok6cV1InICuoBdQF1gqyCOtlUQZ1sqqBONhVQD5zjG6jvy3JQX2vUcY4K6qym76C+7Y/Lp2EoFeqspgrqrKYK6jS9AuozTa+COk2vgjp+XUEdv66gHlAXUKfpvZ76MeM6V4iTS+8mTia9mzh59G7iZNGbiS/k0LuJk0HvJk7+vJs42fNu4gHxm4mTOe8mTgK6mzgJ6G7iJKCbia8koLuJk4CuJz69zhidyrRUqJOCFNRJQgrqAXUBdRKRgjo7cQrqZFEB9Q3n+A7q83ZQXyrfrthwjgrqrKZvoD6NB/VpqmTTjdVUQZ3VVEGddldBnYZXQH2n5VVQx68rqOPXFdRpehXUA+oC6mTTd1Df5if1GGrUyaYK6mRTBXWyqYI62fR+6gsvi38H9Rhf1KNUqJNNFdTJpgrqZFMF9YC6gDrZVEGdbKqgTjZVUCebKqiTTQXUR7KpgjrZVEGdbKqgTjZVUA+oC6iTTRXUyaYK6mRTBXWyqYI62VRAvZBNFdTJpgrqZFMFdbKpgnpAXUAdv37/r3wX3m7/FurbcFDf96/UeeO3hDoeRkEdD6OgHlAXUKdfV1CnX1dQx68rqOPXFdTp1wXUg35dQZ1s+o7f4JXjDYLTFBXqZFMFdbKpgnpAXUCdbKqgTjZVUCebKqiTTRXUyaYC6jPZ9B3Up9e5X/NYoU42VVAnmyqok00V1APqAupkUwV1sun9Z5cuM9lUQZ1sqqBONhVQX8imCupkUwV1sqmCOtlUQT2gLqBONlVQJ5sqqJNNFdTJpgrqZFMB9ZVsqqBONlVQJ5sqqJNNFdQD6gLqZFMFdbKpgjrZVEGdlCSgvpGSFNRJSQrqpCQFdVKSgjrO8XrqZV+eSMq+DhXqOEcFdXY1FNTx6wLqO35dQR2/rqCOX1dQx68rqAfUBdTZ1VBQJ5u+oREYhuPU+4//tEKdbKqgTjZVUCeb3k99HcimCupkUwV1suk7nON2nIU0DKVCnWyqoB5QF1Anmyqok00V1MmmCupkUwV1sqmA+kg2VVAnmyqok00V1MmmCuoBdQF1sqmCOtlUQZ1sqqBONlVQJ5sKqBeyqYI62VRBnWyqoE42VVAPqAuok00V1MmmCupkUwV1sqmA+oRffwP1bTum3Ic/fqtR+fAyT8/PLnPlS5ET5t5eIpKAvUSBRO4SkTHsJSKQ2EtEerGXiKhjLxF7dnKJjlsZy16RKNjgs5eIdsFeItoFe4loF+wlCiRyl4h2QS7R67PLNlYkol2wl4h2wV4i2gV7iWgX3CWaaRfsJaJdsJeIdsFeItoFe4kCidwlol2wl4h2wV4i2gV7iWgX7CWiXXCXaKFdsJeIdsFeItoFe4loF+wlCiRyl4h2wV4icpFYon1/Xrvvc0UgUpG3QCuZyFwgEpG5QOQhc4FIQ+YCBQJ5C0QSMheIXVZzgdhjNReIJsFcIJoEb4E2mgRzgWgSzAWiSVBvOAzj8PrsqSIRXYK9RIFE7hLRJ9hLRKNgLxGdgr1EtAr2EtEruEu00yzYS0S3YC8R7YJcovKCHUNFItoFe4kCidwlol2wl4h2wV4i2gV7iWgXnEx3VSLaBfNctA20C/YS0S7YS0S7YC8R7YK9RIFE7hLRLthLRLtgLxHtgr1EtAv2EtEuuEs00i7YS0S7YC8R7YK9RLQL9hIFErlLRLtgLxHtgr1EtAv2EtEu2EtEu+AuUaFdsJeIdsFeItoFe4loF+wlCiRyl4h2wV4icpFYoo8H2ePa7dONvAQiFakFiie+bVm+CjSRicwFIhGZCxQI5C0QPs5cIPaIzAVih8hcIHKQuUDkIG+BghxkLhA5yFwg9oXMBWJXyFygQCCxQNv8FGivtNlBk2AuEE2CuUA0CeYC0SSYC0ST4C3QTJNgLhBNgrlANAnmAtEkmAsUCOQtEE2CuUA0CeYC0SSYC0STYC4QTYK3QAtNgrlANAnmAtEkmAtEk2AuUCCQt0A0CeYC0SSYC0RQNReIoOot0EpQNReIoGouEEHVXCBs9l8JFPtLoPnP6x8gscMXgWQD7CKQ+P+LQOLTrwG54acvAonvvQgk/vQikGx4XAQyAHkNSJLNRSBJNheBJNlcBJJkcxFIks1fgZzmF8hIr1+G6Xn5Mn6acnhi38lBEuykJgl2MpYEO4lMgj3ArsBO2pNgJxtKsJMkJdjJnRLspFQB9n0gpUqwk1Il2EmpEuykVAn2ALsCOylVgp2UKsFOSpVgJ6VKsJNSFdhHUqoEOyn1DdjjxS+mP37Y86BOSFVQJ6O+gfq0TS/qY4U6pv0dD/Z5PB7sc6lQx7MrqGPZFdRx7ALqBcP+Dur7E8m4jnuFOn5dQR2/rqCOX1dQD6i/gfrrZJC1VLJpwa+/gfq2Hpdvn/gd1Cc8zPXUyzgOz08fy1ShjodRUMfDKKjjYRTUA+oC6nwrRkGdfl1BHb+uoE6/rqBOvy6gHmRTBXWyqYI62VRBnWz6DurLdFBfokI9oC6gTjZVUCebKqiTTRXUyaYK6mRTAfWZbKqgTjZVUCebKqiTTRXUA+oC6vh1wTfuZvy6gjp+XUB9wa+/49ul5fgm9TZX+vUFv66gjl9XUMevK6gH1AXU2UtSUGcvSUGdbKqgTjZVUCebCqivZFMFdbKpgjrZVPAr35VsqqAeUBdQJ5sqqJNNFdTJpgrqZFMFdbKpgPpGNlVQJ5sqqJNNFdTJpgrqAXUBdbKpgjrZVEEdv/4G6vPxTepx3v44k/rrxVOMz8+eIioHWO+Ye3uJSAL2EhEb7CUiY9hLFEjkLhHpxV4ioo69ROzZ2UvEBp+3ROMwYLrFEm3leSfbpxt5CYTlNheIfk4s0Ee587h2/1qgjgPvg3YXiEecWKB//pG8PnuqSBRI5C4RrYK9RLQK9hLRKthLRKtgLxGZyF0iXrrtLxHfWbCXiPrUXiLaBblE63HxWCqbELwo3F8i2gV7iWgX7CWiXbCXiHbBXiLaBXeJJtoFe4loF+wlol2wl4h2wV6iQCJ3iWgX7CWiXbCXiHbBXiLaBXuJaBfcJQraBXuJaBfUEpVyXFxKVCSiXbCXiHbBXqJAIneJaBfsJaJdsJeIdsFeItoFe4loF9wlmmkX7CWiXbCXiHbBXiLaBXuJAoncJaJdsJeIdsFeItoFd4kWTLdcovkl0bxWJMJ020uEXZBLtJZDom2sSIRdsJcIu2AvEZsR9hKxGeEu0cpmhL1E5CJ7ichF9hKxGWEvUSCRu0S0C7dK9KBOYfAO6vv2vHwZa/+v0wEoqBPrFdRJ6gLqG+FbQZ08raBORFZQJ/UqqAfUBdTJpgrqZFMFdbKpgjrZVEGdbPoG6ss8HtTnSue4k00V1MmmCupkUwV1sqmCekBdQJ1sqqBONlVQJ5sqqJNNFdTJpvdTHwdS0vXUy3h8C+njj1GhTkpSUCclKagH1AXUSUkK6qQkBXVSkoI6KUlBnZQkoD6yg6egTjZVUCebKqiTTRXUA+oC6mRTBXWyqYI62VRBnWyqoE42/Sn1f0EW4uZFIEmQF4EkFF4Ekpx3EUjsrPn5uWPB+9pLhFG2lwhX7S7RhF+3l4gkYC8RGcNeItKLvUSBRGqJjlv5MG81idj/speIdsFeItoFe4loF+wlol1wlyhoF8zPch+DdsFeItoFe4loF+wlCiRyl4h2wV4i2gV7iWgX7CWiXbCXiHbBXaKZdsFeItoFe4loF+wlol2wlyiQyF0i2gV7iWgX7CWiXbCXiHbBXiLaBXeJFtoFe4nIRWKJ9v054/4J9UugQCBvgchE5gKRiMwFIg+ZC0QaMheILOQt0EoSMheIXVZzgdhjNReIJsFcoEAgb4FoEswFokkwF4gmQb3hMIzD67OnikR0CfYS0Sa4S7TRJ9hLRKNgLxGdgr1EtAr2EgUSuUtEs2AvEd2CvUS0C3KJygt2DBWJaBfsJaJdcJdop12wl4h2wV4i2gV7iWgXnEx3VaJAIvNctNMu2EtEu2AvEe2CvUS0C/YS0S6YS1QG2gV7iWgX7CWiXbCXiHbBXqJAIneJaBfsJaJdsJeIdsFeItoFe4loF9wlGmkX7CWiXbCXiHbBXiLaBXuJAoncJaJdsJeIdsFeItoFe4loF+wlol1wl6jQLthLRC4SS7SV551sn27kJVAgkFigeOLblqUiEJnIXCASkblAODlvgSZ8nLlA7BGZC8QOkblA5CBzgQKBvAUiB5kLRA4yF4h9IXOB2BUyF4gmQS3Q9vzoba+02UGTYC4QTYK5QDQJ5gLRJJgLFAjkLRBNgrlANAnmAtEkmAtEk2AuEE2Ct0AzTYK5QDQJ5gLRJJgLRJNgLlAgkLdANAnmAtEkmAtEk2AuEE2CuUA0Cd4CLTQJ5gLRJJgLRFA1FygQyFsggqq5QARVc4EIqt4Crc3Y7HGZn8zHj7/l88WPUZsxrPmo0cyo23b8v77Hnly8j8eE+7an/+w+SB1Axrn8cf0DZDMOQA2ymZVaDbKZFVUNspmKVg2ymSpVDHJrx4uJQbbj9MQgm/kykhpkM12sGmQA8hqQJJuLQJJs/grkvL1AfuosTq7f1qMR2z7xO3qrjRikoE5mUlAnYAmo76QxBXWim4I6OU9BnVCooB5QF1Anbiqok00V1MmmCupkUwV1sun91KeBbKqgTjZVUCebKqiTTRXUA+oC6mRTBXWyqYI62VRBnWyqoE42FVAfyaYK6mRTBXWyqYI62VRBPaAuoE42VVAnmyqok00V1MmmCupkUwH1gl+/nnoZj+NIPv4YFer4dQX1gLqAOn5dQR2/rqCOX1dQx68rqOPXBdQn9pIU1NlLUlAnmyqok00V1APqAupkUwV1sqmCOtlUQZ1sqqBONhVQD7KpgjrZVEGdbKqgTjZVUA+oC6iTTRXUyaYK6mRTBXWyqYI62VRAfSabKqiTTRXUcY5/Q718Osi+lPjj+gdIzOBFIFnz/grk+gnktvzo+n/Bt/PO+N8GnpVPBJ5iVgSeblYEPgCvAY/PFoHHl4vA09OKwFPVisCTXDXgV5KrCDzJVQSe5CoCT3IVgQ/Aa8CTXEXgSa4i8CRXEXiSqwg8yfV68KXsx5TT+PqmxvHdi43YqqBOZn0H9XV4US8V6gH166nP0/PTP/64Vajj3RXUMe4K6rh2BXUsu4I6fl1AfcevK6jj1xXU2WBSUGd3SUE9oC6gTjZVUCclKaiTkhTUSUn3U48B5/gG6tt2TLkPw2fqXy+eYny+yGeKKBWJsJn2EgUSuUuEgbWXiJ0Ye4kIJPYSkV7sJSLquEs0sntkLxFbTfYSYbrFEm0lHtdupVL/8PJ3c4F4i7NaoP34hvJeec128MJnd4F4xIkFGodxeH32VJGIVsFeIloFe4loFdwl4h2//hLRKthLRCayl4hUZC9RIJG7RNSn9hLRLsglWo/7HktlE4LXI/tLRLtgLxHtgrtEvKXZXyLaBXuJaBfsJaJdsJcokMhdItoFe4loF+wlol2wl4h2wV4i2gV3iXjPtr9EtAv2EtEu2EtEu2AvUSCRWKJSjvv+/Gb4l0S0C/YS0S7YS0S7YC8R7YK9RLQL7hIttAv2EtEu2EtEu2AvEe2CvUSBRO4S0S7YS0S7YC8R7YK9RLQL9hLRLrhLtNIu2EsUSKSWaH5JNK8ViTDd9hJhF+QSvT67bGNFIuyCu0QbdsFeIjYj7CViM8JeIjYj7CUKJHKXiFxkLxGbEfYSsRlhLxHtgr1EtAvuEu20C/YS0S7YS0S7cKtED+oUBgrqAXUBdWK9gjpJXUGd8K2gTp5WUCci3099Hki9CuoEWQV1sqmCOtlUQT2gLqCOc3wD9X1ZDuprjTrOUUB9ZDV9B/Vtf1w+DUOpUGc1VVBnNVVQp+lVUKfpVVCn6VVQx68rqOPXBdQLTa+COk3v9dSPGde5QpxcejdxMundxAPiNxMni95NnBx6N3Ey6N3EyZ93Eyd73kx8InfeTZzMeTdxEtDdxAPiNxMnAd1NnAR0N3ES0PXEp9cZo1OZlgp1UpCCOklIQD1IQwrqJCIFdXbiFNTJogrqOMd3UJ+3g/pS+XZF4BwF1GdW0zdQn8aD+jRVsunMaqqgzmqqoB5QF1Cn4VVQp+VVUMevK6jj1xXUaXoF1BeaXgV1suk7qG/zk3oMNepkUwV1sqmCekBdQJ1sqqBONn0D9Rhf1KPSr/P+dwl1sqmCOtlUQJ0Xr0uok00V1MmmCupkUwX1gLqAOtlUQZ1sqqBONlVQJ5sqqJNNBdQ3sqmCOtlUQZ1sqqBONlVQD6gLqJNNFdTJpgrqZFMFdbKpgjrZVEB9J5sqqLeTTfflSb0M05Dcx7DF8+JStpT6OL6oj3P54/oHyHbiphhkOwlSDDIAeQ3IdnKeGGQ70U0Msp00JgbZTsASg2wnM0lBLkM7MUgMkmRzEUiSzUUgSTZ/BfI4Iuvjz+uYXb+tz4bj44Kvv7NahoC6gDqZSUGdgKWgThpTUCe6KaiT8wTUR0KhgjoJUkGduKmgTjZVUA+oC6iTTRXUyaYK6mRTBXWyqYI62VRAvZBNFdTJpgrqZFMFdbKpgnpAXUCdbKqgTjZVUCebKqiTTRXUyaYC6hPZVEGdbKqgTjZVUCebKqgH1AXUyaYK6vj166mX8XUr4xIV6vh1AfXAryuo49cV1PHrCur4dQX1gLqAOn5dQZ29JAV19pIU1MmmCupkUwH1mWyqoE42VVAnmyqok00V1APqAupkUwV1sqmCOtlUQZ1sqqBONhVQX8imCupkUwV1sqmCOtlUQT2gLqBONlVQJ5sqqJNNBdRXnOPfUC+fjlQvJf64/gESM3gRSNa8vwL5n96+9/31D/AseyLwrHwi8BSzIvB0sxrwG/WsCDw+WwQeXy4CT08rAh+A14AnuYrAk1xF4EmuIvAkVxF4kqsG/E5yFYEnuYrAk1xF4EmuIvABeA14kuv14EvZjymn8fVNjeO7FzuxVUGdzPoO6uvwol6+UF8H7PsbqM/Tk9/HH7cKdby7gjrGXUEd166gHlAXUMevK6jj1xXU8esK6mwwKaizuySgPpJNFdTJpgrqpCQF9YC6gDopSUEd5/gG6tt2TLkPw2fqXy+eYny+yGeKqJTxIzbTXaKCJ7WXCANrLxE7MfYSEUjsJQokcpeIqGMvEbtH9hKx1eQuEW90V0u0leedbKVS//Dyd3eB6OfEAu3HN5T3ymu2V174bC4Q78tVCzQO4/D67KkiEa2CvUSBRO4S0SrYS0SrYC8RrYK9RGQie4lIRe4S8V5if4moT+0lol2QS7Q+73scS2UTgtcj+0sUSOQuEe2CvUS0C/YS0S7YS0S7YC8R7YK7RLxZ2l8i2gV7iWgX7CWiXbCXKJDIXSLaBXuJaBfsJaJdsJeIdsFeItoFd4lW2gW1RKUcEn1+M/xLItoFe4loF+wlol2wlyiQyF0i2gV7iWgX7CWiXbCXiHbBXiLaBXeJNtoFe4loF+wlol2wl4h2wV6iQCJ3iWgX7CWiXXCXaMd0yyWaXxLNa0UiTLe9RIFEaolen122sSIRdsFeIuyCvURsRthLxGaEvURsRphLtA3kInuJyEX2ErEZYS8RmxH2EgUSuUtEu2AvEe2CvUS0C/YS0S7cKtGDOoWBgPpIB6CgTqxXUCepK6gTvhXUA+oC6kRkBXVSr4I6QVZBnWyqoE42FVAvZFMF9YD69dT3ZTmorzXqOEcFdVbTd1Df9sfl0zCUCnVWUwH1idVUQZ2mV0GdpldBnaZXQT2gLqCOX1dQp+lVUKfpvZ76MeM6V4iTS+8mTia9mXiQR+8mTha9mzg59G7iZNC7iQfEbyZO9rybOLnzbuJkzruJk4BuJj6TgO4mTgK6mzgJ6G7iJKDriU+vM0anMi0V6gF1AXWSkII6aUhBnUSkoM5OnII6WVRAfcE5voP6vB3Ul8q3K5aAuoA6q+kbqE/jQX2aKtl0YTVVUGc1FVBfaXcV1Gl4FdRpeRXU8esK6gF1AXWaXgV1ml4FdbLpO6hv85N6DDXqZFMFdbKpgDqvoZdQJ5sqqJNN30A9xhf1qPTrvP9dQj2gLqBONlVQJ5sqqJNNFdTJpgrqZFMB9Z1sqqBONlVQJ5sqqJNNFdQD6gLqZFMFdbKpgjrZVEGdbKqgTja9n/o+kE0V1MmmCupkUwV1sqmCekBdQJ1sqqBONlVQx6/f/yvfnbfbv4X6NhzU971CHQ+joB5QF1DHwyio42EU1OnXFdTp1xXU8esC6rzxW0Kdfl1BnX5dQZ1s+o7f4JXjDYLTFBXqAXUBdbKpgjrZVEGdbKqgTjZVUCebCqhPZFMFdbKpgjrZ9B3Up9e5X/NYoU42VVAPqAuok00V1MmmCupkUwV1sun9Z5fuE9lUQD3IpgrqZFMFdbKpgjrZVEE9oC6gTjZVUCebKqiTTRXUyaYK6mRTAfWZbKqgTjZVUCebKqiTTRXUA+oC6mRTBXWyqYI62VRBnWyqoE42FVBfSEkK6qQkBXVSkoJ6QF1AnZSkoI5zvJ562ZcnkrKvQ4U6zlFAfWVXQ0Edv66gjl9XUMevK6gH1AXU8esK6uxqKKizq6GgTjZ9QyMwDMep9x//aYU62VRAfSObKqiTTRXUyaYK6mRTBfWA+huc43achTQMlXfIbGRTBXWyqYI62VRBnWyqoE42FVDfyaYK6mRTBXWyqYI62VRBPaAuoE42VVAnmyqok00V1MmmCupk09upl2Egmyqok00V1MmmCupkUwX1gLqAOtlUQZ1sqqBONlVQJ5sqqJNNBdRHsqmCOn79DdS37ZhyH/74rUblw8v8vO+PP64ViQKJ3CUiCdhLRGywl4iMYS8RgcReItKLu0SFqGMvEXt2comOWxnLXpOIDT57iWgX7CUKJHKXiHbBXiLaBXuJaBfkEr0+u2xjRSLaBXuJaBfcJZpoF+wlol2wl4h2wV4i2gV7iQKJ3CWiXbCXiHbBXiLaBXuJaBfsJaJdcJcoaBfsJaJdsJeIdsFeItoFe4kCidwlol2wl4h2wV4i2gV3iWZykViifX9eu+9zRSBSkblAZCJzgUhE5gIFAnkLRBoyF4gsZC4QSchcIHZZzQVij9VboIUmwVwgmgRzgWgSzAWiSTAXKBBIvOEwjMPrs6eKRHQJ9hLRJthLRJ9gLxGNgr1EdAruEq20CvYS0SvYS0SzYC8R3YK9RIFEaonKC3YMFYloF+wlol2wl4h2wV4i2gV7iWgX3CXaaBecTHdVItoF91y00S7YS0S7YC9RIJG7RLQL9hLRLthLRLtgLxHtgr1EtAvuEu20C/YS0S7YS0S7YC8R7YK9RIFE7hLRLthLRLtgLxHtgr1EtAv2EtEumEs0DrQL9hLRLthLRLtgLxHtgr1EgUTuEtEu2EtEu2AvEe2Cu0QjuUgs0Vaed7J9upGXQKQitUDxxLctS0UgMpG5QCQic4FwcuYC4ePMBWKPyFwgdoi8BSrkIHOByEHmApGDzAUiB5kLFAjkLRC7QuYC0SSoBdrmp0B7pc0uNAnmAtEkmAtEk+At0ESTYC4QTYK5QDQJ5gLRJJgLFAjkLRBNgrlANAnmAtEkmAtEk2AuEE2Ct0BBk2AuEE2CuUA0CeYC0SSYCxQI5C0QTYK5QDQJ5gLRJJgLRJPgLdBMUDUXiKBqLhBB1Vwggqq5QIFA3gJhs/9KoNhfAs1/Xv8AiR2+CCQbYNeAXPD/F4HEp18EEj99EUh870UgA5DXgGTD4yKQbExcBJJkcxFIks1FIEk214BcSTYXgSTZ/BXIaX6BjPT6ZXjeykd0/DTlcGAnB0mwk5ok2APsCuwkMgl28psEO2lPgp1sKMFOklRg38idEuykVAl2UqoEOylVgj3ArsBOSpVgJ6VKsJNSJdhJqRLspFQF9p2UKsFOSpVgJ6VKsJNS34A9Xvxi+uOHPQ/qAXUBdTLqG6hP2/SiPlaoY9rf8WCfx+PBPpcKdTz7/dTLgGVXUMexK6hj2N9BfX8iGddxr1DHryuoB9QF1PHrCupsKb2D+utkkLUMFer49TdQ39bj8u0Tv4P6iIe5nnoZx+H56WOZKtTxMArqAXUBdTyMgjoeRkGdb8UoqNOvK6jj1wXUC/26gjr9uoI62VRBnWyqoB5QF1Anm76D+utWxiUq1MmmCupkUwV1sqmCOtlUQH0imyqok00V1MmmCupkUwX1gLqAOtlUQZ1sqqCOXxd84y7w6wrq+HUFdfz6O75dWo5vUm9zpV8P/LqCekBdQB2/rqCOX1dQZy9JQZ29JAV1sqmA+kw2VVAnmyqok00V1MmmCuoB9ft/5TuTTRXUyaYK6mRTBXWyqYI62VRAfSGbKqiTTRXUyaYK6mRTBfWAuoA62VRBnWyqoE42VVAnmwqor/j1N1Cfj1sZ5+2PM6m/XjzF+PzsKaJygPWKubeXiCRgL1EgkbtEZAx7iQgk9hKRXuwlIurYS8SenbtEGxt89hIFEmkl2srzTrZPN/ISCMvtLRBveVYLtO/PGfdagcr7oN0F4hEnFmgcjgNe//l7KhLRKthLRKtgLxGtgr1EtArmEk28GttfIjKRvUSkInuJ+M6CvUSBRO4S0S7IJVqPiz8sdkUi2gV7iWgX7CWiXbCXiHbBXaKRdsFeItoFe4loF+wlol2wlyiQyF0i2gV7iWgX7CWiXbCXiHbBXiLaBXeJCu2CvUS0C/YS0S7YS0S7oJaolOPiUqIiUSCRu0S0C/YS0S7YS0S7YC8R7YK9RLQL7hJNtAv2EtEu2EtEu2AvEe2CvUSBRO4S0S7YS0S7YC8R7YK9RLQL9hLRLrhLFJhuuUTzS6J5rUgUSOQuEXZBLtFaDom2sSIRdsFeIuyCu0QzmxH2ErEZYS8RmxH2EpGL7CUKJHKXiM0Ie4nYjLCXiHbhVoke1CkM3kF9356XL2Pt/3U6AAH1hVivoE5SV1AnfCuok6cV1APqAuqkXgV1gqyCOtlUQZ1sqqBONhVQX8mmCupk0zdQX+bxoD5XOseVbKqgTjZVUA+oC6iTTRXUyaYK6mRTBXWyqYI62VRAfSObKqiTTRXUSUnXUy/j61bGpfL7zC2gLqBOSlJQJyUpqJOSFNRJSQrqpCQB9Z2UpKBOSlJQZwdPQZ1sqqAeUBdQJ5sqqJNNFdTJpgrqZFMFdbLp/dRjIJsqqJNNf0r9AZK4eRFIEuRFIAOQ14Ak510EEjtrfn5uDHhfd4lGjLK9RLhqe4nw6/YSkQTsJQokcpeI9GIvEVtacomOWxnLXpOI/S97iWgX7CWiXXCXqNAu2EtEu2AvEe2C+VnuUWgX7CUKJHKXiHbBXiLaBXuJaBfsJaJdsJeIdsFdool2wV4i2gV7iWgX7CWiXbCXKJDIXSLaBXuJaBfsJaJdsJeIdsFeItoFd4mCdsFeItoFe4loF+wlIheJJdr354z7J9QvgUhF5gKRicwFIhGZC0Qe8hZoJg2ZC0QWMheIJGQuELus5gIFAnkLRJNgLhBNgrlANAnmAtEkmAtEk6DecBjG4fXZ01eJFroEe4loE+wlok+wl4hGwV6iQCJ3iWgV7CWiV7CXiGbBXiK6BXuJaBfkEpUX7Bi+SrTSLthLRLtgLxHtgr1EtAv2EgUSuUtEu+BkuqsS0S6456KVdsFeItoFe4loF9wl2mgX7CWiXbCXiHbBXiLaBXuJAoncJaJdsJeIdsFeItoFe4loF+wlol1wl2inXbCXiHbBXiLaBXuJaBfsJQokcpeIdsFeItoFe4loF+wlol2wl4h2wVyieaBdsJeIdsFeItoFe4nIRWKJtvK8k+3TjbwEIhWpBYonvm1ZKgKRicwFIhF5CzTi5MwFwseZC8QekblAgUDeApGDzAUiB5kLRA4yF4gcZC4Q+0LeAhV2hcwFoklQC7Q9P3rbK212oUkwF4gmwVygQCBvgWgSzAWiSTAXiCbBXCCaBHOBaBK8BZpoEswFokkwF4gmwVwgmgRzgQKBvAWiSTAXiCbBXCCaBHOBaBLMBaJJ8BYoaBLMBaJJMBeIJsFcIJoEc4EIquYCEVTNBSKomgtEUDUXiKDqLdDcjs3etoPKHnum5nhMuG97LtBaXgJtS3L9VObtcflUllKh3o53dqK+DQf1fa9Qb8dv/Sbq7Zio30S9HWf0m6i3Y3d+EfWlnbL9N1Fvp0H/TdTx6wrq+HUF9YC6gHo72wa/iTrZ9A3UP1g/qU9TVKiTTRXUyaYK6mRTAfWVbKqgTjZVUCebKqiTTRXUA+oC6mTTd1Cfjt3qaR4r1MmmCupkUwV1sqmCOtlUQH0jmyqok03fQX18UZ/mCnWyqYI62VRBPaAuoE42VVAnmyqok00V1MmmCupkUwH1nWyqoE42VVAnmyqok00V1APqAupkUwV1sqmCOtlUQZ1sqqBONr2f+jKQTRXUyaYK6mRTBfWAuoA6KUlBnZSkoE5KUlAnJQmojzjH66mXfXkiKfs6VKjjHBXU2dVQUA+oC6jj1xXU8esK6vh1BXX8uoI6uxoC6oVdDQV1sukbGoFheB56P338pxXqZFMFdbKpgnpAXUCdbKqgTjZVUCebvsM5bsdZSMNQKtTJpgrqZFMB9YlsqqBONlVQJ5sqqJNNFdQD6gLqZFMFdbKpgjrZVEGdbKqgTjYVUA+yqYI62VRBnWyqoE42VVAPqAuok00V1MmmCupkUwV1sqmCOtlUQH0mmyqok00V1MmmCupkUwV1/PobqG/bMeU+/PFbjcqHl/m47zJXvhQ5Y+7tJSIJ2EtEbHCXaCFj2EtEILGXiPRiLxFRx16iQCK1RFscEu01idjgs5eIdsFeItoFe4loF+wlol1wl2ilXZBL9Prsso0ViWgX7CWiXbCXiHbBXqJAIneJaBfsJaJdsJeIdsFeItoFe4loF9wl2mgX7CWiXbCXiHbBXiLaBXuJAoncJaJdsJeIdsFeItoFe4loF+wlol1wl2inXbCXiFwklmjfn9fue+XdzXsgkLdAZCJzgUhE5gKRh8wFIg2ZC0QWshZoHUhC5gKxy2ouEHus5gLRJJgLFAjkLRBNgrlANAnmAtEkqDcchnF4ffZUkYguwV4i2gR3iUb6BHuJaBTsJaJTsJeIVsFeokAid4loFuwloluwl4h2QS5RecGOoSIR7YK9RLQL7hIV2gV7iWgX7CWiXbCXiHbByXRXJQokMs9FhXbBXiLaBXuJaBfsJaJdsJeIdsFdool2wV4i2gV7iWgX7CWiXbCXKJDIXSLaBXuJaBfsJaJdsJeIdsFeItoFd4mCdsFeItoFe4loF+wlol2wlyiQyF0i2gV7iWgX7CWiXbCXiHbBXiLaBXeJZtoFe4nIRWKJthKPa7eyVQQKBBILFE9827JUBCITmQtEIjIXCCfnLdCCjzMXiD0ic4HYITIXiBxkLlAgkLdA5CBzgchB5gKxL2QuELtC5gLRJKgF2uanQHulzV5pEswFokkwF4gmwVwgmgRzgQKBvAWiSTAXiCbBXCCaBHOBaBLMBaJJ8BZoo0kwF4gmwVwgmgRzgWgSzAUKBPIWiCbBXCCaBHOBaBLMBaJJMBeIJsFboJ0mwVwgmgRzgQiq5gIFAnkLRFA1F4igai4QQdVaoG3AZv+VQLG/BJq3P65/gMQOXwSSDbCLQOL/LwIZgLwGJH76IpD43otA4k8vAsmGx0Ug2Zi4BuRIsrkIJMnmIpAkm4tAkmwuAhmA/BuQ0/wCGVt2/TIct7KMn6YcDuzkIAl2UpMEOxlLgp1EJsFOflNgL6Q9CXayoQQ7SVKCndwpwR5gV2AnpUqwk1Il2EmpEuykVAl2UqoC+0RKlWAnpUqwk1Il2EmpEuwBdgV2UqoEOyn1DdjjxS+mP37Y86BOSFVQJ6O+gfr0upWYxq/UA9P+jgf7PB4P9rlUqOPZFdSx7ArqAXUBdQz7O6jvTyTjOu4V6vh1BXX8uoI6fl1BnS2ld1B/nQyylko2nfHrb6C+rcfl2yd+L+p4mOupl3EcnlOOZapQx8MoqONhFNTxMArqeBgB9YVvxSio068rqOPXFdTp1xXUA+oC6mRTBXWyqYI62VRBnWz6DurLdFBfokKdbCqgvpJNFdTJpgrqZFMFdbKpgnpAXUCdbKqgTjZVUCebKqiTTRXUyaYC6ht+XfCNuw2/rqAeUBdQx6+/49ul5fgm9TZX+vUNv66gjl9XUMevK6jj1wXUd/aSFNTZS1JQJ5sqqJNNFdQD6gLqZFMFdbKpgjrZVPAr351sqqBONr2f+j6QTRXUyaYK6mRTBXWyqYJ6QF1AnWyqoE42VVAnmyqok00V1MmmAuoj2VRBnWyqoB5Qv576fHyTepy3P86k/nrxFOPzs6eIUpEIc28vEUnAXiJig71EZAx7iQgk7hIV0ou9REQde4nYs7OXiA0+e4kw3WKJthKPa7eyVQTCcnsLxFue1QLt+3PGvVag8j5od4F4xIkFGofjgNd//p6KRLQK7hIFrYK9RLQK9hLRKthLRKtgL1EgkbtEpCJ7ifjOgr1E1Kf2EtEuyCVaj4vHUtmE4EXh9hLNtAv2EtEu2EtEu2AvEe2CvUSBRO4S0S7YS0S7YC8R7YK9RLQL9hLRLrhLtNAu2EtEu2AvEe2CvUS0C/YSBRK5S0S7YC8R7YJaolKOi0uJikS0C/YS0S7YS0S74C7RSrtgLxHtgr1EtAv2EtEu2EsUSOQuEe2CvUS0C/YS0S7YS0S7YC8R7YK7RBvtgr1EtAv2EtEu2EuE6ZZLNL8kmteKRJhud4l27IJcorUcEm1jRSLsgr1E2AV7idiMsJcokMhdIjYj7CUiF9lLRC6yl4jNCHuJ2IzwlmgaBtqFWyV6UKcweAf1fXtevoy1/9fpABTUifUK6gF1AXXCt4I6eVpBnYisoE7qVVAnyAqoj2RTBXWyqYI62VRBnWyqoB5Qv576Mo8H9bnSOY5kUwV1sqmCOtlUQZ1sqqBONhVQL2RTBXWyqYI62VRBnWyqoB5QF1AnJV1PvYzHt5A+/hgV6qQkBXVSkoI6KUlAfSIlKaiTkhTUSUkK6qQkBfWAuoA6O3gK6mRTBXWyqYI62VRBnWwqoB5kUwV1sqmCOtlUQZ1sqqAeUP8h9QdI4uZFIEmQF4EkFF4Ekpx3DcgZO+t9fu6HRHhfe4kwyvYSBRK5S4Rft5eIJGAvERnDXiLSi71EbGnJJdrikGivSLSw/2UvEe2CvUS0C/YS0S7YSxRI5C4R7YL7We4L7YK9RLQL9hLRLthLRLvgLtFKu2AvEe2CvUS0C/YS0S7YSxRI5C4R7YK9RLQL9hLRLthLRLtgLxHtgrtEG+2CvUS0C/YS0S7YS0S7YC9RIJG7RLQL9hKRi8QS7ftzxv0T6pdApCJvgXYykblAJCJzgchD5gKRhswFCgTyFogkZC4Qu6zmArHHai4QTYK5QDQJ1gKNA02CuUA0CeYC0SSoNxyGcXh99lSRiC7BXqJAIneJ6BPsJaJRsJeITsFeIloFe4noFdwlGmkW7CWiW7CXiHZBLlF5wY6hIhHtgr1EgUTuEtEu2EtEu2AvEe2CvUS0C06muyoR7YJ7Liq0C/YS0S7YS0S7YC8R7YK9RIFE7hLRLthLRLtgLxHtgr1EtAv2EtEuuEs00S7YS0S7YC8R7YK9RLQL9hIFErlLRLtgLxHtgr1EtAv2EtEu2EtEu+AuUdAu2EtEu2AvEe2CvUS0C/YSBRK5S0S7YC8RuUgs0Vbice1WtopApCK1QPHEty3LV4FmMpG5QCQic4ECgbwFwseZC8QekblA7BCZC0QOMheIHOQt0EIOMheIHGQuEPtC5gKxK2QuUCCQWKDt+dHbXmmzF5oEc4FoEswFokkwF4gmwVwgmgRvgVaaBHOBaBLMBaJJMBeIJsFcoEAgb4FoEswFokkwF4gmwVwgmgRzgWgSvAXaaBLMBaJJMBeIJsFcIJoEc4ECgbwFokkwF4gmwVwggqq5QARVb4F2gqq5QARVc4EIquYC3bwGrePz4rLNayLQOIxjOW5knMsfYP7fAGUYfvsA428foPz2AabfPkD89gHm3z7A8tsHWH/7ANtvH+C3r8Tjb1+JR/OVeN5eA6xjZhK39fCU26f7fjq/Mpov2xdPa77GXzxtdDWtuXu4eFpzq3HxtOa+5OJpzU3MxdOaO55rpy3m9ujiabvyUqUrL1W68lJ3v41dPG1XXqp05aVKV16qdOWlSldeaurKS01deampKy81deWl7n73rHjarrzU1JWXmrryUlNXXmrqyktFV14quvJS0ZWXiq681N1v2hNP29J6+7GH9/wC58cfozJtS+ttPm1L62067dzSeptP29J6m0/b0nqbT9vSeptP29J6m0/bUneRT9tSd5FP25WXmrvyUnNXXmrpykstXXmppSsvtXTlpe5+I4x42q681NKVl1q68lJLV15q6cpLrV15qbUrL7V25aXWrrzU3Wfii6ftykutXXmpzXsFKp9+QFxK/DHtYwDvReUvBvB+lnysY68BtiX5/+376x8Dez9O3jCw9xPlDQN7B7Q3DOyd0d4wsHdMu37g3XydvH5g83X1+oG989obBvaObG8YOHobuDentffmtPbenNbem9MyPyz08oEn88NF3zBwZ05rMj+89A0Dd+a0piEaGrh8ZKHnp0/jq3F9dqiT+UmqV0/bkscqH1uwr2lLZdqWlt8yT8/7/vjj15PJJ/PjRK+etqWFN5+2pVU3n7alJTeftqn1Np22qfU2nbap9TadtqVCI5+2pTYjn7YrL2V+9ujV03blLsxP47x62uhq2qZWoG070vw+DJ+n/XrxFOPzQIgpohKGzY93lKJpam27FI35wZFSNE01ENeiacpQXIumKfdxLZoAzRmaplqTa9E0VbFcisb8pMI3otlKPK7dSiUmmB9qKATTbX7aj53TvXKc3mR+wJwO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"},{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1dbYwkRRnu6Z3Z3dmdm9n72DuOu72bOZa7W+6469nZXdCoHKKJYII/MGg00Sy3e3ACt+RuEdBEo2ggkmj8NpKI8SMaSOAHJprIDwj4R4x8BDRRMQEjGgMq/lHBH17P9LPzzLu13TPd/W4vN9XJ3XbXvFXP835UdXVVdXXOaR254J9/FChNHkg7Fvz1kh31FMvycpKn/1++C2X8v+82yN3uts93Bn8vP316/o7qyVMLi7dXl25dri6dqF63dOuphTOc8bNxM75noH2+O/g7v7y8ePMty9Xlper8wkL1tpPLN1SXPr54+sRNS7dx3i9T3trqvDffetPyyVtuumPtAr4+EJP1fQlY35+U9YNxWf88KfKjCdR+Ii7rJxOAPhUX9DcJQH8XF/TFBKB/jgv6SgLQf8YF/XcC0Dfigrr5+KCD+Zig11DGWHXuA3GRjydQ9/q4oGcSgN4WF/TOBKB3xQX9agLQb8YF/X4C0B/FBX04AehP44I+ngD0qQR5X0haX19KAP5yXGu9mgD0tbigrycA3V2ICXpB3IwXxc34FsoYKyLeERf5KsrYq4Gvjgv6oQSgH4kL+rEEoKfign4iAein4oJ+IQHoF+OCfjsB6Hfigt6fAPTBuKCPJgD9ZYK8v45L+Lm4GV/ske3Kc/4bQcbhs//w1I5xg2PBtZfsqA8T0VTLvnRmdvBsGVcMt8vmo3T2Hx4PIDMU/MPv7wrSIbeF0lDe6Nl/5eD8+sXld960dPzGq2+9+brF04xoGmnJUTofowFSUOIVS6eWT88fX758YeH04pkOx4YNRskSR6jEG+ZPnrpyoeOhJV5J1y6ePnNy6RTnGuqypGEqKeWYmi4F5fMh+bDlR4hTUYdTvSRwnABrhHikhZUT5ebpGvW4QmkDxEvJJ55fdkmn7OmxgDfsWhJ+HSX9Njmp29tjGxYIbxPhVkj3nJPuwG6Z/JwjLhXC36Ji+8Zx39ZjTucRVte2EKfNKpxadQ044FYUNnBTw5tt5Khs6ItrVx3/kpls8edOZKz/dMb61zPGvyRj/Nls8ae9jOMv4/o/d7zP6/9Mf8dfw+tv/ecWbfz3tf+zvv9m3f72e/vf5/2fuazr/2J/tz/2+c8+/9nnP/v8l5n97fOf08/+z7z/vZCx/Wf72//9/vzX7/bPuv+Rdf+r78c/5vq8/32iv+9/mY8/Z9z+TC/6eJgD/2Hw159f3kp4Kc55L5SEvsBwhA1wgEeJzreQXZhnITWerbUBWwWnrcIvvp226dipuTZgIFiUMUY2yA+vtkshSAMXfx3RM+vAMcxGwNxM/np78LdCedZah8Ux4BryjcbMNxQzXz5mvsGY+XI95Cs55jV6ZZGH61CB0uAfXr+3TfD308aD81FK2x6cj1Aa1tCUKQ0cOuI2ON9CacDbRmngNU5pWK+0nbi/YOA6YOA6bpBje3Nanq5d0isnyuo232DMfPmY+YZi5huNma8g8rFPt1Ma/ILfsAZtaLgT41jwu5fw8MsbDsouBGUDC+1ncw0j4efSw68zPsoGFtLzdP4Hpy1bpAWZvgzuC+DfjKvgnPnLfHmRr0Iyg5RvSOTDNfzs2+/Z4Bx+4/ZYa+2nQxh8cJvI6xVHKf1YOnw8XvtpWhuZsv7N9bglp3v9ed1kWYdT0yebeuBUJk4VRTuVe+DE6zvHFO1U6YHTGHHSXN/Zy5rTzcRpiyKnzT1w2kKcdJ5TOtfBdsNpqz6nZtuzSeBVnHaMMQelejbvlztG2PjLcYK/HMPpPbN69Qr5hnF1nnPq073GwjbipHRfqHMfnZ+H2QYp9l+a/adtQl9cu2vgp+hzi98jvtPntrexb2O/X21vY9/G/rmgu9/Pw7MvjxHy2CBwo3hWKI2fkeWY1rF0uJ/o9bl9nDjp9GNbfUYel/OPorBB2m3HuNBXjhlK/LTrjsV/c+Hb+LP4WeLb+LP4aeH7fQ6eA8Vf4PH4fBTPCqVx/wd7bvC87jVBR0NxDsDjse0yYV9L2Fp7VvQ6/wAeenuUzHq99veKxElz7qwobFAUNki7vSsKfXHtGvAdi22x+wA77bY3Dr6t5xbbYuti23pusb2Eh8Xe+Ni2nltsL+FhsTc+tq3nFttLeFjsjY9t67nF9hIeFnvjY9t6brG9hIfF3vjYtp5bbC/hYbE3Prat5xbbS3hY7I2Pbeu5xfYSHhZ742OnXc/5fWlefwk8fjc3imeF0njfB+bupshd8T3yRq/v2/N75Zp7AAAH3IrCBmnaN+dE7+91LuMrvvvUKAndgOEIfXGs97tPW8m+du27Dr7vyx06vmyUhG7AcIS+OMDD57Rdh1MzvoAzTvbdoWTfHJUNfXHt9gG+78udOr5slIRuwHCEvjjAw+d0ng6nZnwBZwfZdyfxSAmr6dudQldcu+cwtu+/XTr+a5QEZ2A4Qlcc4OFzOl+HUzOmgLOTbMs2SLvN2CX0xbXbB/i+Lyd0fNkoCd2A4Qh9cYCHz2m3DqdmfAFnF9l3Qsm+OSob+uLa7QN835d7dXzZKAndgOEIfXGAh89pjw6nZnwBZ4Lsu1fJvjkqG/ri2u0DfN+XNR1fNkpCN2A4Ql8c4OFzqupwasYXcPaSfWtK9s1R2dAX124f4Pu+vEDHl42S0A0YjtAXB3j4nPbpcGrGF3BqZN8LlOybo7KhL67dPsBXjK95v+xJHd51v+wLVXgvzPhlH1Qq24/v/U7nEVbnwMPndEDHT3XW13HSja0pJTvmqGzYDNewr2/ri0San+9QcI49zyEzRbY+TPIpznPWGR9lA+sQ6YLzU0EjUCGeHJtIc4QuLul4vdvW62LKm3Zcsz+A4Qh+OMBjmDinHdejTnvv3esXl69eWl48kyMs8H1O8M05q7lDhveJHqJznvPCXM0ApW01pI0b0nYY0nYa0nYZ0iYMaXsNaTWR5h98Dxqm80k65/YW9clkF4fkXGe1PZHOnNL83VEsO+3fkZZf49wV6WGx2U174Pv2iCjzWHDtJTz8so+qlN1q772gLLTb0OMo6QuZOwKF5ZwuuHnCTmgLUKa/fw/aKI9sCCzZjrokd5TKdg3lII+evVr39LpK2S1fTAdlwRfQo042hcydEb6Ypmv2Bcosk+0gy982OEJc7qJ7nVKcz+eIG/SXXNgmz+bbsve4bZ2Qh9djjIq0nNP5zY48XbtkH6zl4H2TSiJfSeRT3Gep5/2oeP2IznceZubYvt1w4n30ldbjdHznAdyKTmddSQnLy4ly83TtWmyLnSF22n0Ra3eLbbFXY9t6ZrEttj62rWcW22LrY9t6ZrEttj62rWcW22LrY9t6ZrEttj62rWcW22LrY9t6ZrEttj62rWcW22LrY6ddz3g/Fqz/4DUhvA4oimeF0rBeRXt/EuYEDEfwxLFFn5PHNuDvI1dEmr8W68hAm4/S+p55Xr+FtWIV4SNe0/W9gbbsdHCuvVasTGVwnEetHyuTPNb/Kq4p6/i+Itv0bQOr9Ze23mywyefJ1peRrStCp5zTtn8++Ad7VSgdMldQuZ8xlDvitNPKBixeS411oo7T+d1K4A8KmTHKB5krAw6yrjJ//+A1y47ggMM15BuKmS8fM99YzHwjMfMVYuarxMw3GDNfrod8JYMcr6kdoLRNohz+rmeB0kYFf95XbIjSZJtRIjz+NizwuM1jPPwFHt8/gVekNNSRzcTpBQPXAQPXokGO7S3vH3KvtDLJF3vMNxgzXyVmvkLMfCMx843FzJePmW8oZr4Bkc8/Bulc3mv86xEhJ+8JKAtyJWe1Hbl+jNDfsPsd11nI3E33pXuJw6goW7F/dgnb2hWcuX+otOdZxx5zuJdvE/h5kvkK9S2wT9aA0xkjbKtxUTbycD9hXJRtui/r7XU4M8e6FIQubBvIfCOEJ5eFfGjDUaZ/DRuzLNcjxCDkuO4Uieu9+n32uqkfbWpL4fdBITNK+SDz3RAbRvVrFXW9lHV119BVcd9Nj+2IOrNV4LMdH6D6yO9PcjvHttomykYero/bRNlr1UedNnG2Y1/CgtCFbQOZhyLqo9zjEPWRn/dgY26vkPYw3SeezLf1tzHYOh5RjMFHMonBVpsn916VMcj6DgoZvm9A5rEIXXTu8a36JO9v4Me+gMwvYt7fUGaZdN5O+intqzkd5ivGhK5hvoLMryJ8pbNvactX2B9S+moH8YTM0xG+Os/ptIvJV9D5PNJPaY/KRpivGBO6hvkKMr+N8JXOHqAtX2HfRemrncQTMr+P8NX5TqddTL6CzueTfkp7P86E+YoxoWuYryDzUoSvdPbWbPkKexhKX+0inpB5OcJXu51Ou5h8BZ13k35K+yjOhvmKMaFrmK8g82qEr3T2qWz5CvsBSl9NEE/IvBbhqz1Op11MvoLOe0g/pT0J58J8xZjQNcxXkPlPhK909nxs+aoalCV9tZd4QuZ/Eb6qOp12MfkKOldJv6qKfq3xmbV8xZjQNcxXK3vP5Ne2gbavakFZYb6CzFAITy4L+Uy+gh1qlIbfeRx7r0hjm6J8uY9l2Vm996KJV82QD/LQTXPfN7+8fUFZBaEL7yE4Sfg5J91nGfYv85kkfJ391OrNvS+wV5JDGHzk6fwAcdqvwqk1Vw8ccCsKG7ip4V3SrHsHhL64dvXxZzPGb2SLP3dptvjTGft/7kSfx9+M9X+m+HN9bv9pW/8z1X8xY/yZrO+/3Oe8iuYwDhJein2+RknoCwxH2AAHeJTo/ADZhXkWUuPZmus4KDgdFH7R27e31TceCBbiXEg2yA+vtkshSAOXobP/nlkHjmE2AuZm8hc//+2j35Emn71ywuYcq1V1/byOewPmpKYEPtfX9+fbPA4FaQPCLlXiepEoG3n4mewiUfZaYwM6z2itNRByH2hZD5n7B0N4ckzzHCXiF3aoBb9xPUPcp62fX1f+WmjzWxmvGW5jK8VXxx7X0B/4sHGFZPh7e3IsA/I8BwkbDwqZGuWDzEJEfOl879EcXzWhL8fXDV3GF4/7yPiCP7OIL/iA40tpvt4YXzIGOL54nnlK5IM8x5cc24TMFOWDzHJEfOnMcZvja0roy/F1e5fx1dHvEPElv8W6nvEFH3B8KX3XyRhfMgY4vnhuXI6dQ57ja6WuCBkeO4fM5yLiS2de3hxfpnl5yNzdZXzViK+MLznevZ7xBR9wfOk8K5jjS8YAxxfP58s5AshzfK3UFSd6zuNrEfGls5bAHF97hb4cX9/qMr64TyPjy/Scs17xtdJnofiqqdjWHF8yBji+eA2CfO6BPMfXSl1xzH07jucfRMSXzvqH8P49r3+AzI9t/77bo+f+Pa+bSLt//5OI+NJZsxHev+c1G5D5me3fd3v03L/n901l/x7jMWH9e8iY+vdPhPiN3zXmuibtIvvN/M43j3ehjE0h+kwZypJ9h3Vat63ynsTTEfXE9J7EEVqPfZTS/aKwRuNiwoLM8/m27COFtr0OE/cU7dWcEzgSlOUKfsBU7Hd6XK9kn+gwpUPmjzTuh3UJGPc7IvKZxhSRh9+dPiDKXqvdPqRjA+PYLrD4ezHgPihkuI8DmT9F6KKzpmOhY45F9nH2E0/I/CWEJ5eFfFNCZ9+PsNF6rFkxcZL6+TKYR5D9BY5HyPw9wleTKrq0fIW1T/AV+E0ST8j8K8JX8puhU0LnMunM3xPFufx2pkt5uWyXZOVYfJh/Dhm4hvkHMm9E+Edpzdo093EcwnCEfjjW4Vu4Df4Wbjec9hEnnThurSPbJ2xQpDTHSfd+tU/oimv3HMb2+zgHhY3Z7tw/iOJYccxrH5VitrlHC/pXwPDbuwr1r5Tu7c01d4cJk/t63O+BzOOFtuzW4LxMebhvLu//pmcUXMP2ZWf1t12Zo+TDz3VKNvL05lRb9sd9uSBswm09ZCYCm691j9sv7CR96dtX9gcU9asrtquNXvsHkxG2u2AN23H/ADZba012mvdXzfskjyvBdtBjH9kAMocibFdbw3aTZDv5jXqu67zOvybSTOXLcUNug/Cbov0uzQkO/FzKfQql+baOd2rw7LhX4OdJ5q2FNg/+5jHbkm21R5Q9QXZG+h5RdjfvquScdNsWnfevzO8Cwk5sG8hcFmIDHqvkZ385Von41R+rnPXkWGU1KJfHKnXGgVvPqPLdSODzWCVkOH6OinyQ5/sXbCzXIvA3jyHz3ojY1XkX0/z+IvjtJp6QeV+X8VUlvjK+4M8s4gs+4PhSGjOss22hv4yBCslw/1SOc8k+ALefg0KGx7kg8+GI+Kqq2MAcX3LdIcfXR7uMrxrxlfFl6pOvV3zBB+vVfsn4kjHA8cXjbvI5Ro7rcL9Cjv3weDNkboyIL51xRnN8HRb6cnwtdRlf/G33jdR+mebyaiq2NceXjAGOLx7fk88wkA9rvw6LctjWn4yIr6MqNjDHF/jxfRwyn+4yvritz24twur4WumzZNR+yRjg+PKIR03kgzzH10pdETI1ygeZeyLiS7N/L+c9Tf17yHwphf59lu3XynzCOq3Vk/10GQMVkuE5xAmRr5f+Pa8hgcy9EfF1RMUG5viaEPpyfN3XZXxxW5/dWr3s+/drPQfCxhxfQ8RD9u8hz/El594gw/17yDyQ4f0RcST793x/hMxDb/L+/UqfheJLaV6zzraF/jIGKiRzIaVhzHKCbIs8PJ4p41DWXdN8llxzo9N2mesXxv0YU7bDkDGNszwWEX8yry9+V2AMHifm+aX9Is00/4FrHifGXMj+kHym5/7J4Fw+9/PzDmSejGgXdGK3tWaC5xDZBty/h8xTEeP6cq50SuhcdlbPGyjWTeO8xVGDfpB5PoV+m5yj1Gv3vIZs91bWVFG7pzSnUTf174HP42aQmSR7KM291rnegZOc0zS1RXL+iduil0Jigttd6M7PZwcNmLJ8bsORto/Kktx4rt8vB/H3N5prf4ViArGA2PV/et3wu0NcHcF15Zzialgnppt9lSJxzRMW448QfprzRIyPsoFVpLqO8//SXNnIcKfdYHPwb34bIThn/jLfoMhXIZkhyjcs8uEaMeVT+wfFBfzu7/v+f9q1wR0tMQEA","debug_symbols":"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JkjRBBU0QRVNEJpTFzSnLmhOXdGcuqI5dUVz6orm1BXNqSuaU1c0p65oTl3RnLqiObWhObWhObWhObWhObWhObWhObWhObWhObWhObWhObWjObWjObWjObWjObWjObWjObWjObWjObWjObWjOXVDc+qG5tQNzakbmlM3NKduaE7d0Jy6oTl1Q3PqBubUsm1gVn1SBObVJ0VgZn1SBObWJ0Vgdn1SBObXJ0Vghn1SBObYJ0Vgln1SBOfZAufZAufZAufZAufZAufZAufZAufZAufZAufZAufZCc6zE5xnJzjPTnCeneA8O8F5doLz7ATn2QnOsxOcZ2c4z85wnp3hPPv17+jdSLZ74eOPBSh7AYW9gMpegLEXgBRx2lUAUiTqwePV9zAaqc8SIsujekXKT325eqSw1ZerR0pmfbl6cPoG6sHRG6gH526gHhy6gXpw4gbqwXEbqKdmbaFmbaFmbaFmbaFm7RtcRB6pnpq1hZq1hZq1hZq1hZq1lZq1lZq1lZq1lZq1b3CVfKR6atZWatZWatZWatZWatYaNWuNmrVGzVqjZu0bhAGMVE/NWqNmrVGz1qhZa9SsdWrWOjVrnZq1Ts3aN4hzGKmemrVOzVqnZq1Ts9apWduoWduoWduoWduoWfsGgRwj1VOztlGztlGztlGztjGzVjZw1lrO+9NWypV6cNYG6sFZG6gHZ22gHpy1gXpw1gbqwVkbqAdnbaAenLWBenDW3lYv1KwVatYKNWuFmrVvkIIzUj01a4WatULNWqFmrVCzNlGzNlGzNlGzNlGz9g3Si0aqp2ZtomZtomZtomZtomZtpmZtpmZtpmYtepJUoJ6ategZUoF6ataip0cF6qlZi54bdVs9em5UoJ6atei5UYF6atai50YF6qlZi54bFainZi16blSgnpq16LlRgXpq1qLnRgXqqVmLnhsVqKdmLXpuVKCemrXouVGBemrWoudGBeqpWYueGxWop2Ytem5UoJ6atei5UYF6atai50YF6qlZi54bFainZi16blSgnpq16LlRgXpq1qLnRgXqqVmLnhsVqKdmLXpuVKCemrXouVGBemrWoudGBeqpWYueGxWop2Ytem5UoJ6atei5UYF6atai50YF6qlZi54bFainZi16blSgnpq16LlRgXpm1ibq3KhEnRuVqHOjEnVuVNqYWZuoc6MSdW5Uos6NStS5UYk6NypR50Yl6tyoRJ0blahzoxJ1blSizo1K8LlRdk61Nb9Wj87a2+rRWXtbPTprb6qHz426rR6dtbfVo7P2tnp01t5Wj87a2+rRWXtbPRKtHhUhEehRERJVviiCSj16VITk/o+KXt1VctazImt2uy9zy3tf5qYXKZLtSb9B69fTt6f75knzgX4n19+49b9+Wstg/UKuP5Hrz+T6sf0/1l/I9Vds/eLttn5w/ob6wfkb6gfnb6S/gPM31I/O33rR736gH52/kX50/kb60fkb6Ufnb6QfnL+hfnD+5vPPsDTrkX5w/ob6wfkb6a/g/A31g/M31A/O35zqRX870A/O31A/OH9D/eD8DfWD8zfUj87fSD86f5/pL/VAPzp/A/2Gzt9IPzh/S9qVaMlH+sH5G+oH52+oH5y/oX5w/mrbLvrtK/0Hm6fLpyBOJ+vytG9P1YLTenC14GwfXC34JDC4WvC5YWy1Dj5lDK4WfCYZXC34BDO4WvB5Z3C1ulS1S81SvtQs5UvNUr7ULOVLzVJtqVmqLTVLtXsiUDHbZfvlnd8TZZ9qvSf+RLXek0PVbX+4bvWq1rzdkz9Ftd6TO0W13tP3eVGtvN/lPepX8He16/mnOnXziJp5ly3PfoKYZf+3Amfm0FrBmTm0VvDv2IbWCv792tBawWehkbUK+Cw0tFb0n8S/qNbLN2ptO6gV/af2I2tF/wn/yFp1oVrvam4Kar2ruSmo9a7mpqDWe5qbkuwf1U5ZDmq9p7kpqDXd09wU1XpPc1NU6z3NTVGt9zQ3RbXqQrWCz001nW/816P3BhP4LBTqB59vQv3gM0uoH3wOqeV8Y7X69Y35nMFni1A/+LwQ6gefAUL94FwP9YOzOtSPzt9IPzp/I/3o/I30o/M30k/OX/TEu1A/OX/RE+9C/eT8RU+8C/WT8xc98S7UT85f9MS7UD85f9ET70L95PxFT7wL9ZPzFz3xLtRPzl/0xLtQPzl/0RPvQv3k/EVPvAv1k/MXPfEu1E/OX/TEu1A/OX/RE+9C/eT8RU+8C/WT8xc98S7UT85f9MS7UD85f9ET70L95PxFz7AL9ZPzFz1nLtRPzl/0LLhQPzl/0fPaQv3k/EXPVAv1k/MXPfcs1E/OX/RsslA/OX/R88NC/eT8beT8beT8beT8Rc+IC/WT87eR87eR8xc9Sy/Qr+j5eKF+bv4qeo5dqJ+bv7px81fR8+ZC/dz8VfRcuFA/N38VPb8t0o+eyRbqJ+cvenZaqJ+cv+gZZ6F+cv6iZ5GF+sn5i54ZFuon5y96tleon5y/6BlcoX5y/qJnZYX6yfkLn38V6SfnL3z+VaSfnL/k+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnn+l5PlXSp5/peT5V0qef6Xk+VdKnh+l5PlRSp4fpeT5UUqeH6Xo+UXatn3zku0r/ddPF7Ndtl9+J3jy8lQruNcOrRX8+6KhtYIzaGit4Lx6Ua31/Lsta8rXtaJnMw2tFZyDQ2sFZ+bQWsG/P3xZrVs716oHtepCtd7T3BTVek9zU1TrPc1NUa33NDdFtd7V3LTtD9etXteKnqk1tNa7mpuCWu9qbgpqva+56XatulCt9zU33a71vuam27Xe19x0u9b7mptu17rO3FTQs9CG1rrO3FTQM9aG1rrO3FQ2XajWdeamgp4JN7TWdeamgp41N7TWReam309//M+7n9+/++7D97+clnz+218//vPT+x8/Pv3x039/evyb08P/Aw=="},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"increment","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+xdB3xUxfOPqfTeawClKMjbu0vuonRBuhRpKghJLgdIbyooxUIRARERAQFBmkiRLk1QARFBUUCxV1CxYQcb/mfh8ssQF5K7mznf/L33+XzNZOVtvjsz+919u3vvLos6f31TIiqqSLHz9mWAGP/PaEBitrLMn9iONZTFG+4tYCgrZCgrYigrZigrDWiUrayy4d8lGsqqGMqqGsqq+8vwdZn/ZyP/T6eV7HJluB0ZyqlSLUdKmifJciWlJXuURyV5krwOj9OZ4XF53ClpKW4rRbmcGcqXlOL0WeevZ6Kz6rJCuhzpnDzXBs1TqewlmfGLRVy1H8767RpRWXZNZK/1/5vM+9bB7+sBGwAbo7NyMXvd61Dd65G9Adkbs9W9CX7fDHgWsOUSdW9CdWxG9rPI3pKt7q3w+zbAdsCOS9S9FdWxDdnbkb0jW93Pwe87AbsAz1+i7udQHTuRvQvZz2er+wX4/UXAbsCeS9T9AqrjRWTvRvaebHXvhd9fAuwDvBydVR6F6tVXI//PUPN5P1m/yzmf9yJ7f/TF8/kV+P0A4CDg1Uv49xVUxwFkH0T2q9nqfg1+PwR4HfDGJep+DdVxCNmvI/uNbHUfht+PAI4C3rxE3YdRHUeQfRTZb2ar+y34/RjgbcA7l6j7LVTHMWS/jex3stX9Lvz+HuB9wAeXqPtdVMd7yH4f2R9kq/tD+P0jwMeATwz5HO3/2cj/0wrtUtWj6PrGp3R9Q+HxVNebyOwHzD1UP3zG5IfP/H6Iy+aDzHmI6aLh4UrhqTc5g6leJ0+9bgcT3ySmer3C+DLlg9vFxFdav3Dz1OuwmPgy9eNkH0+97ki/OM+XyQ9c+suWv8lM9XLlrzT/cvmBSSfZdD3S387zTeOp18nF15u5Boqvy0j/hqVq0NX1Dz8YCYf6AHWc+AEqb9SFD0vHo/+5aKivE9HnH67yR/0zKByBOUG8mJR5fR7NSFhXTl3vF4RP31zt/iI6y8FE9VqcyfUFYXLpTqF3YqKj/nlR8y4ZxatWIdb9v10J7Isv/b+cjI66cCtI/48Ps5WdNCxnxTA6McgO5fB3KPUlYec8Gc0TXOrlQMo2f2WoK81K9yaptGSvW2WkJnnS01OcSjlSk1OT0xweX0ZakvIkeaDO9FSHB/6cIzVdZVipyRnhHJ2+Yhqdvo5mJPw1w+j0jc1HJ93ub5hGJ+qp3Uk/V6oOm1kvZYy+JU78TOHX9VaJuvCiFq6ThH74js4PSdgP30Xzn484RcZduTl5fo94qqTkjNQ0n8eV4YRBwfK6rAyn02k5HC6fw+vI8Khkl8fn83l8yufOSFdp6clQvduZng4DQ0pSipczr04Q5tUPdHnFenblx+B5OrMXmPaHT6HH0O+R/QOyf4y+cH/4J/j9Z8AvgF+jz5fHRWWdvcp+UY81XBM4ap4/EfKMRzxP+518xv/zN//P3/0//4jOOn+krz/h9790DAF/638DIngZIBoQA4gFxAHiAQmAPIC8gHyA/IACgIKAQoDCgCKAooBigOKAEoCSgFKA0oAygLKAcoDygAqAioBKgMqAREAVQFVAtewH9P7IxZNJqJ2KMDDqDKEoXR5D+7gcrlk6JW/M94oYRsK6cup6q8fYe5au2109JsvBRPWeS7boqPCoP6WqcvI8w/ToWgPlLfl0ozpdT77g2FAm6ThUxp0olAHAiV3T34Fq6TZxBKAGgzLViKHtNVztjmZsd6gcr2T2oRXapXRiXhlDH5uriIf3TAHQ9Y7z10vti1pMvqjN5IvajL7QQsjhi8ZF7K0pXP2hyb/b7vQc+LHl/nVFeGZe1BtPhHmpCGOtKP2nJ1J63cU0444K0J855ROuk2PMovIJnlTWudQs2QrtUlcyDQKYdICcVU5/R3OuwyAKzZlEITbAmAUyeQu1zVfH2FNgKGOB8/JqNDkJNj45+ZwyPnVRXcrphL4Be9w+r8+Z5E5xpKlkZ3Kyz+VzJ3tcXl+SK9XrzlCuVKcjJcNt+ZQnI8Od5Ex3J/tSvOnJPizayut0urwpaekqyZGcmmZ5vM5Uy+dyOx1Wqtfp9nqdnuTkVKfTm+zxeVI8Dkeqz+mxktzuFCvZ4UxxcMWnrj8+4Xy6plyGwYOY5Z8NKCkCzsXPYhBrB9PA5WB8etG+UAy+cDL5wsnoi5+YnuRa2vxJjqs/tLL5kxxX7rcW8iRHmJeKMNaqdeRJLvulLKYnOZfEJzkX85Oci0EU2v0Hn+SSYuwpMO2YnhSShD3JJRM+ybUmfJLjik8yepK72KBg5yU4Tp5cA4xb4gDjZh5g3AwDTIcwDTCU+7w22iu6YIAJlVfHMD0BhMrTQzhAE+af6sg0AHhyMUCH6tOUGLqB8ILlURsN0B2Y4pPy/2ip9Rp/Z73WdJDJCu1SFzvQQ3lCLdS6CA9FKY7AZ/qQWlS5fBhqXfVsHg/dYeoxTIzqM00S6zMuRV/L5IsGTL5owLwsz+GLzjZflufqD11svizPlftdhSzLE+alIoy16hpZls9+nRuzqHyCJ7sNOVdN6jENAg0ZV00054YMonCLkGX5eoQTwUYx9hSYW5ieKhuFYVmeMj6NCZfluxI+9XPFp/G/8NTP9fGlJv7ZwHVSBJyLXxMGsW7KNHA1ZXx60b64jsEXzZh80SyG96MyHDP7HjZ/kuPqD7fa/EmOK/d7CnmSI8xLRRhr1TPyJJf9Uk2YnuSul/gkdz3zk9z1DKKQ/h98kmseY0+BSWd6Umgu7EmuBeGTXE/CJzmu+LT4Fw5YXRPD0++lDDAtJQ4wLZkHmJYMA0yGkANWlALWhWkGGyovn5ADVq0IB2jC/FM+pgGgVRgOWLUmPGDVtYg9B+gMpvi0NsSH+qkXH6gKNda/E9bVhnAsC+f7/9owTRzaxjASbhtDX+8NhAMbV7tviMlyMFG9YX3/H+5wVogXJ0/KU5u4U7S71Gw61KS7gXA2gFU9k/T/h2Oz7f0dqIPp2CxFANoxKFM75g05qnZHM7Y75M9M2HxTUydmR4bHyhuZHrFvZNzI68Dki05MvujEfDyVwxd9bb6pydUfbrP5piZX7vcTsqlJmJeKMNaqX2RTM/t1bsyi8gmeVHbmXHPuyDQIdGZcc9acOzOIwiAhm5odKdecY+wpMIOY1uS6hGFTkzI+XQk3NfsRrplyxafrv3A8lXIZBg9i3fyzgZukCDgXv24MYn0z08B1M+PTi/bFTRyfq2DyxS2Mvvid6UluiM2f5Lj6w1CbP8lx5f4wIU9yhHmpCGOthkWe5LJfqhvTk1x3iU9y3Zmf5LoziMId/8EnuR4x9hSYO5ieFHoIe5K7lfBJbhjhkxxXfG79F46nto/h6fdSBpieEgeYnswDTE+GAWakkOOplAJ2G9MMNlReo4QcT+1FOEAT5p8axTQA9ArD8dRUwuOp/YrYc4AeyRSf1P9HS61p/s6abjrIZIV2qYsd6KE8oRbyG88JxYUj8Jk+pBZVLh+GWpfX5vHQHcbL8bkdpkliBuNSdDqTL3xMvvAxL8tz+GK0zZflufrDGJsvy3Pl/lghy/KEeakIY63GRpbls1/nxiwqn+DJbm/OVRMv0yDQm3HVRHPuzSAK9wlZlvcSTgT7xNhTYO5jeqrsE4Zlecr49CVclh9L+NTPFZ++/8JTP9fHl27zzwb6SRFwLn63MYh1f6aBqz/j04v2RT8GXwxg8sWAGN6PynDM7Mfb/EmOqz9MsPmTHFfuTxTyJEeYl4ow1mpi5Eku+6VuY3qSGyjxSW4g85PcQAZRePA/+CQ3KMaeAvMg05PCIGFPcoMJn+QmEj7JccVn8L9wwCothqffSxlghkgcYIYwDzBDGAaYqUIOWFEK2BimGWyovKYJOWA1lHCAJsw/NY1pABgahgNWwwgPWI0tYs8BeipTfIahATpc76/7I5pn4Bsew0h4eAx9vSMIhZmr3SNishxMVG9YX5b4O1Oy3R7DSPh2hmS7w+bJptt9B0OymbhSnOjzxtC/Po1ypnanzfeEtLDcwfGxhxh7547+Nuh6DLlD+ZbvUTb3oc7tkTH06/OEfUaNJIzHXTaPh86Xuxj68t3MJ5RD5af3L+9maPfDReyt3WeY2j2D6SmeWmsJ46NmEO+9hWtiTfmFmZjv6BhGwqMZJtZjbD6x1u0eI/wp7jemZBsbw0h4LEOyjbN5sul2jwvTU5wV2nWu445jGMXusfmTl37quoeh3feGaeMt5CPewfN0ZS/Q3EpHZa1p69+14J71278h+w9kaw5n0X33w+/jARMAE2OyyjMv6icdwmUxdT+hJk0i3l/MHptJMVkxGI/sCciemC02D8DvkwEPAqbEXFgfZV7qFZF7OfYpCZ+iMmfSURfxgRXapU4TDvQ1/fVMg/Y/BJgOeBgwA/AIYCbgUcAswGOA2YA5gLmAxwHzAPMBCwBPABYCFgGeBCwGLAEsBSwDLAc8BVgBeBqwErAKsBqwBvAMYC1gHWA9YANgI2CTfyUI78lM8+cALnvIUDbdUPawoWyGoewRQ9lMQ9mjhrJZhrLHDGWzDWVzDGVzDWWPG8rmGcrmG8oWGMqeMJQtNJQtMpQ9aShbbChbYihbaihbZihbbih7ylC2wlD2tKFspaFslaFstaFsjaHsGUPZWkPZOkPZekPZBkPZRkPZppgsjcm8Aj3gFYjmhHwOISb0ujJ856+HYuh4PWrzsyr+Nnun0/kv5WG6utQMwljMEhGLDPUImf/S1UyyujzqUcJYPCYiFpaaReW/DEs9RlVXuqVmE8ZitoRYeCw1h8p/MPbMJaorA+p6nDAWcwTEIh3aPI/Ifx6oaz5RXdBktYAwFnPtH4sM3eYnaPyXrutaSFOXR9e1iDAWj9s/Frpq9SSJ/zLO1bWYpK70c3UtIYzFPNvHwnOuzUtJ/HeOplpGUVfG+bqWE8Zivt1jkX6+zU9R+M9zvq4VFHWdb7J6mjAWC2weC6+/zSsJ2pzmr2sVQV1uf12rCWPxhL1j4cj8JO2a0NusMut6JuS6PL7MutYSxmKhrWPhScts87rQ/fe/T0ivD7ku9//q2kAYi0W2jkXS/9q8MeQ2q//VtSmGbs3yUcLPTj1pkw9K53ApwnUzRbjuo2YTxmKxkFgQrg8owudb9ThhLJYIiQXhc5AinMerBYSxWCokFoTzPUU4X1GLCGOxTEgsCMc1RajLaglhLJYLefMRYf9VhPmnuPwXnc1/dthXzqxrM+E8VNdBfQZIn7eaGkN/DurZGNpYU7f7z+issz+U7d5u80+T6Hx8lqHdO4S8E2ILYX8kjLXaYfO80f1lM0Pe7LJ5u6cx9ZfnhfSXrYT9hTDWist/1HHeFrz/HNkLNLfsZ6y1nmWepd6K7P3RWfa2mAvPWG+H33cAngPsjLn4GWsrtEv9FZ11lpbSp7tt/sZZ3ebtDO3eI+RZcDvh/HkXof4Q5o2SEgvdB6li8XwMTx+2U78waewupKvP51JjX4DfXwTsBuxh1Niz0VmfTcD1hurTfTbXWN3mFxja/bKQfv0CYV/cS6ixhHmjpMTiLKHGvhTD04ft1C9MGrsX6epLudTYffD7y4D9gFcYNfbv6KzPeuF6Q/XpAZtrrG7zPoZ2HxTSr/cR9sUDhBpLmDdKSiz+JtTYgzE8fdhO/cKksQeQrh7Mpca+Cr+/BjgEeJ1RY/XC1QwGrTlkc43VbX6Vod2vC+nXrxL2xTcINZYwb5SUWEQRxuJwDE8ftlO/MGnsG0hXD+dSY4/A70cBbwLeYtTYy2Ky3kWA6w3Vp0dsrrG6zUcY2n1USL8+QtgXjxFqLGHeKCmxuIwwFm/H8PRhO/ULk8YeQ7r6di419h34/V3Ae4D3GTU2Oibr3S643pD7nc01Vrf5HYZ2vy2kX79D2Bc/INRYwrxRUmIRTRiLD2N4+rCd+oVJYz9AuvphLjX2I/j9Y8AngE8ZNTYmJutdWbjeUH36ns01Vrf5I4Z2vy+kX39E2Bc/I9RYwrxRUmIRQxiL4zE8fdhO/cKksZ8hXT2eS409Ab9/DvgC8CWjxsbGZL17ENcbqk8/srnG6jafYGj3x0L69QnCvniSUGMJ80ZJiUUsYSy+iuHpw3bqFyaNPYl09atcauzX8Ps3gG8B3zFqbFxM1rtccb0hz21srrG6zV8ztPu4kH79NWFfPEWosYR5o6TEIo4wFt/H8PRhO/ULk8aeQrr6fS419gf4/UfAT4CfGTU2Pibr3di43lB9+oXNNVa3+QeGdn8ppF//QNgXfyHUWMK8UVJiEU8Yi19jePqwnfqFSWN/Qbr6ay419jT8fgbwG+B3Ro1NiMn6rgFcb6g+/drmGqvbfJqh3d8I6denCfviH4QaS5g3SkosEghj8WcMTx+2U78waewfSFf/zKXG/qV/B/wdc76QS2PzxGR9dwuuN+TnR5trrG7zXwzt/l7K5zcJ++JlsXS8CPNGSYlFHsJYRMfy9GE79QuTxuoczNTS6NjcaWyM1lVAHCCeUWPzxmR9FxauN1Sf/mRzjdVt1j6mrvdnKXvZhH0xgVBjCfNGSYlFXkKNzRPL04ft1C9MGpuAdDVPLjU2Lxj5APkBBRg1Nl9M1ncL4npD9elpm2usbnNeBo09I6VfE/bFgoQaS5g3Skos8hFqbKFYnj5sp35h0tiCSFcL5VJjC4NRBFAUUIxRY/PHZH1XK6435DU6m2usbnNhBo39U0i/LkzYF4sTaixh3igpschPqLElYnn6sJ36hUljiyNdLZFLjS0JRilAaUAZRo0tEJP13de43lB9+rfNNVa3uSSDxkYVldGvSxL2xbKEGkuYN0pKLAoQamy5WJ4+bKd+YdLYskhXy+VSY8uDUQFQEVCJUWMLwt99gkFjY4raW2N1m8szaGyskH5dnrAvVibUWMK8UVJiUZBQYxNjefqwnfqFSWMrI11NzKXGVgGjKqAa4HJGjS0Ef3chg8Ym2FxjdZurMGhsHiH9ugphX7yCUGMJ80ZJiUUhQo2tHsvTh+3UL0waewXS1eq51NgaYNQE1AJcyaixheHvLmLQ2Pw211jd5hoMGltASL+uQdgXryLUWMK8UVJiUZhQY2vH8vRhO/ULk8ZehXS1di41tg4YVwPqAixGjS0Cf/dJBo0tbHON1W2uw6CxRYT06zqEfVERaixh3igpsShCqLGOWJ4+bKd+YdJYhXTVkUuNdYLhAiQBkhk1tij83cUMGlvc5hqr2+xk0NgSQvq1k7Avugk1ljBvlJRYFCXUWE8sTx+2U78waawb6aonlxqbAsY1gGsB9Rg1thj83SUMGlva5hqr25zCoLFlhPTrFMK+WJ9QYwnzRkmJRTFCjW0Qy9OH7dQvTBpbH+lqg1xqbEPtK0BjQBNGjS0Of3cpg8aWt7nG6jY3ZNDYCkL6dUPCvngdocYS5o2SEovihBrbNJanD9upX5g09jqkq01zqbHNwLge0BzQglFjS8DfXcagsZVtrrG6zc0YNDZRSL9uRtgXWxJqLGHeKCmxKEGosa1iefqwnfqFSWNbIl1tlUuNbQ1GG0BbwA2MGlsS/u5yBo2tZnON1W1uzaCxlwvp160J+2I7Qo0lzBslJRYlCTW2fSxPH7ZTvzBpbDukq+1zqbEdwOgIuBHQiVFjS8HffYpBY2vYXGN1mzswaGxNIf26A2Ff7EyosYR5o6TEohShxnaJ5enDduoXJo3tjHS1Sy41tisY3QA3AW5m1NjS8HdXMGjsVTbXWN3mrgwaW1tIv+5K2BdvIdRYwrxRUmJRmlBju8fy9GE79QuTxt6CdLV7LjW2Bxi3AnoCejFqbBn4u08zaGxdm2usbnMPBo21hPTrHoR9MZVQYwnzRkmJRRlCjU2L5enDduoXJo1NRbqalkuNTQfDC8gA+Bg1tiz83ZUMGuu0ucbqNqczaKxLSL9OJ+yLvQk1ljBvlJRYlCXU2D6xPH3YTv3CpLG9ka72yaXG9gXjNkA/QH9GjS0Hf3cVg8a6ba6xus19GTTWI6Rf9yXsiwMINZYwb5SUWJQj1NiBsTx92E79wqSxA5CuDsylxg4CYzBgCGAoo8aWh7+7mkFjr7W5xuo2D2LQ2HpC+vUgwr44jFBjCfNGSYlFeUKNHR7L04ft1C9MGjsM6erwXGrsCDBuB9wBuJNRYyvA313DoLENba6xus0jGDS2kZB+PYKwL44k1FjCvFFSYlGBUGNHxfL0YTv1C5PGjkS6OiqXGnsXGHcDRgPGMGpsRfi7zzBo7HU211jd5rsYNLapkH59F2FfHEuosYR5o6TEoiKhxo6L5enDduoXJo0di3R1XC419h4w7gXcB7ifUWMrwd9dy6CxzW2usbrN9zBobAsh/foewr44nlBjCfNGSYlFJUKNnRDL04ft1C9MGjse6eqEXGrsRDAmAR4ATGbU2Mrwd9cxaGxrm2usbvNEBo1tI6RfTyTsiw8Saixh3igpsahMqLFTYnn6sJ36hUljH0S6OiWXGjsVjGmAhwDTGTU2Ef7uegaNbWdzjdVtnsqgse2F9OuphH3xYUKNJcwbJSUWiYQaOyOWpw/bqV+YNPZhpKszcqmxj4AxE/AoYBajxlaBv7uBQWNvtLnG6jY/wqCxnYT060cI++JjhBpLmDdKSiyqEGrs7FiePmynfmHS2MeQrs7OpcbOAWMu4HHAPEaNrQp/dyODxna1ucbqNs9h0NhuQvr1HMK+OJ9QYwnzRkmJRVVCjV0Qy9OH7dQvTBo7H+nqglxq7BNgLAQsAjzJqLHV4O9uYtDYW2yusbrNTzBobHch/foJwr64mFBjCfNGSYlFNUKNXRLL04ft1C9MGrsY6eqSXGrsUjCWAZYDnkIam3lFE8e5aBSdP5fG2ltffwPn3c0wrqwgbHcc1JEftR1f1OMsJW/M9+lYRsJPx9LXu5JQoLjavRIpAVG955JNIzqKP9lqRPEMfNQ8T0bT8SyAeK7yx2+1/+ca/89n/D/X+n+u8/9c7/+5wf9zo//nJv/Pzf6fz6L+QP/mAcJZlOYW4+e4xk8al60zlG00lGU2OJxKuYpJKbfEMhLewqCUW22ulLrdW5mUMlzJtpop2bbFMhLexpBs222ebLrd2xmSzcQ15M+F+TsG9fMDpSDsEDqPfoapwz4Xy0j4OYYOu9PmHVa3e6fw0WEtU7LtimUkvIsh2Z63ebLpdj8vZHRY5+8Y1KMDpSC8wLy6ZIV2nZut7GBYvX/R5u3WOf4CQ7t3C50NrGcS6D2xjIT3MAj0XpsLtG73XuGzgQ1MyfZSLCPhlxiSbZ/Nk023e5+Q2cBGf8egng1QCsLLNh8V9ai9m2FU3G/zduscf5mh3a8InQ1sYhLoA7GMhA8wCPRBmwu0bvdB4bOBzUzJ9mosI+FXGZLtNZsnm273a0JmA8/6Owb1bIBSEA7ZfFTUo/YrDKPi6zZvt87xQwztfoO43ZlXNDFPyoMlhwn34jlirXPxDYZYH2GKNTXPo2Q8nS5Onm8Gz9ObvcB06lH7IfN04ypkr0b2m7EXnnp8C4xjgLcB78T+89RjDHGuriHsS28R9vF3mXKd2n+EO57qGKH/3hPiP8JNPPU2of/eJ36AyK4N7yINeA/Z7yP7nWza8AEYHwI+AnwcBm1YRxibDwhj84mQ3Cbc/1AfEvrvUyH+I1zSVx8R+u8zZm34BGnAp8j+DNkfZ9OG42CcAHwO+CIM2rCRMDbHCWPzpZDcJlwNVScI/XdSiP8IF/jU54T++4pZG75EGnAS2V8h+4ts2vA1GN8AvgV8FwZteJYwNl8TxuYUc2xOoRh8g+xvkf1dtth8D8YPgB8BP8Ve/JPEFGsmRxjWLg8Txudnm6/h6Vj9zLCu84vN2831acFfbd5undu/MMS7p80/fa/b/StDu3sxfeKbWtMI46Mo26w3UOOjwrOBSvkhxcsQx4J++zTk1xnAb4DfAX8A/gT8pcdHwN96IIQGXwaIBsTEXeLDfVZolyL8cN+5IBWICs8nSX9jmqxH0fJ0YF/Exp3/GRcXdeGnGfX/+CtbWVzcP7Oderb6G8EMJsN3/tJtCLWuTLWMi5OhlpRtjkd1KY/T4XA79b/zeC3l8qY7PA6HN81lpVup6Y6MFJdK8bkcLme6Nz0N6kxVPsuXmp7i85znFc7jJvFx9Gqpr4Q4RsIJcfT15iFMBq5254nLcjBRvSzTsDg/V+p68xIna6ZY63q1uIRzBPxT4AiYz59/+bOPgPkMI2D+MIyAfxKOgPkIBSC/kBGQss0FhI6ABZhGwIJxjIQLMoyAhWw+Aup2FxIyAub3c6WutzDTCFj4XxgB/xY4Ahbx51/R7CNgEcMIWDQMI+DfhCNgEUIBKCpkBKRsczGhI2AxphGweBwj4eIMI2AJm4+Aut0lhIyARf1cqestyTQClvwXRsDoOHkjYCl//pXOPgKWMoyApcMwAkbH0Y2ApQgFoLSQEZCyzWWEjoBlmEbAsnGMhMsyjIDlbD4C6naXEzIClvZzpa63PNMIWB6NgOHqeKdjeTpehThGwhUYOl5Fm3c83e6KDB0vnMl2hinZKsUxEq7EkGyVbZ5sut2VBe11VYyjn5ZRCkJinMwO+ztTh60Sx0i4CkOHrWrzDqvbXVX46PAHU7JVi2MkXI0h2S63ebLpdl8uaB+oKsPoQCkIV8Tx+tAK7To3W0lkeI6qbvN26xy/gqHdNYTOBv5iEuiacYyEazIIdC2bC7Rudy3hs4GzTMl2ZRwj4SsZku0qmyebbvdVgvbEajHMBigFobbNR0U9atdgGBXr2LzdOsdrM7T7aqGzgSimLZu6cYyE6zIItGVzgdbttoTPBi5jSjYVx0hYMSSbw+bJptvtELQ/aDHMBigFwWnzUVGP2lczjIoum7db57iTod1JNm+3jksSQ7uTiQX+Ui9UPI3sM7EXf6GiGzh5ACmAa+L4X35C+LFN5SbUoGuZDlJR+49wt0p5CP1XT4j/CDdgVAqh/+oza4PO70wNqIfs+si+Ju5CbWgAvzfUvACNw6ANhB9oUw0IY9NESG4Trl2rhoT+u06I/wiXY1UjQv81ZdaGJkgDrkN2U2Q3zqYNzeD36wHNAS3CoA2EH/VRzQhj01JIbhOuZKnrCf3XSoj/CBdnVHNC/7Vm1oaWSANaIbs1sltk04Y28HtbwA2AdmHQBsIPQag2hLFpzxyb9igGbZF9A7LbZYtNB/i9I+BGQKc4vhcq6ndGJTOsO1F+UUZnJu2h9mUXOp4+Ez8rtEvpnOrMsF7Slbn/dEH9pCuyY5D9Y/SF/acb/L+bADcDbrlE/7FCu869YG4lw0sG023+ckXd5m4MueQV8nJFwvgoL3OsrdCuc1oexxDr3jZvt/5SmcMMfbsPU47HEPPsTjhfI4y1ovQf/sxbd5TjHH0oP0Mf6mfzPrSOqQ/1F9KHehD2IcJYq/7EfShvVNYYq38/Hp01N6sZdd7W161xURdc1OPyrYTPhT3pYpdumteeQj76Htk9LzGv7QX/LxWQBkj3z2vj/P82OuqfF3V/PhkdnmcxK7RL9SJ8JolHPL3+/M3w//T5f/b2/+wTl5Xz+uoLv98G6AfoDxgAGAgYBBgMGAIYChgGGA4YAbgdcAfgTsBIwCjAXYC7AaMBYwBjAeMA9wDuBdwHuB8wHjABMBEwCfAAYDLgQcAUwFTANMBDgOmZiZM5AGryiVEXXtSCSBgYlUHY2R8mTBjt13CdRqPkjfnOiGMkPCOOvt5HCJOBq92PoNGPqN5zyRYdFR71p1RVTp4ZTJ1iJspb8intI4TKiFU9k3QcKuNOFMoA4MR+1N+BZuk2cQRgJoMyzSTuNVztjmZsd6gcH2P2oRXapXRiPsbwfD+bWMkyBUDXO85fL7UvZjH5Yg6TL+Yw+iKDyReDbL4/wNUfBv+77U7PgR9b7g8J03qXFdqlCPNSEcZaDSH+Aiu97mKacUcF6M+c8gnXyTFmUfkETyrnXmqWbIV2qceYBoG5wS/+q5z+juY8l0EURjCJQmyAMQtk8hZqmx+Ps6fAjGDalHocTU6CjU9OPqeMzzxUl3I6oW943crn9TmT3CmONJXsTE72uXzuZI/L60typXrdGcqV6nSkZLgtn/JkZLiTnOnuZF+KNz3Zh0VbeZ1OlzclLV0lOZJT0yyP15lq+Vxup8NK9TrdXq/Tk5yc6nR6kz0+T4rH4Uj1OT1WktudYiU7nCkOrvjM88cnnE/XlMsweBCb73+6XiBFwLn4zWcQ6yeYBq4nGJ9etC8WMPhiIZMvFjL6ohfTzP4Omz/JcfWHO23+JMeV+yOFPMkR5qUijLUaGXmSy36p+UxPcoskPsktYn6SW8QgCqP/g09yT8bZU2BGMz0pPCnsSW4x4ZPcSMInOa74LEZPchcbFOy8BMfJk2uAWSJxgFnCPMAsYRhgxoZpgKHc57XRXtEFA0yovMYJObu8lHCAJsw/NY5pAFiaiwE6VJ8ui6MbCC9YHrXRAD2WKT7L/h8ttS73L7U+ZTrIZIV2qYsd6KE8oRZqXYSHohRH4DN9SC2qXD4Mta4VNo+H7jArGCZGTzNNEp9mXIp+iskXK5l8sZJ5WZ7DF/fZfFmeqz/cb/Nlea7cHy9kWZ4wLxVhrNX4yLJ89uvcmEXlEzzZXcW5arKCaRBYxbhqojmvYhCFB4Qsy68gnAiujrOnwDzA9FS5OgzL8pTxWUO4LD+e8KmfKz5r/oWnfq6PLz3jf+pfK0XAufg9wyDW65gGrnWMTy/aF2sZfLGeyRfrmT8qwzGzf9DmT3Jc/WGKzZ/kuHJ/qpAnOcK8VISxVlMjT3LZL/UM05PcBolPchuYn+Q2MIjCw//BJ7mNcfYUmIeZnhQ2CnuS20T4JDeV8EmOKz6b/oUDVsvjePq9lAFms8QBZjPzALOZYYB5RMgBK0oBu59pBhvyvriQA1bPEg7QhPmnZjINAM+G4YDVFsIDVuOL2nOAfoQpPlsM8aF+6u1FqD+9CevaSjiW6QlOuN7/t5Vp4rAtjpHwtjj6ercTJgNXu7fHZTmYqN6wvv+vt5DZdC+mTrHjUrPpUJNuO+FsAKt6Jun/D8dmn/N3oJ2mY7MUAdjBoEw7mDfkqNodzdjuUDnusvmmpk7MXQyPlc8zPWI/z7iRt5PJFy8w+eIF5uOpHL54zOabmlz9YbbNNzW5cn+OkE1NwrxUhLFWcyKbmtmvc2MWlU/wpPJFzjXnXUyDwIuMa86a84sMojBfyKbmLsKJ4O44ewrMfKY1ud1h2NSkjM8ewk3NOYRrplzx2fMvHE+lXIbBg9he/9P1S1IEnIvfXgax3sc0cO1jfHrRvniJwRcvM/niZUZf9Gaa2T9h8yc5rv6w0OZPcly5v0jIkxxhXirCWKtFkSe57Jfay/Qkt1/ik9x+5ie5/QyisPQ/+CT3Spw9BWYp05PCK8Ke5A4QPsktInyS44rPgX/heOpzcTz9XsoAc1DiAHOQeYA5yDDALBdyPJVSwGYzzWBD5fWUkOOprxIO0IT5p55iGgBeDcPx1NcIj6fOKWrPAXo5U3xe+3+01HrIv9T6uukgkxXapS52oIfyhFqodREeimJ531ymD6lFlcuHodb1hs3joTvMGwwTo8NMk8TDjEvRrzP54giTL44wL8tz+GKlzZflufrDKpsvy3Pl/mohy/KEeakIY61WR5bls1/nxiwqn+DJ7lHOVZM3mAaBo4yrJprzUQZRWCdkWf4Nwongm3H2FJh1TE+Vb4ZhWZ4yPm8RLsuvJnzq54rPW//CUz/Xx5eO+Z/635Yi4Fz8jjGI9TtMA9c7jE8v2hdvM/jiXSZfvMv8URmOmf0Gmz/JcfWHjTZ/kuPK/U1CnuQI81IRxlptijzJZb/UMaYnufckPsm9x/wk9x6DKGz9Dz7JvR9nT4HZyvSk8L6wJ7kPCJ/kNhE+yXHF54N/4YDVoTiefi9lgPlQ4gDzIfMA8yHDALNdyAErSgFbxTSDDXlfXMgBq48IB2jC/FM7mAaAj8JwwOpjwgNWq4vac4DezhSfj9EAHa731/VhGvg+iWMk/Ekcfb2fEgozV7s/jctyMFG9YX1ZYm+mZPssjpHwZwzJdtzmyabbfZwh2UxcKU70vRFH//o0ypnaCZvvCX3qjzd1bD6Ps3fu6G+DXsGQO5Rv+f7C5j7Uuf15HP36PGGfUZ8TxuNLm8dD58uXDH35JPMJ5VD56f3Lkwzt3lXU3tqdwdTu55me4qm1ljA+6nnivbdwTawzmCbWX8UxEv6KYWL9tc0n1rrdXwt/ivMxJds3cYyEv2FItm9tnmy63d+G6SnOCu0613G/ZRjFvrP5k5d+6vqOod2niDtp6aistWL9uxays37bh+w+yL4v5ryded/38P9+APwI+Ckuqzzzon6CIFxuUt8T9vWfmWPzM4rBD8j+Edk/xV0Ym1/g918BpwFn4i6sjzIv9UrDKYZ8/40w1pkz1KiL+MAK7VJewvjX9NfzO9T5B+BPwF86toC/tfbHA39ANCAGEAuIA8QDEgB5AHkB+QD5AQUABQGFAIUBRQBFAcUAxQElACUBpQClAWUAZQHlAOUBFQAVAZUAlQGJgCrx52f9eK/jd38O4LI/DGV/Gsr+MpSdNZT9bSg7549sZZcZyqINZTGGslhDWZyhLN5QlmAoy2Moy2soy2coy28oK2AoK2goK2QoK2woK2IoK2ooK2YoK24oK2EoK2koK2UoK20oK2MoK2soK2coK28oq2Aoq2goq2Qoq2woSzSUVYnP0pjMK9CDU4FoTqha+ztBXRm+89cfhLx22/wMiL/N3j/p/JfyF11d6ixhLPaIiEWG+pvMf+lKjy00dXnUZfF0sdgrIhYw76LyX4alYqjqSrdULGEsXpIQC4+l4qj8B2NPPFFdGVBXAmEs9gmIRTq0OQ+R/zxQV16iuqDJKh9hLF62fywydJvz0/gvXddVgKYuj66rIGEs9ts/FrpqVYjEfxnn6ipMUlf6ubqKEMbiFdvHwnOuzUVJ/HeOpipGUVfG+bqKE8bigN1jkX6+zSUo/Oc5X1dJirrON1mVIozFQZvHwutvc2mCNqf56ypDUJfbX1dZwli8au9YODI/oVou9DarzLrKh1yXx5dZVwXCWLxm61h40jLbXDF0//3vk8eVQq7L/b+6KhPG4pCtY5H0vzYnhtxm9b+6qsTTrVnuJvxM0us2+QByDpciXDdThOs+6iXCWLwhJBaE6wOK8PlW7SeMxWEhsSB8DlKE83h1kDAWR4TEgnC+pwjnK+oQYSyOCokF4bimCHVZHSaMxZtC3ihE2H8VYf4pLv9FZ/OfHfaVM+uqSjgP1XVQnwHS561+YzgHVS2eNtbU7e4bl3X2h7LdJ23+KQ2dj9Xi6dv9lZB3LVxO2B8JY62+snne6P5SlSFvvrV5u7VGcPSX74T0lysI+wthrBWl/86d4Yu68Kyx1onMM8pXIHt/dJa9Ldu58urw72oAagJqxV/87LIV2qVui8s6o0oZ6x9s/oZU3ebqDH3xRyHPWNUJ14SvJOzXhHmjpMTiNsJnhKviefqwnfqFSWOvRLp6VS41tjb8uzqAqwF1GTW2X1zWmX9cb6g+/cXmGqvbXJtBY38V0q9rE/ZFi1BjCfNGSYlFP0KNVfE8fdhO/cKksRbSVZVLjXXAv3MCXIAkRo3tH5f1GSpcb8ifwbO5xuo2Oxg09nch/dpB2BeTCTWWMG+UlFj0J9RYdzxPH7ZTvzBpbDLSVXcuNdYD/y4FcA3gWkaNHRCX9ZlUXG/IGmZzjdVt9jBo7Fkh/dpD2BfrEWosYd4oKbEYQKix9eN5+rCd+oVJY+shXa2fS41tAP+uofYXoDGjxg6My/qMP643VJ9eVszeGqvb3IBBY6OLyejXDQj7YhNCjSXMGyUlFgMJNfa6eJ4+bKd+YdLYJkhXr8ulxjaFf9cMcD2gOaPGDsp8h0y2ekP1aZzNNVa3uSlDu+OF9OumhH2xBaHGEuaNkhKLQYQa2zKepw/bqV+YNLYF0tWWudTYVvDvWgPaANoyauxgPYdl0Jq8NtdY3eZWDO3OJ6RftyLsizcQaixh3igpsRhMqLHt4nn6sJ36hUljb0C62i6XGtse/l0HQEfAjYwaOyQu651+uN5QfVrQ5hqr29yeod2FhPTr9oR9sROhxhLmjZISiyGEGts5nqcP26lfmDS2E9LVzrnU2C7w77oCugFuYtTYoXFZ70jF9Ybq06I211jd5i4M7S4mpF93IeyLNxNqLGHeKCmxGEqosbfE8/RhO/ULk8bejHT1llxqbHf4dz0AtwJ6MmrssLisd07jekP1aUmba6xuc3eGdpcS0q+7E/bFXoQaS5g3SkoshhFqbGo8Tx+2U78waWwvpKupudTYNPh36QAvIINRY4fHZb3DH9cbqk/L2lxjdZvTGNpdTki/TiPsiz5CjSXMGyUlFsMJNbZ3PE8ftlO/MGmsD+lq71xqbB/4d30BtwH6MWrsiLis70TB9Ybq04o211jd5j4M7a4kpF/3IeyL/Qk1ljBvlJRYjCDU2AHxPH3YTv3CpLH9ka4OyKXGDoR/NwgwGDCEUWNvj8v6jilcb6g+rWJzjdVtHsjQ7qpSzmQS9sWhhBpLmDdKSixuJ9TYYfE8fdhO/cKksUORrg7LpcYOh383AnA74A5Gjb0jLus7+3C9Ib//x+Yaq9s8nKHd1aU8nxL2xTsJNZYwb5SUWNxBqLEj43n6sJ36hUlj70S6OjKXGjsK/t1dgLsBoxk19s64rO9AxfWG6tNaNtdY3eZRDO2+Uki/HkXYF8cQaixh3igpsbiTUGPHxvP0YTv1C5PGjkG6OjaXGjsO/t09gHsB9zFq7Mi4rO+UxvWG6tM6NtdY3eZxDO2+Wki/HkfYF+8n1FjCvFFSYjGSUGPHx/P0YTv1C5PG3o90dXwuNXYC/LuJgEmABxg1dhTENz+D1iiba6xu8wSGdjuE9OsJhH1xMqHGEuaNkhKLUYQa+2A8Tx+2U78waexkpKsP5lJjp8C/mwqYBniIUWPvgvgWYNCaJJtrrG7zFIZ2Jwvp11MI++J0Qo0lzBslJRZ3EWrsw/E8fdhO/cKksdORrj6cS42dAf/uEcBMwKOMGns3xLcgg9ak2FxjdZtnMLT7GiH9egZhX5xFqLGEeaOkxOJuQo19LJ6nD9upX5g0dhbS1cdyqbGz4d/NAcwFPM6osaMhvoUYtKa+zTVWt3k2Q7sbCOnXswn74jxCjSXMGyUlFqMJNXZ+PE8ftlO/MGnsPKSr83OpsQvg3z0BWAhYxKixYyC+hRm0prHNNVa3eQFDu5sI6dcLCPvik4QaS5g3SkosxhBq7OJ4nj5sp35h0tgnka4uzqXGLoF/txSwDLCcUWPHQnyLMGhNM5trrG7zEoZ2Xy+kXy8h7ItPEWosYd4oKbEYS6ixK+J5+rCd+oVJY59Curoilxr7NPy7lYBVgNWMGjsO4luUQWta2lxjdZufZmh3KyH9+mnCvriGUGMJ80ZJicU4Qo19Jp6nD9upX5g0dg3S1WdyqbFr4d+tA6wHbGDU2HsgvsUYtKatzTVWt3ktQ7tvENKv1xL2xY2EGkuYN0pKLO4h1NhN8Tx92E79wqSxG5Gubsqlxm6Gf/csYAtgK6PG3gvxLc6gNR1srrG6zZsZ2t1RSL/eTNgXtxFqLGHeKCmxuJdQY7fH8/RhO/ULk8ZuQ7q6PZcauwP+3XOAnYBdjBp7H8S3BIPWdLa5xuo272Bodxch/XoHYV98nlBjCfNGSYnFfYQa+0I8Tx+2U78waezzSFdfyKXGvgj/bjdgD2Avo8beD/EtyaA1N9lcY3WbX2Ro981C+vWLhH3xJUKNJcwbJSUW9xNq7L54nj5sp35h0tiXkK7uy6XGvgz/bj/gFcABRo0dD/EtxaA1PWyusbrNLzO0+1Yh/fplwr54kFBjCfNGSYnFeEKNfTWepw/bqV+YNPYg0tVXc6mxr8G/OwR4HfAGo8ZOgPiWZtCaVJtrrG7zawztThPSr18j7IuHCTWWMG+UlFhMINTYI/E8fdhO/cKksYeRrh7JpcYehX/3JuAtwDFGjZ0I8S3DoDUZNtdY3eajDO32CenXRwn74tuEGkuYN0pKLCYSauw78Tx92E79wqSxbyNdfSeXGvsu/Lv3AO8DPmDU2EkQ37IMWtPX5hqr2/wuQ7tvE9Kv3yXsix8Saixh3igpsZhEqLEfxfP0YTv1C5PGfoh09aNcauzH8O8+AXwK+IxRYx+A+JZj0JoBNtdY3eaPGdo9UEi//piwLx4n1FjCvFFSYvEAocaeiOfpw3bqFyaNPY509UQuNfZz+HdfAL4EnGTU2MkQ3/IMWjPE5hqr2/w5Q7uHCunXnxP2xa8INZYwb5SUWEwm1Niv43n6sJ36hUljv0K6+nUuNfYb+HffAr4DnGLU2AchvhUYtGaEzTVWt/kbhnbfLqRff0PYF78n1FjCvFFSYvEgocb+EM/Th+3UL0wa+z3S1R9yqbE/wr/7CfAz4BdGjZ0C8a3IoDUjba6xus0/MrR7lJB+/SNhX/yVUGMJ80ZJicUUQo09Hc/Th+3UL0wa+yvS1dO51Ngz8O9+A/wO+INRY6dCfCsxaM1om2usbvMZhnaPEdKvzxD2xT8JNZYwb5SUWEwl1Ni/4nn6sJ36hUlj/0S6+lcuNfYs/Lu/AVEJ8P8T+DR2GsS3MoPW3GNzjdVtPsvQ7nuF9OuzhH0xOoGOF2HeKCmxmEaosTEJPH3YTv3CpLE6BzO1NCYhdxobC/8uDhAPSGDU2IcgvokMWjPe5hqr26x9TF3vBCH9OpawL+Yh1FjCvFFSYvEQocbmTeDpw3bqFyaNzYN0NW8uNTYf/Lv8gAKAgowaOx3iW4VBYx+wucbqNudj0NjJQvp1PsK+WIhQYwnzRkmJxXRCjS2cwNOH7dQvTBpbCOlq4VxqbBH4d0UBxQDFkcZmXtHEcS4aRefPIgn21lcf5PTJOIZ3eRG2G+hF5Udtxxf1OEvJG/MtmcBIuGQCfb2lCAWKq92lErIcTFTvuWTTiI7iT7aaUTwDHzXPk9F0PAsgnqX98Svj/1nW/7Oc/2d5/88K/p8V/T8r+X9W9v9M9P+s4v9ZFfUH+re7EM6izq3m+DmW9ZPGZRUMZZUNZZkNDqdSlmZSymoJjISrMSjl5TZXSt3uy5mUMlzJVoYp2a5IYCR8BUOyVbd5sul2V2dINhPXkD976+8Y1M8PlIJQQ+g8uhxTh62ZwEi4JkOHrWXzDqvbXUv46FCeKdmuTGAkfCVDsl1l82TT7b5KyOhQwd8xqEcHSkGozby6ZIV2nZut1GBYva9j83brHK/N0O6rhc4GKjIJdN0ERsJ1GQTasrlA63ZbwmcDlZiSTSUwElYMyeawebLpdjuEzAYq+zsG9WyAUhCcNh8V9ah9NcOo6LJ5u3WOOxnanSR0NpDIJNDJCYyEkxkE2m1zgdbtdgufDVRhSjZPAiNhD0Oypdg82XS7U4TMBqr6Owb1bIBSEK6x+aioR+0khlHxWpu3W+f4NQztrkfc7swrmpgn5cGS+oR78Ryx1rlYjyHWDYgHteyn9I7GZp3GK41O6ZVB9puxF57Sa6g5ARoDmhhO6cUQ+7YsYewbEubkdUz9kNp/hDt0qhGh/5oK8R/hppNqTOi/ZszacB3SgKbIbobsJgkXasP18HtzQAtAyzBoQwXC2FxPGJtWQnKbcL1eNSf0X2sh/iNcglYtCP3XhlkbWiENaI3sNshumU0b2sLvNwDaAdqHQRsqE8amLWFsOgjJbcLVO3UDof86CvEf4YKUakfovxuZtaED0oCOyL4R2e2zaUMn+L0zoAugaxi0oSphbDoRxqYbc2y6oRh0RnYXZHfNFpub4PebAbcAuidc/JOvFM/4DRjW2uoTxqeHzdecdKx6MKxD3GrzdnN9uq2nzdutc/tWhnhPtfmnxXW7ezK0exrTJ5SpNY0wPoqyzXrDLz4qPBt+lB+quwxxLOi3e0F+pQLSAOkALyAD4AP0BvQB9AXcBugH6J9wiQ+jWaFdivDDaOeCVCAqPJ98TGOarEfR8nRgXwzwb04OTIi68NN3+n/8la1sYMI/s516tppGMIPJ8J2/BhDOhgYmyFBLyjYPQnUpj9PhcDv1v/N4YaPTm+7wOBzeNJeVbqWmOzJSXCrF53K4nOne9DSoM1X5LF9qeorPc55XOI9HDEqgV0t9DU5gJDw4gb7eIYTJwNXuIQlZDiaql2UaNtDPlbreocTJminWQ/2Pl+EcATMEjoDD/Pk3PPsIOMwwAg4PwwiYQTgCDiMUgOFCRkDKNo8QOgKOYBoBb09gJHw7wwh4h81HQN3uO4SMgMP9XKnrvZNpBLzzXxgB+wgcAUf6829U9hFwpGEEHBWGEbAP4Qg4klAARgkZASnbfJfQEfAuphHw7gRGwnczjICjbT4C6naPFjICjvJzpa53DNMIOOZfGAH7CRwBx/rzb1z2EXCsYQQcF4YRsB/hCDiWUADGCRkBKdt8j9AR8B6mEfDeBEbC9zKMgPfZfATU7b5PyAg4zs+Vut77mUbA+9EIGK6O14up441PYCQ8nqHjTbB5x9PtnsDQ8cKZbKlMyTYxgZHwRIZkm2TzZNPtniRor2tCAv20jFIQHkiQ2WHTmTrs5ARGwpMZOuyDNu+wut0PCh8dvEzJNiWBkfAUhmSbavNk0+2eKmgf6EGG0YFSEKYl8PrQCu06N1t5gOE56iGbt1vn+DSGdk8XOhvwMQn0wwmMhB9mEOgZNhdo3e4ZwmcDvZmS7ZEERsKPMCTbTJsnm273TEF7YjMYZgOUgvCozUdFPWpPZxgVZ9m83TrHH2Vo92NCZwN9mQR6dgIj4dkMAj3H5gKt2z1H+GzgNqZkm5vASHguQ7I9bvNk0+1+XND+4ByG2QClIMyz+aioR+3HGEbF+TZvt87xeQztXmDzduu4LGBo9xPEAn+pFyrqrdRMOzXh4i9UXAj/bxHgScDiBP6XnxB+bFMtJNSgJcQ5yeU/wt0qtYjQf0uF+I9wA0Y9Sei/ZczasARpwFJkL0P24oQLtWE5/P4UYAXg6TBoA+EH2tRywtisFJLbhGvX6ilC/60S4j/C5Vi1gtB/q5m1YSXSgFXIXo3sp7Npwxr4/RnAWsC6MGgD4Ud91BrC2KwXktuEK1nqGUL/bRDiP8LFGbWW0H8bmbVhPdKADcjeiOx12bRhE/y+GfAsYEsYtIHwQxBqE2FstjLHZiuKwWZkP4vsLdlisw1+3w7YAXguge+FivqdUU8wrDtRfrHDTpuvQ+hY7WRYh9jFnJdd4rLybxfKxf7I/jH6wrx8Hv7fC4AXAbsvkZdWaNe5F7eVYvDpwzZ/aaFu8/MM7Z4h5KWFhPFRM4rZWzd0rEcxxPpRm7dbv3S9PseufbHwzFFD5bmHcB5EGGtF6T/8WbI9KNbUubQSBqDTsfS5NMfmfWgVtPkwQ7vnCulDewn7EGGs1Vyb543uL2cY8ma+zdu9mqm/LBDSX14i7C+EsVYLiMec7M84e9GzzEvI7h538WecffDvXgbsB7zif8bRB4zQUZILDhodSPD/g5io8JxAOhFN57RoxPOgv4WvJmRrAPVKEG5AqJl9MPcrDek51KVeJX7izoN8p38/Hp2VdftQNh7w28mA18A+lBDeT96/RtzuzOv1BEbCryfQ1/sG4bIVV7vfQL2TqN6wnp88xJRshxMYCR9mSLYjNk823e4jDMlm4hpq+9/wc6Wu9yjhvElz028Ti4ky+NSlHA6ncrmBmgUcvekeR4YnNSkpNSXJ4XV5fQ7LkZTsy7CAmzfFlQLFLpWealk+KzXNp5LOZq8v1ZMOrU62vBb8x5fk9UCzXSlel8fntFwur5WsXFZaiifD61bu1JS0JKcj1ZfstNJVktNyp6izxDHXbc+camj7IBr9XvXbb8LPtwDHEsL75rVjTHubUbQ8L3jz2tv+fvlOgt8hmXNP/T+yv3ntnYR/Kjv1lO4YgZhlvnntbUJhfIcpuNQL35RtfhfVJenNa+8yzQzeS2Ak/B7DzOB9m88MdLvfFzIzeMfPlbreD4iTNVOsP0i4cKSkjJt+fDjK4IsPbb5Df4ip3R/ZvN1cs+KPiXO/oL/tH6JZ4UfI/tjfhnOfjEDlbyE7c5LzCfz8FPCZfxap12Diov552XlRzkA35LrdyuWA5wt3ptZw/A3/pbh8vI9hMkfN8QDThJOa5ydCeH4WzTMpPJ59kZua+HEhTx6fES7GnyBeLsmcFOl6E6PCuyjOlXifJzAS/pzhaeQLmz+N6HZ/EaanESu069yZLx/DjGyRzfffKzKd+XpSyP77l4TCSBhr9aSAM5K9GfJmqc3bXYmpvywT0l9OEvYXwlirZcznVb5ET7Qnkb3nEmfyv4L/9zXgG8C3/vMqprr3o9MHF7Oz1/0d1HcK8D3ghwT+zwh9RTjX+I6wrh8JJ/PhnMRS8sZ8f0pgJPwTwyT2Z5tPYnW7f2Y62ZE3KjwbqV8J2UjFIvaL3+e/+n+e9v88g/dMqUfhn5kek0+jddLs6v8LGkF+RfbpS4wsv8H/+x3wB+DPBL5Pe33lT35qP6+w+ae9dJt/Y2j300yzvFhinoSCoX4jrIswb9TTNn/S0AMDR9/7i2l/9C//UiBHf8z0BfUSazQhx7NMfj2L/Jp5Uc/uCXNCnSWc0P3N5NO/L5GrVmiXio/i6bd6w5TDF7rei/kiVM6ZvqDut/GEHC9j8utlefj7LWFOKOyHkPWayafRefj6bYEonn4bw+SLGMZ+W4Cp3xYg5BjL5NfYMPRbwpxQsYT9No7Jp3GM/bZQFE+/jWfyRTxjvy3E1G8LEXJMYPJrQhj6LWFOqATCfpuHyad5GPttkSiefpuXyRd5GfttEaZ+W4SQYz4mv+YLQ78lzAmVj7Df5mfyaX7GflvMn6vkc04mXxRg7LfFmPptMUKOBZn8WjAM/ZYwJ1RBwn5biMmnhRj7bekonn5bmMkXuF5qzqWZ+m1pQo5FmPyK641i6reEOaGKEPbbokw+LXqJXLVCu1TlKJ5+W4zJF8UYx9vKTP22MiHH4kx+LR6G8ZYwJ1Rxwn5bgsmnJRjH28Qonn5bkskXJRn7baYvqPttIiHHUkx+LRWGfkuYE6oUYb8tzeTT0oz9tkoUT78tw+SLMoz9NtMX1P22CiHHskx+LRuGfkuYE6osYb8tx+TTcoz9tmoUT78tz+SL8oz9tipTv61KyLECk18rhKHfEuaEqkDYbysy+bQiY7+tHsXTbysx+aISY7+tztRvqxNyrMzk18ph6LeEOaEqE/bbRCafJjL22xNMnw2owuSLKoz9NtMX1P32BOFZ2qpMfq0ahn5LmBOqKmG/rcbk02qM/fa7aJ5+ezmTLy5n7LeZvqDut7peKo5XMPn1ijD0W8KcUFcQ9tvqTD6t7vfppb6VoEbmi8/C9a0ENQgbG4141sxz/metPFG8WVSDMPI1c19Xjt9KUIs4iy76DurQrpzeGe1I9ylnUoY7yUpOdSV5k50Or8NteV1JPgWOcKS4wA2+dJfH63E4fQ63I537HdQ6RpmffK3lt6+En1cBaucJ7zuoaxPG2ECXqu4L3kFdx98hr87jd0im0uj/8Vc2AtSdtTZBZ81833Qdwo5/NVMgqacOlG2ui+qS9L7pusTCmnlZeRgJ68qp61WEycDVboWGf6J6WT7Tf7WfK3W9Dqa5pK4Xj4qUcdPfNvc7w7eurbb5Z+qfYfq2uTVC3t7lJHweI4y1WiPg2xn/YMibdTZv91qm/rJeSH9xEfYXwlir9cRvu8NPnvp3J3oCcyG7R5z/c9jo35qe1pLgZzLAHeanNbfApzWPf/6Ukv1pzROGpzU34dOah3CymiLkaY2yzdcIfVq7hulp7do8jISvZXhaq2fzpzXd7npCntZS/Fyp663P9LRWP88/Rzjq+FGKIjfXJEKuif56GkCdDXW9gMaAJoDrAE0BzQDXA5oDWgBaAloBWgPaANoCbgC0A7QHdAB0BNwI6AToDOgC6AroBrgJcDPgFkB3QA//6IxjrvlkH7QbGsoaGcoaG8qaGMquM5Q1NZQ1M5RdbyhrbihrYShraShrZShrbShrYyhrayi7wVDWzlDW3lDWwVDW0VB2o6Gsk6Gss6Gsi6Gsq6Gsm6HsJkPZzYayWwxl3Q1lPfxl+Mr+1kcrtOuCPhuqzjYgm1haqiEhr002fwOnbrOORSMS/52Pa+PQ63Jk7nk2IYzFZjvHwpW1z3tdaG228J5x01Dqcly4/9yMMBbP2jMWVvY99+uDbHOy75/7982Dq8tjOgvQgjAWW+wWC4/5/EPLwNvsvthZilaB1uW++LmM1oSx2GqfWDgudRalTSBtdl/6XEvb3NeV4xmZGwhjsc0OsXDnyFO1y12brVy0WbXPTV1WrvynOhDGYvu/G4ukXPJUHXNqsyvXbVY3XrIuly8A/6lOhLHY8W/Fwh0QT9X54m32BNhm1eUidaX4Avaf6koYi+fCHwsrCJ6qm6nNVlBtVjf9sy4VpP/UzYSx2BnOWHiD5qluubDNzhDarLqjuhy+kPynehDGYleYYmGFdinC9QFF+Hyr8PNZqLF4XkgsCJ+DFOE8Xm0jjMULQmJBON9ThPMV9RxhLF4UEgvCcU0R6rJ6njAWu8N0QsgK7VKE/VcR5p+i9J/O34lRWZ8W6+HfE7vFv0d2k3/PrKt/D62zf0/tRv8eWwf/nls7/x6cXl/Q6xV6nUav++h1JL1+ptfj9PqeXtfU66R63VWvN59bv85zfm+tQfZNkKh/HuoINfeSCec9t+YhO9QR1u+nxLytEC/Mt2ceRsK6cup6exEmA1e7e6FOQVTvuWSLjgrPsb3kPDxin90noXZAnMipKNfIT6n0onPIBd9DiUkHyDk9pyNnmrOuP9Ajdjk5PZWwA6YRq1qmX3W944LMBQW+S1eWz0pxwEqOOz3ZnZbidaR5Un1OX5LT6wzWrzklO6Vf05n8mh68X/9f5KuXya/e/3i+ZjD5NcPv13B+vJ9y8MSDvc8/qeitxwyOAS6VYbaWSjyT4Gp3oJ3DCqDdoXLsw+xDK7RL6cTsk4c+Nn2ZRKHvJcTWCu1SvZl8cRuTL25j9EUyky+O2PzLyrn6w9F/t905Hi3hyv03hSw9EualIoy1ovSfnkjp5UfTKkRUgP7MKZ9wnRxjFpVP8KSy36VWIazQLtWHaRDod4lViByqUTn9Hc25H4MovGOTvaFAJm+htrl/HnsKDGUscF72R5OTYOOTk88p4zMA7y04ndA3vG7l8/qcSe4UR5pKdiYn+1w+d7LH5fUluVK97gzlSnU6UjLclk95MjLcSc50d7IvxZue7MOirbxOp8ubkpaukhzJqWmWx+tMtXwutxMe+L1Ot9fr9CQnpzqd3mSPz5MCD+nw6O+xktzuFCvZ4UxxcMVnAHq6phoUclrNwXVKGRQGShwUBjIPCgMZBoX3bDIoXDSJ3ec/mU8pOoNsOii8xyQ6gwgGhZyWNinjM9imgwJXfAb/P1pyHeJfch1qWnK1Qrsuut9BuVcZal2Ey7eKI/CZPqR+zxCXD0Ota5jN46E7zDCGgX040yRnOOPy51AmX4xg8sUI5qVgDl98YPOlYK7+8KHNl4K5cv8jIUvBhHmpCGOtPoosBWe/zo1ZVD7Bk93bOZ/6hzENArczPvVrzrcziMJnQpaChxFOBO/IY0+B+YzpqfKOMCwFU8bnTsKn/o8In/q54nOnIT6BnqnJaemXMj4jmfRzJIEfclqdovTDKCY/jBKWD3cx+eEuYflwN5Mf7s7FVpGdJ3YGumR5jCeNoyVOGkczTxpHM0waT9jjPULp4RS5MYR1UU4aTzBNSsbkYtIY6ul6yviMzUM30aOcNHLFZyzB4JjDRfrOjHFk+ulhOYjdy7/qRr2jRJnj99h8B0PH+B6G8eZeprFX15vH//vEqH9eVH8zsz5qf++Ptj/H+ygnkpFA8XG8PxIoSx0XEKjxXI9m1LI9gY6oQ2pCTchjf44TpSTUJDqiTqkJNUlAQj0gJaEm0xF1SU2oyQIS6kEpCTWFjmiS1ISaIiChpkpJqGl0RJOlJtQ0AQn1kJSEmk5H1C01oaYLSKiHpSTUDDqiHqkJNUNAQj0iJaFm0hFNkZpQMwUk1KNSEmoWHdFUqQk1S0BCPSYloWbTEU2TmlCzBSTUHCkJNZeOaLrUhJorIKEel5JQ8+iIeqUm1DwBCTVfSkItoCOaITWhFghIqCciu/iW6hJnf44LpfT8RWRElSU1oRYJ6PlPSkmoxXQJpaQm1GIBCbVESkItpUsoseeMlgpIqGVSEmo5XUKJPWe0XEBCPSUloVbQJZTYc0YrBCTU01ISaiVdQok9Z7RSQEKtkpJQq+kSSuw5o9UCEmpNZH3HUqei7c/xGSk9fy1dzxd7fmetgJ6/TkpCradLKLHnd9YLSKgNUhJqI11CiT2/s1FAQm2SklCb6RJK7PmdzQIS6lkpCbWFLqHEnt/ZIiChtkpJqG10CSX2/M42AQm1XUpC7aBLKLHnd3YISKjnpCTUTrqE8klNqJ0CEmoXJUf9ArhJgER/hfqdMfp1JPoNEvpD//pz2vqjtfrTkPoDbPozR/pjIvpkvz6Mrc/P6iOP+pSaPgClz6zoYwZ6Z1hv5un9F71krlc59QKaXvPQj6n6yUJPBvX4rSVX9xLdMC6ncb3I6gubf+WCbvN9DO3+0iZvGc/huuBlVaG2+Xm6jqcI80ZRxiLGrwfZLyqumfX9F9/HRZg/FgtBLpF8gbDh+G1/ut48FwkWxXdemd4eaYV2Kcq3R76Yh3fwsUK7zr1t9EWGfNrNlE+7UT5lXtTfhUPYF9Ruwlzaw+TTPXmy3sjJOLD8p98fuNfuA4seVPYyCMFLTEn70iUGFiu0S3VnEsV9TL7YFwZRJIyj2kcoii8z+fRl4aIo4R2Y+yWI4n4GIXiFKWlfYRTFW5hE8QCTLw6EQRQJ46gOEIriQSafHhQuihLe4/qqBFF8lUEIXmNK2tcYRfFmJlE8xOSLQ2EQRcI4qkOEovg6k09fFy6KEt5F/IYEUXyDQQgOMyXtYUZRvIlJFI8w+eJIGESRMI7qCKEoHmXy6VHhoijhfdpvShDFNxmE4C2mpH2LURS7MYniMSZfHAuDKBLGUR0jFMW3mXz6tnBRlPBO+HckiOI7DELwLlPSvssoil2ZRPE9Jl+8FwZRJIyjeo9QFN9n8un7wkVRwvcafCBBFD9gEIIPmZL2Q0ZR7MIkih8x+eKjMIgiYRzVR4Si+DGTTz8WLooSvpvjEwmi+AmDEHzKlLSfMopiZyZR/IzJF5+FQRQJ46g+IxTF40w+PS5cFCV8v8wJCaJ4gkEIPmdK2s8ZRbETkyh+weSLL8IgioRxVF8QiuKXTD79UrgoSviOpJMSRPEkgxB8xZS0XzGK4o1Movg1ky++DoMoEsZRfU0oit8w+fQb4aIo4Xu+vpUgit8yCMF3TEn7HaModmQSxVNMvjgVBlEkjKM6RSiK3zP59Hvhoijhu+p+kCCKPzAIwY9MSfsjoyh2YBLFn5h88VMYRJEwjuonQlH8mcmnPwsXRQnft/iLBFH8hUEIfmVK2l8ZRbE9kyieZvLF6TCIImEc1WlCUTzD5NMzwkVRwneG/iZBFH9jEILfmZL2d0ZRbMckin8w+eKPMIgiYRzVH4Si+CeTT/8ULooSvp/3Lwmi+BeDEJxlStqzjKJ4A5Mo/s3ki7/DIIqEcVR/E4piVF4en+p6JYuihO+YviyvAFHUJKmFIJopaaPz8oliWyZRjGHyRUxeflEkjKPCfgjVp7FMPo0VLooSvic9ToIoxjGIYjxT0sYzimIbJlFMYPJFQhhEkTCOKoFQFPMw+TSPcFFcKkAU80oQxbwMopiPKWnzMYpiayZRzM/ki/xhEEXCOKr8hKJYgMmnBYSL4nIBolhQgigWZBDFQkxJW4hRFFsxiWJhJl8UDoMoEsZRFSYUxSJMPi0iXBRXCBDFohJEsSiDKBZjStpijKLYkkkUizP5ongYRJEwjqo4oSiWYPJpCeGiuFKAKJaUIIolGUSxFFPSlmIUxRZMoliayRelwyCKhHFUpQlFsQyTT8sIF8XVAkSxrARRLMsgiuWYkrYcoyg2ZxLF8ky+KB8GUSSMoypPKIoVmHxaQbgonoq2P8eKEkSxIoMoVmJK2kqMong9kyhWZvJF5TCIImEcVWVCUUxk8mmicFFcK2CmWEWCKFZhEMWqTElblVEUmzGJYjUmX1QLgygSxlFVIxTFy5l8erlwUVwvQBSvkCCKVzCIYnWmpK3OKIpNmUSxBpMvaoRBFAnjqGoQimJNJp/WFC6KGwWIYi0JoliLQRSvZEraKxlF8TomUbyKyRdXhUEUCeOoriIUxdpMPq0tXBQ3CxDFOhJEsQ6DKF7NlLRXM4piEyZRrMvki7phEEXCOKq6hKJoMfnUEi6KWwSIopIgiopBFB1MSetgFMXGTKLoZPKFMwyiSBhH5SQURReTT13CRXGbAFFMkiCKSQyimMyUtMmMotiISRTdTL5wh0EUCeOo3ISi6GHyqUe4KO4QIIopEkQxhUEUr2FK2msYRbEhkyhey+SLa8MgioRxVNcSimI9Jp/WEy6KOwWIYn0JolifQRQbMCVtA0ZRbMAkig2ZfNEwDKJIGEfVkFAUGzH5tJHBp9T50JiMu9OtucUCqiCue/Kcb4O2X0b2QWS/juyjyH4b2e8j+2NkH0f2l8j+BtnfI/tnZJ9B9p/IznyP5bn2IDsPsgsguwiySyC7DLIrIDsR2ZcjuyayayPbQrYL2R5k10N2I2Q39ttN4Od1gKaAZoDrAc0BLQAtAa0ArQFtAG0BNwDaAdoDOgA6Am4EdAJ0BnQBdAV0A9wEuBlwC6A7oAfgVkBPQC9AKiA66tJ5bIV2qcvo6rIS/fWkAe90gBeQAfABegP6APoCbgP0A/QHDAAMBAwCDAYMAQwFDAMMB4wA3A64A3AnYCRgFOAuwN2A0YAxgLGAcYB78p53EtaDNBTXzLJ0Q5nXUJZhKPMZynobyvoYyvoaym4zlPUzlPU3lA0wlA00lA0ylA02lA0xlA01lA0zlA03lI0wlN1uKLvDUHanoWykoWyUoewuQ9ndhrLRhrIxhrKxhrJxhrJ7DGNPrP9nI/9PK7Trgj4b6jiWRjCeZ/j0Zal0wrnB18XoHwxMsQilzToWXhL/nY9rRuh1Ofz+Uz7CWHxj51i4/sdT9Q6tzRZqs+oTSl2OC/yn+hLG4lt7xsLKxlPdFmSbk33/aLPqF1xdHoP/VH/CWHxnt1h4jDzVgMDb7L5Im9XAQOtyX9R/ahBhLE7ZJxaOS/BUgwNps/uSbVZDcl9Xeg7+U0MJY/G9HWLhzpGnGpa7Nlu5aLManpu6rFz5T40gjMUP/24sknLJU92eU5tduW6zuuOSdbl8AfhP3UkYix//rVi4A+KpRl68zZ4A26xGXaSuFF/A/lN3Ecbip/DHwgqCp7rb1GYrqDar0f+sSwXpPzWGMBY/hzMW3qB5qrEXttkZQpvVOFSXwxeS/9Q9hLH4JUyxsEK7FOH6gCJ8vlX4+Szkb74VEgvC5yBFOI9X3xPG4rSQWBDO9xThfEX9RBiLM0JiQTiuKUJdVr8SxuI3plhQ74ET9l9FmH+K0n+Ze4OJ/p94PyL7fgXez8D7HXg/BO+X4P0UvN+C92Pwfg3ez8H7PXg/CO8X4f0kvN+E96PwfhXez8L7XXg/DO+X4f00vN+G9+Pwfh3ez8P7fXg/EO8X4v1EvN/YEdk3IrsTsjsjuwuyuyK7G7JvQvbNyL4F2d2R3QPZtyK7J7J7ITsV2U2QfR2ymyK7GbKvR3ZzZLdAdktkt0J2a2S3QXZbZN+A7HbIbo/sDn47U1Duhd/vA9wPGA+YAJgImAR4ADAZ8CBgCmAqYBrgIcB0wMOAGYBHADMBjwJmAR4DzAbMAcwFPA6YB5gPWAB4ArAQsAjwJGAxYAlgKWAZYDngKcAKwNOAlYBVgNWANYBnAGsB6/Keb1OBqCxN1L9/mRAVddZvn0T2noTzP6PRv62ZJ+v/1/Lb66HeDYCNgDh//Zn34CtTUxr5f1qhXWpjXp7xIoqWpwP7YlPe8z835426cLNX/4+/shGgHrg2Ejzcnd+g9fk2ET4obmYKZDSx/yjb/CyqS8FCPyzQ63/n8VrK5YUldofDm+ay0q3UdEdGigvWuFwOlzPdmw6Ljp5U5bN8qekpPs95XrrT5Y/K6mD4ou50z+aln2Toa0teRsJb8tLXu5UwGbjavTVvloOJ6jVypRCArXnp691GnKyZYq3r5T5NRymK3FzXE3JN9NezHercAXgOsBOwC/A84AXAi4DdgD2AvYCXAPsALwP2A14BHAAcBLwKeA1wCPA64A3AYcARwFHAm4C3AMcAbwPeAbzrH51xzLfn/ecJrR2GsucMZTsNZbsMZc8byl4wlL1oKNttKNtjKNtrKHvJULbPUPayoWy/oewVQ9kBQ9lBQ9mrhrLXDGWHDGWvG8reMJQdNpQdMZQdNZS9aSh7y1B2zFD2tqHsHUPZu3n5T/6tJxy/tpNNLC21g5BX3uIyTv49R+K/83HdGXpd/zv5t4swFvnsHAt08u/50Np8wcm/F0KpK9vJvxcJY5HfnrH4x8m/3UG22XTyb09wdRlP/u0ljEUBu8XiIif/Xgq8zRc9+bcv0LoucfLvZcJYFLRPLC558m9/IG3O4eTfK7mvK8eTfwcIY1HIDrHIxcm/g7lrc65O/r2am7pyefLvNcJYFP53Y5Hrk3+HcmpzACf/Xs9Ld/LvDcJYFPm3YhHgyb/DeelO/h3JS3fy7yhhLIqGPxZBnfx7My/dyb+38tKd/DtGGIti4YxFCCf/3s5Ld/Lvnbx0J//eJYxF8TDFwgrtUoTrA4rw+Vbh57NQY1FCSCwIn4MU4TxeFSKMRUkhsSCc7ynC+YoqShiLUkJiQTiuKUJdViUIY1GaKRbUBygI+68izD9F6T+dv1MBif763vXvib3t3yN7y79ndtS/h3bYv6f2un+P7TX/nttB/x7cK/49uZf9e3Qv+ffs9vj38F707+k979/j2+nf89P7AHpfIfuV/VBHqLm3gXDe815eskMdVjgPdWDeVogX5vt+XkbCunLqej8gTAaudn+AOgVRveeSLToqPMf2NuTlEfvsPgm1A+JE/hDlGvkplQ/oHKLwLjImHSDn9JyOnGnOuv5Aj9jl5PQPCTvgR8SqlulXXe+4IHNBge/SleWzUhywkuNOT3anpXgdaZ5Un9OX5PQ6g/VrTslO6dePmfz6cfB+/X+Rr58w+fWT/3i+fsrk10/9fo1DZdkvOw+eeLD/zD+pOK7HDI4B7kOG2dqHxDMJrnYH2jmsANodKscTzD60QruUTswTeelj8zmTKHx+CbG1QrvUcSZffMHkiy8YfbGByRc1ittbU7j6Q81/t905Hi3hyv1aQpYeCfNSEcZaUfpPT6T08qNpFSIqQH/mlE+4To4xi8oneFL55aVWIazQLnWCaRD48hKrEDlUo3L6O5rzlwyiUMcme0OBTN5CbfPJvPYUGMpY4Lw8iSYnwcYnJ59TxucrvLfgdELf8LqVz+tzJrlTHGkq2Zmc7HP53Mkel9eX5Er1ujOUK9XpSMlwWz7lychwJznT3cm+FG96sg+LtvI6nS5vSlq6SnIkp6ZZHq8z1fK53E544Pc63V6v05OcnOp0epM9Pk8KPKTDo7/HSnK7U6xkhzPFwRWfr9DTNdWgkNNqDq5TyqDwtcRB4WvmQeFrhkGhrk0GhYsmsfv8J/MpRecbmw4KdZlE5xuCQSGnpU3K+Hxr00GBKz7f/j9acv3Ov+R6yrTkaoV2XXS/g3KvMtS6CJdvFUfgM30YI8SHIb9r2+bx0B3me4aB/QemSc4PjMufp5h88SOTL35kXgrm8IWy+VIwV39w2HwpmCv3nUKWggnzUhHGWjkjS8HZr3NjFpVP8GT3J86n/u+ZBoGfGJ/6NeefGETBLWQp+HvCieDPee0pMG6mp8qfw7AUTBmfXwif+p2ET/1c8fnFEJ9Az9TktPRLGZ9fmfTzVwI/5LQ6RemH00x+OC0sH84w+eGMsHz4jckPv+Viq8jOEzsDXbI8xpPG3yVOGn9nnjT+zjBpTLHHe4TSwylyfxDWRTlpTGGalPyRi0ljqKfrKePzZ166iR7lpJErPn8SDI45XKTvzPiLTD89LAexP/CvulHvKFHm+Fmb72DoGJ9lGG/+Zhp7db15/L9PjfrnRfU3M+uj9vf+aPtzjMpHyDESKD6Ol0UCZanjAgIVHQmUpSbksT/HmEigLDVJQKBiI4Gy1GQBgYqLBMpSUwQEKj4SKEtNExCohEigLDVdQKDyRAJlqRkCApU3EihLzRQQqHyRQFlqloBA5Y8EylKzBQSqQCRQlporIFAFI4Gy1DwBgSoUCZSlFggIVOFIoCzVJc7+HItEAmWpRQJ6VNFIoCy1WECgikUCZamlAgJVPBIoSy0XEKgSkUBZaoWAQJWMBMpSKwUEqlQkUJZaLSBQpSOBstQpAaeQykQCZam1AnpU2UigLLVeQKDKRQJlqY0CAlU+EihLbRYQqAqRQFlqi4BAVYwEylLbBASqUiRQltohIFCVI4Gy1E4BgUqkDJT+gO40QGImWahcf1xEfxJBH3LX56f10Vx96lMfKNRn1fQxKH3CRh/e0OcC9Jaz3s3UG2V6D0Yv7+uVY70oqde79FKKfkrXD4D62UJPW/WMSA+2Wse1ROjs0w3jchrXBw2vtfkr8XSb9QfqqOutJ+TLovGHCUNtcxW6jqcI80ZRxiLGrwfZL7J4+K//4uclCfPHYiHIJZJVCRuOP42t681zkWBRvJPY9Ol+K7RLUX66v1o+3sHHCu069zaIagyDz+VM+XQ5yqfMi/pdpYR9QV1OOLhdweTTK/JlvTGBcWD5T3++u7rdBxY9qFRnEIIaTElb4xIDixXapd5hEsWaTL6oGQZRJIyjqkkoirWYfFpLuChKeJfClRJE8UoGIbiKKWmvYhTFt5lEsTaTL2qHQRQJ46hqE4piHSaf1hEuihLeW3K1BFG8mkEI6jIlbV1GUTzGJIoWky+sMIgiYRyVRSiKismnSrgoSnhHkEOCKDoYhMDJlLRORlF8i0kUXUy+cIVBFAnjqFyEopjE5NMk4aIo4X1cyRJEMZlBCNxMSetmFMU3mUTRw+QLTxhEkTCOykMoiilMPk0RLooS3n13jQRRvIZBCK5lStprGUXxKJMo1mPyRb0wiCJhHFU9QlGsz+TT+sJFUcJ7JhtIEMUGDELQkClpGzKK4hEmUWzE5ItGYRBFwjiqRoSi2JjJp42Fi6KEd7o2kSCKTRiE4DqmpL2OURQPM4liUyZfNA2DKBLGUTUlFMVmTD5tJlwUJbw/+XoJong9gxA0Z0ra5oyi+AaTKLZg8kWLMIgiYRxVC0JRbMnk05bCRVHCu8pbSRDFVgxC0JopaVsziuLrTKLYhskXbcIgioRxVG0IRbEtk0/bChdFCd8LcIMEUbyBQQjaMSVtO0ZRPMQkiu2ZfNE+DKJIGEfVnlAUOzD5tINwUZTwHRwdJYhiRwYhuJEpaW9kFMXXmESxE5MvOoVBFAnjqDoRimJnJp92Fi6KEr7vposEUezCIARdmZK2K6Movsokit2YfNEtDKJIGEfVjVAUb2Ly6U3CRVHCd0vdLEEUb2YQgluYkvYWRlE8yCSK3Zl80T0MokgYR9WdUBR7MPm0h3BRlPA9brdKEMVbGYSgJ1PS9mQUxQNMotiLyRe9wiCKhHFUvQhFMZXJp6nCRVHCdyamSRDFNAYhSGdK2nRGUXyFSRS9TL7whkEUCeOovISimMHk0wzhoijh+0l9EkTRxyAEvZmStjejKO5nEsU+TL7oEwZRJIyj6kMoin2ZfNpXuChK+C7g2ySI4m0MQtCPKWn7MYriy0yi2J/JF/3DIIqEcVT9CUVxAJNPBwgXRQnfuz1QgigOZBCCQUxJO4hRFPcxieJgJl8MDoMoEsZRDSYUxSFMPh0iXBQlfMf9UAmiOJRBCIYxJe0wRlF8iUkUhzP5YngYRJEwjmo4oSiOYPLpCOGiuFKAKN4uQRRvZxCCO5iS9g5GUdzLJIp3MvnizjCIImEc1Z2EojiSyacjhYviagGiOEqCKI5iEIK7mJL2LkZR3MMkincz+eLuMIgiYRzV3YSiOJrJp6OFi+KpaPtzHCNBFMcwCMFYpqQdyyiKu5lEcRyTL8aFQRQJ46jGEYriPUw+vUe4KK4VMFO8V4Io3ssgBPcxJe19jKL4IpMo3s/ki/vDIIqEcVT3E4rieCafjhcuiusFiOIECaI4gUEIJjIl7URGUXyBSRQnMfliUhhEkTCOahKhKD7A5NMHhIviRgGiOFmCKE5mEIIHmZL2QUZRfJ5JFKcw+WJKGESRMI5qCqEoTmXy6VThorhZgChOkyCK0xiE4CGmpH2IURR3MYnidCZfTA+DKBLGUU0nFMWHmXz6sHBR3CJAFGdIEMUZDELwCFPSPsIoijuZRHEmky9mhkEUCeOoZhKK4qNMPn1UuChuEyCKsySI4iwGIXiMKWkfYxTF55hEcTaTL2aHQRQJ46hmE4riHCafzhEuijsEiOJcCaI4l0EIHmdK2scZRXEHkyjOY/LFvDCIImEc1TxCUZzP5NP5wkVxpwBRXCBBFBcwCMETTEn7BKMobmcSxYVMvlgYBlEkjKNaSCiKi5h8usjvU23HAqqgXLsC/b9ayK6DbIXsJGSnILs+shsjuxmyWyK7LbI7ILszsm9Cdg9kpyI7A9l9kT0A2UOQPQLZI5E9Gtn3IHs8sh9A9lRkP4zsR5E9B9nzkY3j0TjveftJKFsMWAJYClgGWA54CrAC8DRgJWAVYDVgDeAZwFrAOsB6wAbARsAmwGbAs4AtgK2AbYDtgB2A5wA7AbsAzwNeAERHXXhR69BldHVZif56XgTeuwF7AHsBLwH2AV4G7Ae8AjgAOAh4FfAa4BDgdcAbgMOAI4CjgDcBbwGOAd4GvAN4F/Ae4H3AB4APAR8BPgZ8ku+8k3A/exHFNbNst6Fsj6Fsr6HsJUPZPkPZy4ay/YayVwxlBwxlBw1lrxrKXjOUHTKUvW4oe8NQdthQdsRQdtRQ9qah7C1D2TFD2duGsncMZe8ayt4zlL1vKPvAUPahoewjQ9nHhrJP8v1znIz1/2zk/2mFdl3QZ0Md23TfCLWuDJ++LLU7Hx2vhsXpJ9ymWITSZh2LPST+Ox/XvaHX5fD7T71EGItGdo6F63881b7Q2myhNquXQ6nLcYH/1H7CWDS2ZyysbDzVK0G2Odn3jzarA8HV5TH4Tx0kjEUTu8XCY+SpXg28ze6LtFm9Fmhd7ov6Tx0ijMV19omF4xI81euBtNl9yTarN3JfV3oO/lOHCWPR1A6xcOfIUx3JXZutXLRZHc1NXVau/KfeJIxFs383Fkm55KneyqnNrly3WR27ZF0uXwD+U28TxuL6fysW7oB4qncu3mZPgG1W716krhRfwP5T7xHGonn4Y2EFwVO9b2qzFVSb1Qf/rEsF6T/1IWEsWoQzFt6geaqPLmyzM4Q2q49RXQ5fSP5TnxDGomWYYmGFdinC9QFF+Hyr8PNZqLFoJSQWhM9BinAer5oSxqK1kFgQzvcU4XxFNSeMRRshsSAc1xShLqtWhLFoyxQL6r1lwv6rCPNPUfovc28w0f8T70dk36/A+xl4vwPvh+D9Eryfgvdb8H4M3q/B+zl4vwfvB+H9IryfhPeb8H4U3q/C+1l4vwvvh+H9Mryfhvfb8H4c3q/D+3l4vw/vB+L9QryfiPcb1yN7A7I3InsTsjcj+1lkb0H2VmRvQ/Z2ZO9A9nPI3onsXch+HtkvIPtJZC9G9hJkL0X2MmQvR/ZTyF6B7KeRvRLZq5C9GtlrkP0Mstcie53fzhSUT+H3zwDHAScAnwO+AHwJOAn4CvA14BvAt4DvAKcA3wN+APwI+AnwM+AXwK+A04AzgN8AvwP+APwJ+AtwFvA3ICo/8AFEA2IAsYA4QDwgAZAHkBeQD5AfUABQEFAIUBhQBFA0P/8ZgBPR9GcAigHv4oASgJKAUoDSgDKAsoBygPKACoCKgEqAyoBEQBVAVUA1wOWAKwDVATUANQG1AFcCrgLUBtQBXA2oC7AAKv95J+F9Wc0n+15tcUNZCUNZSUNZKUNZaUNZGUNZWUNZOUNZeUNZBUNZRUNZJUNZZUNZoqGsiqGsqqGsmqHsckPZFYay6oayGoaymoayWoayKw1lVxnKahvK6hjKrjaU1TWUWYYylZ//DADus6HO4XTfCLWuzDMAxfPT8eoh5AxACRL/nY9rydDr+t8ZgFKEsbhVyBmA0qG1+YIzAGVCqSvbGYCyhLHoKeQMQLkg22w6A1A+uLqMZwAqEMail5AzABUDb/NFzwBUCrSuS5wBqEwYi1QhZwASA2lzDmcAquS+rhzPAFQljEWakDMA1XLX5lydAbg8N3Xl8gzAFYSxSBdyBqB6Tm0O4AxAjfx0ZwBqEsbCK+QMQK38dGcArsxPdwbgKsJYZAg5A1A7P90ZgDr56c4AXE0YC5+QMwB189OdAbDy050BUISx6C1kf41wfUARPt+qnoT7a32ExILwOUgRzuNVGmEs+gqJBeF8TxHOV1QGYSxuExILwnFNEeqy6kMYi35CzgAQ9l9FmH+K0n/ce4X7Euj3Ch0wd3ECXIAkQDLADfAAUgDXAK4F1APUBzQANNTzHUBjQBPAdYCmgGaA6wHNAS0ALQGtAK0BbQBtATcA2gHaAzoY9godhj0dp6HMZShLMpQlG8rchjKPoSzFUHaNoexaQ1k9Q1l9Q1kDQ1lDQ1kjQ1ljQ1kTQ9l1hrKmhrJmhrLrDWXNDWUtDGUtDWWtDGWtDWVtDGVtDWU3GMraGcraG8o65OffK8R9NlStdxDuFToJn1nuErJX6CLcK0wi3CtMJozF3UL2Ct2Ee4Uewr3CFMJYjBayV3gN4V7htYR7hfUIYzFGyF5hfcK9wgaEe4UNCWMxVsheYSPCvcLGhHuFTQhjMU7IXuF1hHuFTQn3CpsRxuIeIXuF1xPuFTYn3CtsQRiLe4XsFbYk3CtsRbhX2JowFvcJ2StsQ7hX2JZwr/AGwljcL2SvsB3hXmF7wr3CDoSxGC9kHZ5wfUARPt+q0YTr8BOExILwOUgRzuPVOMJYTBQSC8L5niKcr6j7CGMxSUgsCMc1RajLagJhLB4QsldI2H8VYf6pBwTtFR5g2CvsCHOXGwGdAJ0BXQBdAd0ANwFuBtwC6A7oAbgV0BPQC5AKSAOkA7yADIAP0BvQB9AXcBugH6A/YABgIGAQYDBgiGGvsKNhT+dGQ1knQ1lnQ1kXQ1lXQ1k3Q9lNhrKbDWW3GMq6G8p6GMpuNZT1NJT1MpSlGsrSDGXphjKvoSzDUOYzlPU2lPUxlPU1lN1mKOtnKOtvKBtgKBtoKBtkKBtsKBuSn3+v8ADhXmFHwr3CGwmfWeYI2SvsRLhX2Jlwr7ALYSzmCtkr7Eq4V9iNcK/wJsJYPC5kr/Bmwr3CWwj3CrsTxmKekL3CHoR7hbcS7hX2JIzFfCF7hb0I9wpTCfcK0whjsUDIXmE64V6hl3CvMIMwFk8I2Sv0Ee4V9ibcK+xDGIuFQvYK+xLuFd5GuFfYjzAWi4TsFfYn3CscQLhXOJAwFk8K2SscRLhXOJhwr3AIYSwWC1mHJ1wfUITPt+pxwnX4JUJiQfgcpAjn8WoBYSyWCokF4XxPEc5X1CLCWCwTEgvCcU0R6rJaQhiL5UL2Cgn7ryLMP0XpP73/UAD5Tv/uhM2Is37bheweced/RqN/WxP9/1p+eyjMLYYBhgPi/PVHR/3zot6XHJ6fJ6+iaHk6sC9G5D//83b/HuT/NoX0//grGwHqBB9OtpHj840gnFDezhTIaGL/Ubb5DlSXggVBWMjT/87jtZTLC0txDoc3zWWlW6npjowUFzwLuxwuZ7o3HRYnPKnKZ/lS01N8nvO8dKfLzKfsF3WnuyM/rRhlXnfmZySsK6eudyRhMnC1e2T+LAcT1WvkSiEAI/PT1zuKOFkzxVrXy33qhlIUubkOJeSa6K/nLqjzbsBowBjAWMA4wD2AewH3Ae4HjAdMAEwETAI8AJgMeBAwBTAVMA3wEGA64GHADMAjgJmARwGzAI8BZgPmAOb61RTH/C7DSY67DWWjDWVjDGVjDWXjDGX3GMruNZTdZyi731A23lA2wVA20VA2yVD2gKFssqHsQUPZFEPZVEPZNEPZQ4ay6Yayhw1lMwxljxjKZhrKHjWUzTKUPWYom20om2Mom5uf/4TQUMLx6y7CE0J3E/J6VsgJodGEJ4TGEJ4QGksYiy1CTgiNIzwhdA/hCaF7CWOxVcgJofsITwjdT3hCaDxhLLYJOSE0gfCE0ETCE0KTCGOxXcgJoQcITwhNJjwh9CBhLHYIOSE0hfCE0FTCE0LTCGPxnJATQg8RnhCaTnhC6GHCWOwUckJoBuEJoUcITwjNJIzFLiEnhB4lPCE0i/CE0GOEsXheyAmh2YQnhOYQnhCaSxiLF4TsvhOuDyjC51u1lXD3/UUhsSB8DlKE83i1gzAWu4XEgnC+pwjnK2oXYSz2CIkF4bimCHVZvUgYi71CTggR9l9FmH+K0n86f2cBEv31zfXvic3275HN8u+ZzfTvoc3w76lN9++xTfPvuU3x78FN9u/JTfLv0U3w79nd79/Du9e/pzfOv8c3xr/np/cB9L5C9iv7oY5Qc28Y4bzn8fxkhzqscB7qwLytEC/Md15+RsK6cup65xMmA1e756NOQVTvuWSLjgrPsb1h+XnEPrtPQu2AOJEXoFwjP6Uyn84hCu8iY9IBck7P6ciZ5qzrD/SIXU5OX0DYAZ8gVrVMv+p6xwWZC0p/plRZPivFASs57vRkd1qK15HmSfU5fUlOrzNYv+aU7JR+Xcjk14XB+/X/Rb4uYvLrov94vj7J5Ncn/X6NQ2XZLzsPnniwX+yfVCzRYwbHALeAYba2gHgmwdXuQDuHFUC7Q/7QGrMPrdAupRNzaX762CxjEoVllxBbK7RLLWHyxXImXyxn9MUwJl+8WdzemsLVH976d9ud49ESrtw/JmTpkTAvFWGsFaX/9ERKLz+aViGiAvRnTvmE6+QYs6h8gieVT11qFcIK7VJLmQaBpy6xCpFDNSqnv6M5P8UgCu/ZZG8okMlbqG1ekd+eAkMZC5yXK9DkJNj45ORzyvg8jfcWnE7oG1638nl9ziR3iiNNJTuTk30unzvZ4/L6klypXneGcqU6HSkZbsunPBkZ7iRnujvZl+JNT/Zh0VZep9PlTUlLV0mO5NQ0y+N1plo+l9sJD/xep9vrdXqSk1OdTm+yx+dJgYd0ePT3WElud4qV7HCmOLji8zR6uqYaFHJazcF1ShkUVkocFFYyDworGQaFD2wyKFw0id3nP5lPKTqrbDoofMAkOqsIBoWcljYp47PapoMCV3xW/z9acl3jX3J9xrTkaoV2XXS/g3KvMuR3wBKKC0fgM30YI8SHoda11ubx0B1mLcPAvo5pkrOOcfnzGSZfrGfyxXrmpWAOX3xk86Vgrv7wsc2Xgrly/xMhS8GEeakIY60+iSwFZ7/OjVlUPsGT3Q2cT/1rmQaBDYxP/ZrzBgZROCFkKXgt4URwY357CswJpqfKjWFYCqaMzybCp/5PCJ/6ueKzyRCfQM/U5LT0SxmfzUz6uZnADzmtTlH64VkmPzwrLB+2MPlhi7B82Mrkh6252Cqy88TOQJcsj/GkcZvESeM25knjNoZJ4xf2eI9QejhFbjthXZSTxi+YJiXbczFpDPV0PWV8duSnm+hRThq54rODYHDM4SJ9Z8ZzZPrpYTmIPd+/6ka9o0SZ4zttvoOhY7yTYbzZxTT26nrz+H+fFfXPi+pvZtZH7e/90fbn+DzlRDISKD6OL0QCZanjAgL1YiRQlpqQx/4cd0cCZalJAgK1JxIoS00WEKi9kUBZaoqAQL0UCZSlpgkI1L5IoCw1XUCgXo4EylIzBARqfyRQlpopIFCvRAJlqVkCAnUgEihLzRYQqIORQMGmiYBAvRoJlKXmCQjUa5FAWWqBgEAdigTKUl3i7M/x9UigLLVIQI96IxIoSy0WEKjDkUBZaqmAQB2JBMpSywUE6mgkUJZaISBQb0YCZamVAgL1ViRQllotIFDHIoGy1CkBp5DejgTKUmsF9Kh3IoGy1HoBgXo3EihLbRQQqPcigbLUZgGBej8SKEttERCoDyKBstQ2AYH6MBIoS+0QEKiPIoGy1E4BgfqYMlD6A7qPARL9FerP9OiPi+hPIuhD7vr8tD6aq0996gOF+qyaPgalT9jowxv6XIDecta7mXqjTO/B6OV9vXKsFyX1epdeStFP6foBUD9b6GmrnhHpwVbruJYInX26YVxO4/qg4UmbvxJPt/l5hnZ/JeXLogk/TPsJ4YdpCfNGUcYixq8H2S8qrpn1/Rc/L0mYPxYLQS6R/JTp09if+j+NbfIFxTuJTZ/ut0K7FOWn+z/Lzzv4WKFd594G8RlDPh1nyqfjKJ8yL+p3lRL2BXWcMJdOMPn0BHpjAuPA8p/+fPfndh9Y9KDyOcdrpZiS9otLDCxWaJeawySKXzL54sswiCJhHNWXhKJ4ksmnJ4WLooR3KXwlQRS/YhCCr5mS9mtGUZzNJIrfMPnimzCIImEc1TeEovgtk0+/FS6KEt5b8p0EUfyOQQhOMSXtKUZRfIxJFL9n8sX3YRBFwjiq7wlF8Qcmn/4gXBQlvCPoRwmi+CODEPzElLQ/MYriLCZR/JnJFz+HQRQJ46h+JhTFX5h8+otwUZTwPq5fJYjirwxCcJopaU8ziuKjTKJ4hskXZ8IgioRxVGcIRfE3Jp/+JlwUJbz77ncJovg7gxD8wZS0fzCK4kwmUfyTyRd/hkEUCeOo/iQUxb+YfPqXcFGU8J7JsxJE8SyDEPzNlLR/M4riI0yiGFWAxxe6Xm5RJIyjwn4I1aeXMfn0sgKyRVHCO12jCwgQRU2SWghimJI2pgCfKM5gEsVYJl/EhkEUCeOoYglFMY7Jp3HCRVHC+5PjJYhiPIMoJjAlbQKjKD7MJIp5mHyRJwyiSBhHlYdQFPMy+TSvcFGU8K7yfBJEMR+DKOZnStr8jKI4nUkUCzD5okAYRJEwjqoAoSgWZPJpQeGiKOF7AQpJEMVCDKJYmClpCzOK4kNMoliEyRdFwiCKhHFURQhFsSiTT4sKF0UJ38FRTIIoFmMQxeJMSVucURSnMYliCSZflAiDKBLGUZUgFMWSTD4tKVwUJXzfTSkJoliKQRRLMyVtaUZRnMokimWYfFEmDKJIGEdVhlAUyzL5tKxwUZTw3VLlJIhiOQZRLM+UtOUZRXEKkyhWYPJFhTCIImEcVQVCUazI5NOKwkVRwve4VZIgipUYRLEyU9JWZhTFB5lEMZHJF4lhEEXCOKpEQlGswuTTKsJFUcJ3JlaVIIpVGUSxGlPSVmMUxclMong5ky8uD4MoEsZRXU4oilcw+fQK4aIo4ftJq0sQxeoMoliDKWlrMIriA0yiWJPJFzXDIIqEcVQ1CUWxFpNPawkXRQnfBXylBFG8kkEUr2JK2qsYRXESkyjWZvJF7TCIImEcVW1CUazD5NM6wkVRwvduXy1BFK9mEMW6TElbl1EUJzKJosXkCysMokgYR2URiqJi8qkSLooSvuPeIUEUHQyi6GRKWiejKE5gEkUXky9cYRBFwjgqF6EoJjH5NEm4KK4UIIrJEkQxmUEU3UxJ62YUxfFMouhh8oUnDKJIGEflIRTFFCafpggXxdUCRPEaCaJ4DYMoXsuUtNcyiuL9TKJYj8kX9cIgioRxVPUIRbE+k0/rCxfFU9H259hAgig2YBDFhkxJ25BRFO9jEsVGTL5oFAZRJIyjakQoio2ZfNpYuCiuFTBTbCJBFJswiOJ1TEl7HaMo3sskik2ZfNE0DKJIGEfVlFAUmzH5tJlwUVwvQBSvlyCK1zOIYnOmpG3OKIr3MIliCyZftAiDKBLGUbUgFMWWTD5tKVwUNwoQxVYSRLEVgyi2Zkra1oyiOI5JFNsw+aJNGESRMI6qDaEotmXyaVvhorhZgCjeIEEUb2AQxXZMSduOURTHMolieyZftA+DKBLGUbUnFMUOTD7tIFwUtwgQxY4SRLEjgyjeyJS0NzKK4hgmUezE5ItOYRBFwjiqToSi2JnJp52Fi+I2AaLYRYIodmEQxa5MSduVURRHM4liNyZfdAuDKBLGUXUjFMWbmHx6k3BR3CFAFG+WIIo3M4jiLUxJewujKN7NJIrdmXzRPQyiSBhH1Z1QFHsw+bSHcFHcKUAUb5UgircyiGJPpqTtySiKdzGJYi8mX/QKgygSxlH1IhTFVCafpvp9qu1YQBWUayfyZ/2/k8j+Ftk/IPsXZP+G7L+QfRn6e3HIzovsgsguiuySyC6L7IrIroLsK5BdC9l1kK2QnYTsFGTXR3ZjZDdDdktkt0V2B2R3RvZNyO6BbByPxnnP22lQlg7wAjIAPkBvQB9AX8BtgH6A/oABgIGAQYDBgCGAoYBhgOGAEYDbAXcA7gSMBIwC3AW4GzAaMAYwFjAOcA/SyoUoNxSKqYXsusi+Gtl1kF0b2Vch+0pk10J2TWTXQHZ1ZF+B7MuRXQ3ZVZFdBdmJyK6M7ErIrojsCsguj+xyyC6L7DLILo3sUsguiewSyC6O7GL5s/Svkf+nFeIVqS9SX6S+SH2R+iL1ReqL1CerPreirc/loK1PuYjb647kS6S+SH2R+iL1ReqL1BepL1Lff6o+9b91ZbQu2B7Z7ZB9A7LbIrsNslsjuxWyWyK7BbKbI/t6ZDdDdlNkX4fsJshujOxGyG6I7AbIro/sesi+FtnXIDsF2R5ku5GdjOwkZLuQ7US2A9lDkD0Y2YOQPRDZA5DdH9n9kH0bsvsiuw+yeyPbh+wMZHuRnY7sNGSnIrsXsnsi+1Zk90B2d2TfguybkX0TsrshuyuyuyC7M7I7IftGZHdE9lC0TzIM2cORPQLZtyP7DmTfieyRyB6F7LuQfTeyRyN7DLLHInscsu9Bdhqy05HtRXYGsn3I7o3sPsjui+zbkN0P2f2RPQDZA5E9CNmDkT3Eb6+NOn/dC7/fB7gfMB4wATARMAnwAGAy4EHAFMBUwDTAQ4DpgIcBMwCPAGYCHgXMAjwGmA2YA5gLeBwwDzAfsADwBGAhYBHgScBiwBLAUsAywHLAU4AVgKcBKwGrAKsBawDPANYC1gHWAzYANgI2ATYDngVsAWwFbANsB+wAPAfYCdgFeB7wAuBFwG7AHsBewEuAfYCXAfsBrwAOAA4CXgW8BjgEeB3wBuAw4AjgKOBNwFuAY4C3Ae8A3gW8B3gf8AHgQ8BHgI8BnwA+BXwGOA44Afgc8AXgS8BJwFeArwHfAL4FfAc4Bfge8APgR8BPgJ8BvwB+BZwGnAH8Bvgd8AfgT8BfgLOAvwFRBSEfANGAGEAsIA4QD0gA5AHkBeQD5AcUABQEFAIUBhQBFAUUAxQHlACUBJQClAaUAZQFlAOUB1QAVARUAlQGJAKqAKoCqgEuB1wBqA6oAagJqAW4EnAVoDagDuBqQF2ABVCac1TWPnjmlWk38v8Mdd/+5wTwZ8I/67VCu5Suk6guKxq131HQ3+6CfmdkOkj/j3HZypz+Mk7HUR/wwI4LlaP2SS7rSs+hLuUsSBdQndj6MAcObPYrt38rJ964TuokdxD6BHdyV/bk1gWXZXNQDHFCB9AYlcP/t1wF6XglFSRLhgtfII7EgcunTkI/UPo0OQCf5vS3sE+T/T7N3rGpO16tPHQdL9Ffjxu4ewApgGsA1wLqAeoDGgAaap8BGgOaAK4DNAU0A1wPaA5oAWgJaAVoDWgDaAu4AdAO0B7QAdARcCOgE6AzoIu/w2Nfaj6ZM9v/vTPbUJZiKLvGUHatoayeoay+oayBoayhoayRoayxoayJoew6Q1lTQ1kzQ9n1hrLmhrIWhrKWhrJWhrLWhrI2hrK2hrIbDGXtDGXtDWUdDGUdDWU3Gso6Gco6G8q6FMw6uZV5xfp/NvL/tEK7LuizIb+fn0ALM3z6spSHUFe/LU5/BN4Ui1DarGORQuK/83G9JvS6HJmTtWsJY/GdnWPhypqg1gutzRae7NYPpS7HhRPnBoSxOGXPWFjZHxYaBtnmZN8/HzwaBVeXx/QQ05gwFt/bLRYe84Nbk8Db7L7YQ+B1gdblvvgDZVPCWPxgn1g4LvUQ3SyQNrsv/UB+PeGiRHPCWPxoh1i4c+SpWuSuzVYu2qxa5qYuK1f+U60IY/HTvxuLpFzyVK1zarMr121WbS5Zl8sXgP9UW8JY/PxvxcIdEE91w8Xb7AmwzardRepK8QXsP9WeMBa/hD8WVhA8VQdTm62g2qw6/rMuFaT/1I2Esfg1nLHwBs1Tdbqwzc4Q2qw6o7ocvpD8p7oQxuJ0mGJhhXYpwvUBRfh8q/DzWaixOCMkFoTPQYpwHq9+JIzFb0JiQTjfU4TzFfULYSx+FxILwnFNEeqyOkMYiz+YYkF9GICw/yrC/FOU/uPeK6zJsFfYFeYu3QA3AW4G3ALoDugBuBXQE9ALkApIA6QDvIAMgA/QG9AH0BdwG6AfoD9gAGAgYBBgMGAIYChgGGA4YATgdsNeYVfDnk43Q9lNhrKbDWW3GMq6G8p6GMpuNZT1NJT1MpSlGsrSDGXphjKvoSzDUOYzlPU2lPUxlPU1lN1mKOtnKOtvKBtgKBtoKBtkKBtsKBtiKBtqKBtmKBtuKBthKLu9IP9eYU3CvcKuhHuF3QifWfKXkLFXeBPhXuHNhHuFtxDGooCdY4H2CrsT7hX2INwrvJUwFgXtGYt/7BX2JNwr7EW4V5hKGItCdovFRfYK0wj3CtMJ9wq9hLEobJ9YXHKvMINwr9BHuFfYmzAWRewQi1zsFfYh3CvsS7hXeBthLIr+u7HI9V5hP8K9wv6Ee4UDCGNR7N+KRYB7hQMJ9woHEe4VDiaMRfHwxyKovcIhhHuFQwn3CocRxqJEOGMRwl7hcMK9whGEe4W3E8aiZJhiYYV2KcL1AUX4fKvw81mosSglJBaEz0GKcB6vihDGorSQWBDO9xThfEUVJ4xFGSGxIBzXFKEuq1KEsSjLFAvqvULC/qsI809R+o97r7AGXV3/2yu8A+YudwJGAkYB7gLcDRgNGAMYCxgHuAdwL+A+wP2A8YAJgImASYAHAJMBDwKmAKYCpgEeAkwHPAyYAXgEMBPwKGCWYa/wDsOezp2GspGGslGGsrsMZXcbykYbysYYysYaysYZyu4xlN1rKLvPUHa/oWy8oWyCoWyioWySoewBQ9lkQ9mDhrIphrKphrJphrKHDGXTDWUPG8pmGMoeMZTNNJQ9aiibVZB/rxD32VC1/g7CvcI7CZ9ZagnZKxxJuFc4inCv8C7CWFwpZK/wbsK9wtGEe4VjCGNxlZC9wrGEe4XjCPcK7yGMRW0he4X3Eu4V3ke4V3g/YSzqCNkrHE+4VziBcK9wImEsrhayVziJcK/wAcK9wsmEsagrZK/wQcK9wimEe4VTCWNhCdkrnEa4V/gQ4V7hdMJYKCF7hQ8T7hXOINwrfIQwFg4he4UzCfcKHyXcK5xFGAunkHV4wvUBRfh8q64iXId3CYkF4XOQIpzHq6sJY5EkJBaE8z1FOF9RijAWyUJiQTiuKUJdVi7CWLiF7BUS9l9FmH+Ky3/U+4Q94uTsaToZPv/4GMyxZgPmAOYCHgfMA8wHLAA8AVgIWAR4ErAYsASwFLAMsBzwFGAF4GnASsAqwGrAGsAzgLWAdYD1gA2AjYBNgM2GPc3HDHtPsw1lcwxlcw1ljxvK5hnK5hvKFhjKnjCULTSULTKUPWkoW2woW2IoW2ooW2YoW24oe8pQtsJQ9rShbKWhbJWhbLWhbI2h7BlD2VpD2TpD2XpD2QZD2UZD2SZD2eaC/HuaTsLPPz5GuKc5m/DZqrmQPc05hHuacwn3NB8njEULIXua8wj3NOcT7mkuIIxFSyF7mk8Q7mkuJNzTXEQYi1ZC9jSfJNzTXEy4p7mEMBathexpLiXc01xGuKe5nDAWbYTsaT5FuKe5gnBP82nCWLQVsqe5knBPcxXhnuZqwljcIGRPcw3hnuYzhHuaawlj0U7InuY6wj3N9YR7mhsIY9FeyJ7mRsI9zU2Ee5qbCWPRQch+AeH6gCJ8vlUtCfcLOgqJBeFzkCKcx6s2hLG4UUgsCOd7inC+otoRxqKTkFgQjmuKUJdVR8JYdBayp0nYfxVh/ilK/+n8nQ9I9Ne32b8nttG/R7bev2e21r+Htsa/p7bKv8f2tH/P7Sn/Htwy/57cEv8e3ZP+PbuF/j28Bf49vXn+Pb65/j0/vQ+g9xWyX9HZYhrymR/CfZBn0RxKwRoOrL3of+fxWsrlhdUTh8Ob5rLSrdR0R0aKCx5fXA6XM92bDs+TnlTls3yp6Sk+z/m69BfY5o/K2qvFF/X+LeZthXhhvlsKMhLWlVPXu5VwEszV7q2oUxDVey7ZoqPM35ZM3QZXHh6xz+6TUDsgTuRtKNf+4ZBQE2UrXe9TeBcZkw6Qc3oOzjnXUXT92dU4J4I5OX0bYQfcTqxqmX7V9Y4LMhcU+C5dWT4rxQErOe70ZHdaiteR5kn1OX1JTq8zWL/mlOyUft3B5Ncdwfv1/0W+Psfk1+f+4/m6k8mvO/1+jUNl2S87D554sN/ln1Q8r8cMjgFuG8NsbVtB2pkEV7sD7RxWAO0OleMLzD60QruUTswXCtLH5kUmUXjxEmJrhXap55l8sZvJF7sZfaGFkMMXGSXsrSlc/cH377Y7x6MlXLnfW8jSI2FeKsJYK0r/6YmUXn40rUJEBejPnPIJ18kxZlH5BE8q91xqFcIK7VIvMA0Cey6xCpFDNSqnv6M572EQhX422RsKZPIWapv3FrSnwFDGAuflXjQ5CTY+OfmcMj4v4b0FpxP6htetfF6fM8md4khTyc7kZJ/L5072uLy+JFeq152hXKlOR0qG2/IpT0aGO8mZ7k72pXjTk31YtJXX6XR5U9LSVZIjOTXN8nidqZbP5XbCA7/X6fZ6nZ7k5FSn05vs8XlS4CEdHv09VpLbnWIlO5wpDq74vISerqkGhZxWc3CdUgaFfRIHhX3Mg8I+hkFhgE0GhYsmsfvcJ6h8lKLzsk0HhQFMovMywaCQ09ImZXz223RQ4IrP/v9HS66v+JdcD5iWXK3Qrovud1DuVYZaF+HyreIIfKYPY4T4MNS6Dto8HrrDHGQY2F9lmuS8yrj8eYDJF68x+eI15qVgDl8MsvlSMFd/GGzzpWCu3B8iZCmYMC8VYazVkMhScPbr3JhF5RM82T3E+dR/kGkQOMT41K85H2IQhRFCloIPEk4EXy9oT4EZwfRU+XoYloIp4/MG4VP/EMKnfq74vGGIT6BnanJa+qWMz2Em/TxM4IecVqco/XCEyQ9HhOXDUSY/HBWWD28y+eHNXGwV2XliZ6BLlsd40viWxEnjW8yTxrcYJo132OM9QunhFLljhHVRThrvYJqUHMvFpDHU0/WU8Xm7IN1Ej3LSyBWftwkGxxwu0ndmvEOmnx6Wg9hb/atu1DtKlDn+rs13MHSM32UYb95jGnt1vXn8v8+P+udF9Tcz66P29/5o+3N8n3IiGQkUH8cPIoGy1HEBgfowEihLTchjf44fRQJlqUkCAvVxJFCWmiwgUJ9EAmWpKQIC9WkkUJaaJiBQn0UCZanpAgJ1PBIoS80QEKgTkUBZaqaAQH0eCZSlZgkI1BeRQFlqtoBAfRkJlKXmCgjUyUigLDVPQKC+igTKUgsEBOrrSKAs1SXO/hy/iQTKUosE9KhvI4Gy1GIBgfouEihLLRUQqFORQFlquYBAfR8JlKVWCAjUD5FAWWqlgED9GAmUpVYLCNRPkUDBQC3gFNLPkUBZaq2AHvVLJFCWWi8gUL9GAmWpjQICdToSKEttFhCoM5FAWWqLgED9FgmUpbYJCNTvkUBZaoeAQP0RCZSldgoI1J+UgdIf0F0ASPRXqD/Toz8uoj+JoA+56/PT+miuPvWpDxTqs2r6GJQ+YaMPb+hzAXrLWe9m6o0yvQejl/f1yrFelNTrXXopRT+l6wdA/Wyhp616RqQHW63jWiJ09umGcTmN64OGI23+Sjzd5vcZ2j1KyJdFv0/4Ydq/CD9MS5g3ijIWMX49yH5Rcc2s77/4eUnC/LFYCHKJ5FmmT2Of9X8a2+QLincSmz7db4V2KcpP9/9dkHfwsUK7zr0N4m+GfIoqxJNPut7MfMq8qN9VStgXFPZDqD69jMmnlxXKemMC48Dyn/58d3Qhmw8selDRJKmFIIYpaWMKXXxgsUK71CYmUYxl8kVsGESRMI4qllAU45h8GidcFCW8SyFegijGM4hiAlPSJjCK4kYmUczD5Is8YRBFwjiqPISimJfJp3mFi6KE95bkkyCK+RhEMT9T0uZnFMUNTKJYgMkXBcIgioRxVAUIRbEgk08LChdFCe8IKiRBFAsxiGJhpqQtzCiK65lEsQiTL4qEQRQJ46iKEIpiUSafFhUuihLex1VMgigWYxDF4kxJW5xRFNcxiWIJJl+UCIMoEsZRlSAUxZJMPi0pXBQlvPuulARRLMUgiqWZkrY0oyiuZRLFMky+KBMGUSSMoypDKIplmXxaVrgoSnjPZDkJoliOQRTLMyVteUZRfIZJFCsw+aJCGESRMI6qAqEoVmTyaUXhoijhna6VJIhiJQZRrMyUtJUZRXENkygmMvkiMQyiSBhHlUgoilWYfFpFuChKeH9yVQmiWJVBFKsxJW01RlFczSSKlzP54vIwiCJhHNXlhKJ4BZNPrxAuihLeVV5dgihWZxDFGkxJW4NRFFcxiWJNJl/UDIMoEsZR1SQUxVpMPq0lXBQlfC/AlRJE8UoGUbyKKWmvYhTFlUyiWJvJF7XDIIqEcVS1CUWxDpNP6wgXRQnfwXG1BFG8mkEU6zIlbV1GUXyaSRQtJl9YYRBFwjgqi1AUFZNPlXBRlPB9Nw4JouhgEEUnU9I6GUVxBZMouph84QqDKBLGUbkIRTGJyadJwkVRwndLJUsQxWQGUXQzJa2bURSfYhJFD5MvPGEQRcI4Kg+hKKYw+TRFuChK+B63aySI4jUMongtU9JeyyiKy5lEsR6TL+qFQRQJ46jqEYpifSaf1hcuihK+M7GBBFFswCCKDZmStiGjKC5jEsVGTL5oFAZRJIyjakQoio2ZfNpYuChK+H7SJhJEsQmDKF7HlLTXMYriUiZRbMrki6ZhEEXCOKqmhKLYjMmnzYSLooTvAr5egihezyCKzZmStjmjKC5hEsUWTL5oEQZRJIyjakEoii2ZfNpSuChK+N7tVhJEsRWDKLZmStrWjKK4mEkU2zD5ok0YRJEwjqoNoSi2ZfJpW+GiKOE77m+QIIo3MIhiO6akbccoik8yiWJ7Jl+0D4MoEsZRtScUxQ5MPu0gXBRXChDFjhJEsSODKN7IlLQ3MoriIiZR7MTki05hEEXCOKpOhKLYmcmnnYWL4moBothFgih2YRDFrkxJ25VRFBcyiWI3Jl90C4MoEsZRdSMUxZuYfHqTcFE8FW1/jjdLEMWbGUTxFqakvYVRFJ9gEsXuTL7oHgZRJIyj6k4oij2YfNpDuCiuFTBTvFWCKN7KIIo9mZK2J6MoLmASxV5MvugVBlEkjKPqRSiKqUw+TRUuiusFiGKaBFFMYxDFdKakTWcUxflMouhl8oU3DKJIGEflJRTFDCafZggXxY0CRNEnQRR9DKLYmylpezOK4jwmUezD5Is+YRBFwjiqPoSi2JfJp32Fi+JmAaJ4mwRRvI1BFPsxJW0/RlF8nEkU+zP5on8YRJEwjqo/oSgOYPLpAOGiuEWAKA6UIIoDGURxEFPSDmIUxblMojiYyReDwyCKhHFUgwlFcQiTT4cIF8VtAkRxqARRHMogisOYknYYoyjOYRLF4Uy+GB4GUSSMoxpOKIojmHw6Qrgo7hAgirdLEMXbGUTxDqakvYNRFGczieKdTL64MwyiSBhHdSehKI5k8ulI4aK4U4AojpIgiqMYRPEupqS9i1EUH2MSxbuZfHF3GESRMI7qbkJRHM3k09EGn1Lnw5jguSeZuJcGxCKujfNGRZ31286CWbYD2ZrDWXTfWPh9HOAewL2Fssq58upKOvFWYwnz6j5qwWby31WE/htH6L/7iftl9ty+r1BWDt+P7HuQfW+23B4Pv08ATARM8ud2dNSFF/VYMp7QD4n+eh6AOicDHgRMAUwFTAM8BJgOeBgwA/AIYCbgUcAswGOA2YA5gLmAxwHzAPMBCwBPABYCFgGeBCwGLAEsBSwDLAc8Vei8k7BWPuDXSlw22VD2oKFsiqFsqqFsmqHsIUPZdEPZw4ayGYayRwxlMw1ljxrKZhnKHjOUzTaUzTGUzTWUPW4om2com28oW2Aoe8JQttBQtshQ9qShbLGhbImhbKmhbJmhbLmh7CnDuJzZvxv5f1qhXRf02VB18AGCujJ8+rLUZMp5Uwme8S17LEJps47FgyT+Ox/XKaHX5fD7T00ljMUYO8fC9T+ealpobbZQm9VDodTluMB/ajphLMbaMxZWNp7q4SDbnOz7R5vVjODq8hj8px4hjMU4u8XCY+SpZgbeZvdF2qweDbQu90X9p2YRxuIe+8TCcQme6rFA2uy+ZJvV7NzXlZ6D/9Qcwljca4dYuHPkqebmrs1WLtqsHs9NXVau/KfmUa4T/LuxSMolTzU/pza7ct1mteCSdbl8AfhPPUG55vBvxcIdEE+18OJt9gTYZrXoInWl+AL2n3qSMBbjwx8LKwiearGpzVZQbVZL/lmXCtJ/ailhLCaEMxbeoHmqZRe22RlCm9VyVJfDF5L/1FOEsZgYplhYoV2KcH1AET7fKvx8FmosJgmJBeFzkCKcx6t7CWPxgJBYEM73FOF8RY0njMVkIbEgHNcUoS6rSYSxeJApFtT7kIT9VxHmn6L0X+be4Dj/T/17l4JZexSdkd0J2TciuyOyOyC7PbLbIfsGZLdFdhtkt0Z2K2S3RHYLZDdH9vXIbobspsi+DtlNkN0Y2Y2Q3RDZDZBdH9n1kH0tsq9BdgqyPch2I/t2ZI9A9nBkD0P2UGQPQfZgZA9C9kBkD0B2f2T3Q/ZtyO6L7D7I7o1sH7IzkO1Fdjqy05CdiuxeyO6J7FuR3QPZ3ZF9C7JvRvZNyO6G7K7InoXsR5E9E9mPIHsGsh9G9nRkP4TsacieiuwpyH4Q2ZOR/QCyJyF7IrInIHs8su9H9n3IvhfZ9yB7HLLHInsMskcj+25k34XsUcgeiew7kX0Hsi9De6RxyM6L7ILILorsksgui+yKyK6C7CuQXQvZdZCtkJ2E7BRk10d2Y2Q3Q3ZLZLdFdgdkd0b2TcjugexUZGcguy+yByB7CLJHIHskskcjG+/n4/1+fB4AnxfA5wnweQN8HgGfV8DnGfB5B3weAp+XwOcp8HkLfB4Dn9d4Ctl4vx3vx+P9eryfj/f78XkAfF4AnyfA5w3weQR8XgGfZ8DnHfB5iMzzEtOjzl8r4PenASsBqwCrAWsAzwDWAtYB1gM2ADYCNgE2A54FbAFsBWwDbAfsADwH2AnYBXge8ALgRcBuwB7AXsBLgH2AlwH7Aa8ADgAOAl4FvAY4BHgd8AbgMOAI4CjgTcBbgGOAtwHvAN4FvAd4H/AB4EPAR4CPAZ8APgV8BjgOOAH4HPAF4EvAScBXgK8B3wC+BXwHOAX4HvAD4EfAT4CfAb8AfgWcBpwB/Ab4HfAH4E/AX4CzgL8BUYXB54BoQAwgFhAHiAckAPIA8gLyAfIDCgAKAgoBCgOKAIoCigGKA0oASgJKAUoDygDKAsoBygMqACoCKgEqAxIBVQBVAdUAlwOuAFQH1ADUBNQCXAm4ClAbUAdwNaAuwAIogAPgBLgASYBkgBvgKRx1wXWZ/2cj/08rtEtdnYdu/sl9Vo3wLOb/zqqlgH+vAVwLqAeoD2gAaAhoBGgMaAK4DtAU0AxwPaA5oAWgJaAVoDWgDaAt4AZAO0B7QAdAR8CNgE6AzoAugK6AboXPO0n7KfP8kOaTqSOZZdcYyq41lNUzlNU3lDUwlDU0lDUylDU2lDUxlF1nKGtqKGtmKLveUNbcUNbCUNbSUNbKUNbaUNbGUNbWUHaDoaydoay9oayDoayjoexGQ1knQ1lnQ1kXQ1lXQ1k3fxm+qNdAcJ8Nda1B941Q68o8q3ZNYTpejws5q3Ytif/Ox7Ve6HX976xafcJYzBNyVq1BaG2+4Kxaw1DqynZWrRFhLOYLOavWOMg2m86qNQmuLuNZtesIY7FAyFm1poG3+aJn1ZoFWtclzqpdTxiLJ4ScVWseSJtzOKvWIvd15XhWrSVhLBYKOavWKndtztVZtda5qSuXZ9XaEMZikZCzam1zanMAZ9VuKEx3Vq0dYSyeFHJWrX1hurNqHQrTnVXrSBiLxULOqt1YmO6sWqfCdGfVOhPGYomQs2pdCtOdVetamO6sWjfCWCwVcg6EcH1AET7fqvmE50CWCYkF4XOQIpzHq4WEsVguJBaE8z1FOF9Riwlj8ZSQWBCOa4pQl9UywlisEHJWjbD/KsL8U5T+0/m7GJDor6+bf0+si3+PrJN/z6yjfw+tvX9P7Qb/Hlsb/55bK/8eXAv/ntz1/j26pv49uyb+PbxG/j29Bv49vnr+PT+9D5CSbY9VX9HZYhpq7l1FuA9yE5pDKVjDgbUX/e88Xku5vLB64nB401xWupWa7shIccHji8vhcqZ70+F50pOqfJYvNT3F5zlfVxzUkT8qa68WX9T7t5i3FeKF+d5cmJGwrpy63lsIJ8Fc7b4FdQqies8lW3TUP19qw9EGwhcPWQa6ZB0QJ3J3lGv/cEjI38hL1/sU3kXGpAPknJ6Dc851FF1/djXOiWBOTu9O2AF7EKva/76JtvCFJ7kDyQUFvktXls9KccBKjjs92Z2W4nWkeVJ9Tl+S0+sM1q85JTulX29l8uutwfv1/0W+9mTya8//eL72YvJrL79f41BZ9svOgyce7FP9k4o0PWZwDHDdGWZr3QvTziS42h1o57ACaHeoHNOZfWiFdimdmOmF6WPjZRIF7yXE1grtUmlMvshg8kUGoy+0EHL4YmsJe2sKV3/Y9u+2O8ejJVy5v13I0iNhXirCWCtK/+mJlOnVuvjK7d/KKZ9wnRxjFpVP8KTSd6lVCCu0S6UzDQK+S6xC5FCNyunvaM4+BlHYZZO9oUAmb6G2uXdhewoMZSxwXvZGk5Ng45OTzynj0wfvLTid0De8buXz+pxJ7hRHmkp2Jif7XD53ssfl9SW5Ur3uDOVKdTpSMtyWT3kyMtxJznR3si/Fm57sw6KtvE6ny5uSlq6SHMmpaZbH60y1fC63Ex74vU631+v0JCenOp3eZI/PkwIP6fDo77GS3O4UK9nhTHFwxacPerqmGhRyWs3BdUoZFPpKHBT6Mg8KfRkGhRdsMihcNInd5z5B5aMUndtsOii8wCQ6txEMCjktbVLGp59NBwWu+PT7f7Tk2t+/5DrAtORqhXZddL+Dcq8y1LoIl28VR+AzfRgjxIeh1jXQ5vHQHWYgw8A+iGmSM4hx+XMAky8GM/liMPNSMIcvdtt8KZirP+yx+VIwV+7vFbIUTJiXijDWam9kKTj7dW7MovIJnuwO4XzqH8g0CAxhfOrXnIcwiMJ+IUvBAwkngkML21Ng9jM9VQ4Nw1IwZXyGET717yV86ueKzzBDfAI9U5PT0i9lfIYz6edwAj/ktDpF6YcRTH4YISwfbmfyw+3C8uEOJj/ckYutIjtP7Ax0yfIYTxrvlDhpvJN50ngnw6TxgD3eI5QeTpEbSVgX5aTxANOkZGQuJo2hnq6njM+ownQTPcpJI1d8RhEMjjlcpO/MuItMPz0sB7Fv8a+6Ue8oUeb43TbfwdAxvpthvBnNNPbqevP4f18c9c+L6m9m1kft7/3R9uc4hnIiGQkUH8exkUBZ6riAQI2LBMpSE/LYn+M9kUBZapKAQN0bCZSlJgsI1H2RQFlqioBA3R8JlKWmCQjU+EigLDVdQKAmRAJlqRkCAjUxEihLzRQQqEmRQFlqloBAPRAJlKVmCwjU5EigLDVXQKAejATKUvMEBGpKJFCWWiAgUFMjgbJUlzgBD+WRQFlqkYAe9VAkUJZaLCBQ0yOBstRSAYF6OBIoSy0XEKgZkUBZaoWAQD0SCZSlVgoI1MxIoCy1WkCgHo0EylKnBJxCmhUJlKXWCuhRj0UCZan1AgI1OxIoS20UEKg5kUBZarOAQM2NBMpSWwQE6vFIoCy1TUCg5kUCZakdAgI1PxIoS+0UEKgFlIHSH9BdAkj0V6g/06M/LqI/iaAPuevz0/porj71qQ8U6rNq+hiUPmGjD2/ocwF6y1nvZuqNMr0Ho5f39cqxXpTU6116KUU/pesHQP1soaetekakB1ut41oidPbphnE5jeuDhq/a/JV4us1jGNr9mpAvix5D+GHaJwg/TEuYN4oyFjF+Pch+UXHNrO+/+HlJwvyxWAhyieRCpk9jL/R/GtvkC4p3Eps+3W+FdinKT/cvKsw7+FihXefeBrGIIZ+eZMqnJ1E+ZV7U7yol7AvqScJcWszk08XojQmMA8t/+vPdS+w+sOhBZQmDECxlStqllxhYrNAu1ZVJFJcx+WJZGESRMI5qGaEoLmfy6XLhoijhXQpPSRDFpxiEYAVT0q5gFMUuTKL4NJMvng6DKBLGUT1NKIormXy6UrgoSnhvySoJoriKQQhWMyXtakZR7MwkimuYfLEmDKJIGEe1hlAUn2Hy6TPCRVHCO4LWShDFtQxCsI4padcximInJlFcz+SL9WEQRcI4qvWEoriByacbhIuihPdxbZQgihsZhGATU9JuYhTFG5lEcTOTLzaHQRQJ46g2E4ris0w+fVa4KEp4990WCaK4hUEItjIl7VZGUezIJIrbmHyxLQyiSBhHtY1QFLcz+XS7cFGU8J7JHRJEcQeDEDzHlLTPMYpiByZR3Mnki51hEEXCOKqdhKK4i8mnu4SLooR3uj4vQRSfZxCCF5iS9gVGUWzPJIovMvnixTCIImEc1YuEoribyae7hYuihPcn75EginsYhGAvU9LuZRTFdkyi+BKTL14KgygSxlG9RCiK+5h8uk+4KEp4V/nLEkTxZQYh2M+UtPsZRfEGJlF8hckXr4RBFAnjqF4hFMUDTD49IFwUJXwvwEEJoniQQQheZUraVxlFsS2TKL7G5IvXwiCKhHFUrxGK4iEmnx4SLooSvoPjdQmi+DqDELzBlLRvMIpiGyZRPMzki8NhEEXCOKrDhKJ4hMmnR4SLooTvuzkqQRSPMgjBm0xJ+yajKLZmEsW3mHzxVhhEkTCO6i1CUTzG5NNjwkVRwndLvS1BFN9mEIJ3mJL2HUZRbMUkiu8y+eLdMIgiYRzVu4Si+B6TT98TLooSvsftfQmi+D6DEHzAlLQfMIpiSyZR/JDJFx+GQRQJ46g+JBTFj5h8+pFwUZTwnYkfSxDFjxmE4BOmpP2EURRbMInip0y++DQMokgYR/UpoSh+xuTTz4SLooTvJz0uQRSPMwjBCaakPcEois2ZRPFzJl98HgZRJIyj+pxQFL9g8ukXwkVRwncBfylBFL9kEIKTTEl7klEUr2cSxa+YfPFVGESRMI7qK0JR/JrJp18LF0UJ37v9jQRR/IZBCL5lStpvGUWxGZMofsfki+/CIIqEcVTfEYriKSafnhIuihK+4/57CaL4PYMQ/MCUtD8wimJTJlH8kckXP4ZBFAnjqH4kFMWfmHz6k3BRXClAFH+WIIo/MwjBL0xJ+wujKF7HJIq/Mvni1zCIImEc1a+EoniayaenhYviagGieEaCKJ5hEILfmJL2N0ZRbMIkir8z+eL3MIgiYRzV74Si+AeTT/8QLoqnou3P8U8JovgngxD8xZS0fzGKYmMmUTzL5IuzYRBFwjiqs4Si+DeTT/8WLoprBcwUo4oIEEVNkloILivCk7S6Xi5RbMQkitFMvoguwi+KhHFU2A+h+jSGyacxRWSL4noBohgrQRRjGUQxjilp4xhFsSGTKMYz+SI+DKJIGEcVTyiKCUw+TRAuihsFiGIeCaKYh0EU8zIlbV5GUWzAJIr5mHyRLwyiSBhHlY9QFPMz+TS/cFHcLEAUC0gQxQIMoliQKWkLMopifSZRLMTki0JhEEXCOKpChKJYmMmnhYWL4hYBolhEgigWYRDFokxJW5RRFOsxiWIxJl8UC4MoEsZRFSMUxeJMPi0uXBS3CRDFEhJEsQSDKJZkStqSjKJ4LZMolmLyRakwiCJhHFUpQlEszeTT0sJFcYcAUSwjQRTLMIhiWaakLcsoitcwiWI5Jl+UC4MoEsZRlSMUxfJMPi0vXBR3ChDFChJEsQKDKFZkStqKjKKYwiSKlZh8USkMokgYR1WJUBQrM/m0st+n2o7VlUdn5dr+6Kz/F7Ej9n/NXlw4y16O7JXIfgbZG5D9LLK3I3sXsncjex+yDyD7ELKPIPsYst9D9kfI/gzZXyD7a2SfQvZPyD6N7D+Q/TeyY5B2JCA7P7ILI7s4sksjuzyysR7dmzfLvg/Z9yN7PLInIHsisich+wFkT0b2g8ieguypyJ6G7IeQPR3ZDyN7BrIfQfZMZD+K7FnIfgzZs5E9B9lzkf04suchez6yFyD7CWQvRPYiZD+J7MXIXoLspchehuzlyH4K2SuQ/TSyVyJ7FbJXI3sNsp9B9lpkr0P2p/lQX0D2cWSfQPbnyP4C2V8i+ySyv0L218j+BtnfIvs7ZJ9C9vfI/gHZPyL7J2T/jOxfkP0rsk8j+wyyf0P278j+A9l/IvsvZJ9F9t/IjsqfZV+G7GhkxyA7FtlxyI5HdgKy8yA7L7LzITs/sgsguyCyCyG7MLKLILsoslcUQrmK7JXIXoXs1cheg+xnkL0W2euQvR7ZG5C9EdmbkL0Z2c8iewuytyJ7G7K3I3sHsp9D9k5k70L288h+AdkvIns3svcgey+yX0L2PmS/jOz9yH4F2QeQfRDZryL7NWQfQvbryH4D2YeRfQTZR5H9JrLfQvYxZL+N7HeQ/S6y30P2+8j+ANkfIvsjZH+M7E+Q/SmyP0P2cWSfQPbnyP4C2V8i+ySyv0L218j+BtnfIvs7ZJ9C9vfI/gHZPyL7J2T/jOxfkP0rsk8j+wyyf0P278j+A9l/IvsvZJ9F9t/IjkLzn8uQHY3nRciORXYcsuORnYDsPMjOi+x8yM6P7ALILojsQsgujOwiyC6K7GLILo7sEsguiexSyC6N7DLILovscsguj+wKyK6I7ErIrozsRGRXQXZVZFdD9uXIvgLZ1ZFdA9k1kV0L2Vci+ypk10Z2HWRfjey6yLaQrZDtQLYT2S5kJyE7GdluZHuQfW+BLPs+ZN+P7PHInoDsiciehOwHkD0Z2Q8iewqypyJ7GrIfQvZ0ZD+M7BnIfgTZM5H9KLJnIfsxZM9G9hxkz0X248ieh+z5yF6A7CeQvRDZi5D9JLIXI3sJspciexmylyP7KWSvQPbTyF6J7FXIXo3sNch+Btlrkb0O2euRvQHZG5G9Cdmbkf0ssrcgeyuytyF7O7J3IPs5ZO9E9i5kP4/sF5D9IrJ3I3sPsvci+yVk70P2y8jej+xXkH0A2QeR/SqyX0P2IWS/juw3kH0Y2UeQfRTZbyL7LWQfQ/bbyH4H2e8i+z1kv4/sD5D9IbI/QvbHyP4E2Z8i+zNkH0f2CWR/juwvkP0lsk8i+ytkf43sb5D9LbK/Q/YpZH+P7B+Q/SOyf0L2z8j+Bdm/Ivs0ss8g+zdk/47sP5D9J7L/QvZZZP+N7KiCWfZlyI5GdgyyY5Edh+x4ZCcgOw+y8yI7H7LzI7sAsgsiuxCyCyO7CLKLIrsYsosjuwSySyK7FLJLI7sMsssiuxyyyyO7ArIrIrsSsisjOxHZVZBdFdnVkH05sq9AdnVk10B2TWTXQvaVyL4K2bWRXQfZVyO7LrItZCu/nQjrcFUAVQHVAJcDrgBUB9QA1ATUAlwJuApQG1AHcDWgLsACKIAD4AS4AEmAZIAb4AGkAK4BXAuoB6gPaABoWCTqgsu/JUG2L1MtD92+TCPC/aJz/dQfB11vIvyM0/0sKmufC1+XEfvls2jaPab/BS7bRfU3IvVG6o3UG6k3Um+k3ki9kXoj9UbqjdQbqTdSb6TeSL2ReiP1RuqN1BupN1KvPeqlXq9eXNj+HJcL4LhSAMdnBHDcIIDjswI4bhfAcZcAjrsFcNwngOMBARwPCeB4RADHYwI4vieA40cCOH4mgOMXAjh+LYDjKQEcfxLA8bQAjn8I4Pi3AI6UXwPCxTFBAMf8AjgWFsCxuACOpQVwLC+AY2UBHPX7CezO8T4BHO8XwHG8AI4TBHCcKIDjJAEcHxDAcbIAjg8K4DhFAMepAjhOE8DxIQEcpwvg+LAAjjMEcHxEAMeZAjg+KoDjLAEcHxPAcbYAjnMEcJwrgOPjAjjOE8BxvgCOCwRwfEIAx4UCOC4SwPFJARwXC+C4RADHpQI4LhPAcbkAjk8J4LhCAMenBXBcKYDjKgEcVwvguEYAx2cEcFwrgOM6ARz1+9HtzvEzARyPC+B4QgDHzwVw/EIAxy8FcDwpgONXAjh+LYDjNwI4fiuA43cCOJ4SwPF7ARx/EMDxRwEcfxLA8WcBHH8RwPFXARxPC+B4RgDH3wRw/F0Axz8EcPxTAMe/BHA8K4Dj3wI46u+7szvHywRwjBbAMUYAx1gBHOMEcIwXwDFBAMc8AjjmFcAxnwCO+QVwLCCAY0EBHAsJ4FhYAMciAjgWFcBRfz+z3Tk+LYDjSgEcVwnguFoAxzUCOD4jgONaARzXCeC4XgDHDQI4bhTAcZMAjpsFcHxWAMctAjhuFcBxmwCO2wVw3CGA43MCOO4UwHGXAI7PC+D4ggCOLwrguFsAxz0COO4VwPElARz3CeD4sgCO+wVwfEUAxwMCOB4UwPFVARxfE8DxkACOrwvg+IYAjocFcDwigONRARzfFMDxLQEcjwng+LYAju8I4PiuAI7vCeD4vgCOHwjg+KEAjh8J4PixAI6fCOD4qQCOnwngeFwAxxMCOH4ugOMXAjh+KYDjSQEcvxLA8WsBHL8RwPFbARy/E8DxlACO3wvg+IMAjj8K4PiTAI4/C+D4iwCOvwrgeFoAxzMCOP4mgOPvAjj+IYDjnwI4/iWA41kBHP8WwDFKwPdfXyaAY7SE7xEXwDFWAMc4ARzjBXBMEMAxjwCOeQVwzCeAY34BHAsI4FhQAMdCAjgWFsCxiACORQVwLCaAY3EBHEsI4FhSAMdSAjiWFsCxjACOZQVwLCeAY3kBHCsI4FhRAMdKAjhWFsAxUQDHKgI4VhXAsZoAjpcL4HiFAI7VBXCsIYBjTQEcawngeKUAjlcJ4FhbAMc6AjheLYBjXQEcLQEclQCODgEcnQI4ugRwTBLAMVkAR7cAjh4BHO8tYH+O9wngeL8AjuMFcJwggONEARwnCeD4gACOkwVwfFAAxykCOE4VwHGaAI4PCeA4XQDHhwVwnCGA4yMCOM4UwPFRARxnCeD4mACOswVwnCOA41wBHB8XwHGeAI7zBXBcIIDjEwI4LhTAcZEAjk8K4LhYAMclAjguFcBxmQCOywVwfEoAxxUCOD4tgONKARxXCeC4WgDHNQI4PiOA41oBHNcJ4LheAMcNAjhuFMBxkwCOmwVwfFYAxy0COG4VwHGbAI7bBXDcIYDjcwI47hTAcZcAjs8L4PiCAI4vCuC4WwDHPQI47hXA8SUBHPcJ4PiyAI77BXB8RQDHAwI4HhTA8VUBHF8TwPGQAI6vC+D4hgCOhwVwPCKA41EBHN8UwPEtARyPCeD4tgCO7wjg+K4Aju8J4Pi+AI4fCOD4oQCOHwng+LEAjp8I4PipAI6fCeB4XADHEwI4fi6A4xcCOH4pgONJARy/EsDxawEcvxHA8VsBHL8TwPGUAI7fC+D4gwCOPwrg+JMAjj8L4PiLAI6/CuB4WgDHMwI4/iaA4+8COP4hgOOfAjj+JYDjWQEc/xbAMaqg/TleJoBjtACOMQI4xgrgGCeAY7wAjgkCOOYRwDGvAI75BHDML4BjAQEcCwrgWEgAx8ICOBYRwLGoAI7FBHAsLoBjCQEcSwrgWEoAx9ICOJYRwLGsAI7lBHAsL4BjBQEcKwrgWEkAx8oCOCYK4FhFAMeqAjhWE8DxcgEcrxDAsboAjjUEcKwpgGMtARyvFMDxKgEcawvgWEcAx6sFcKwrgKMlgKNi4MjBs1oeHp7/u6KzEXZayS5XhtuRoZwq1XKkpHmSLFdSWrJHeVSSJ8nr8DidGR6Xx52SluK2UpTLmaF8SSlOH/ojVI2vFcXTeOo2X0bY5ivD1GYrtEtdRei/vxNkxDmG0H+1o2S0OZawzXWE5PbVhP77MFrGQFM3SgZPSwhPJYSngzDXMU/qPukk5Fk9j4zYuKJk8EwSwjNZCE+3EJ4eITxThPC8RgjPa4XwrCeEZ30hPBsI4dlQCM9GQng2FsKziRCe1wnh2VQIz2ZCeF4vhGdzITxbCOHZUgjPVkJ4thbCs40Qnm2F8LxBCM92Qni2F8KzgxCeHYXwvJGJp533VTuFqc1WaJfqTOi/T4XsPXWJksGzqxCe3YTwvEkIz5uF8LxFCM/uQnj2EMLzViE8ewrh2UsIz1QhPNOE8EwXwtMrhGeGEJ4+ITx7C+HZRwjPvkJ43iaEZz8hPPsL4TlACM+BQngOEsJzsBCeQ4TwHCqE5zBintT8fk6IivolgX7Nc3gU3ZrnLwn29+GvDD4cQejDXwX48DSDD28n9OFpAT48w+DDOwh9eCZMnwuzQrvUnWR1OR0/J4TuvwyfvtJ9uM3U+TMySsaYOkoIz7uE8LxbCM/RQniOEcJzrBCe44TwvEcIz3uF8LxPCM/7hfAcL4TnBCE8JwrhOUkIzweE8JwshOeDQnhOEcJzqhCe04TwfEgIz+lCeD4shOcMITwfEcJzphCejwrhOUsIz8eE8JwthOccITznCuH5uBCe84TwnC+E5wIhPJ8QwnOhEJ6LhPB8UgjPxUJ4LhHCc6kQnsuE8FwuhOdTQniuEMLzaSE8VwrhuUoIz9VCeK4RwvMZITzXCuG5TgjP9UJ4bhDCc6MQnpuE8NwshOezQnhuEcJzqxCe24Tw3C6E5w4hPJ8TwnOnEJ67hPB8XgjPF4TwfFEIz91MPKOJee5BdYX6+ZhPhHw+Zi9hmz+LlpGPL0XJ4LlPCM+XhfDcL4TnK0J4HhDC86AQnq8K4fmaEJ6HhPB8XQjPN4TwPCyE5xEhPI8K4fmmEJ5vCeF5TAjPt4XwfEcIz3eF8HxPCM/3hfD8QAjPD4Xw/EgIz4+F8PxECM9PhfD8TAjP40J4nhDC83MhPL8QwvNLITxPCuH5lRCeXwvh+Y0Qnt8K4fmdEJ6nhPD8XgjPH4Tw/FEIz5+E8PxZCM9fhPD8VQjP00J4nhHC8zchPH8XwvMPITz/FMLzLyE8zwrh+bcQnrpCCTwvE8IzWgjPGCE8Y4XwjBPCM14IzwQhPPMI4ZlXCM98QnjmF8KzgBCeBYXwLCSEZ2EhPIsI4VlUCM9iQngWF8KzhBCeJYXwLCWEZ2khPMsI4VlWCM9yQniWF8KzghCeFYXwrCSEZ2UhPBOF8KwihGdVITyrCeF5uRCeVwjhWV0IzxpCeNYUwrOWEJ5XCuF5lRCetYXwrCOE59VCeNYVwtMSwlMJ4ekQwtMphKdLCM8kITyThfB0C+HpEcIzRQjPa4TwvFYIz3pCeNYXwrOBEJ4NhfBsJIRnYyE8mwjheZ0Qnk2F8GwmhOf1Qng2F8KzhRCeLYXwbCWEZ2shPNsI4dlWCM8bhPBsJ4RneyE8Owjh2VEIzxuF8OwkhGdnITy7COHZVQjPbkJ43iSE581CeN4ihGd3ITx7COF5qxCePYXw7CWEZ6oQnmlCeKYL4ekVwjNDCE+fEJ69hfDsI4RnXyE8bxPCs58Qnv2F8BwghOdAITwHCeE5WAjPIUJ4DhXCc5gQnsOF8BwhhOftQnjeIYTnnUJ4jhTCc5QQnncJ4Xm3EJ6jhfAcI4TnWCE8xwnheY8QnvcK4XmfEJ73C+E5XgjPCUJ4ThTCc5IQng8I4TlZCM8HhfCcIoTnVCE8pwnh+ZAQntOF8HxYCM8ZQng+IoTnTCE8HxXCc5YQno8J4TlbCM85QnjOFcLzcSE85wnhOV8IzwVCeD4hhOdCITwXCeH5pBCei4XwXCKE51IhPJcJ4blcCM+nhPBcIYTn00J4rhTCc5UQnquF8FwjhOczQniuFcJznRCe64Xw3CCE50YhPDcJ4blZCM9nhfDcIoTnViE8twnhuV0Izx1CeD4nhOdOITx3CeH5vBCeLwjh+aIQnruF8NwjhOdeITxfEsJznxCeLwvhuV8Iz1eE8DwghOdBITxfFcLzNSE8Dwnh+boQnm8I4XlYCM8jQngeFcLzTSE83xLC85gQnm8L4fmOEJ7vCuH5nhCe7wvh+YEQnh8K4fmREJ4fC+H5iRCenwrh+ZkQnseF8DwhhOfnQnh+IYTnl0J4nhTC8yshPL8WwvMbITy/FcLzOyE8Twnh+b0Qnj8I4fmjEJ4/CeH5sxCevwjh+asQnqeF8DwjhOdvQnj+LoTnH0J4/imE519CeJ4VwvNvITyjomXwvEwIz2ghPGOE8IwVwjNOCM94ITwThPDMI4RnXiE88wnhmV8IzwJCeBYUwrOQEJ6FhfAsIoRnUSE8iwnhWVwIzxJCeJYUwrOUEJ6lhfAsI4RnWSE8ywnhWV4IzwpCeFYUwrOSEJ6VhfBMFMKzihCeVYXwrCaE5+VCeF4hhGd1ITxrCOFZUwjPWkJ4XimE51VCeNYWwrOOEJ5XC+FZl4lnNDFPC/F0WskuV4bbkaGcKtVypKR5kixXUlqyR3lUkifJ6/A4nRkel8edkpbitlKUy5mhfEkpTp+/ssQ8MtqsCNvcqAhPm2OztRl4OkPgqRKLZGuzN/i6qhT5h/9UsHVVLUIXizdKhC0W53lawbW5mrnNVjB1XX4R/6X4Aq/rCsJYHA53LM7z9ATa5uqXarM7sLpqXNJ/Ll8gddUkjMWRfycW53m6ct/mWjm3OSm3dV2ZG/9ZuavrKsJYHP03Y3Gep5WbNtfObZvdOddVJ/f+S8+prqsJY/Hmvx+L8zzdl25z3cDa7LhUXVag/nNfvC5FGIu37BKL8zzdF2uzI5g2e8x1OYPzn8dUl4swFsfsFYtzPJN9/2xzUvBttrLXlRyK/xwX1uUmjMXbNoyFn6eF2+wJtc2urLpSQvefI7Ouawhj8Y59Y3GOZ8Z5ouraIhR1+XRtqh5RXVCbqk8Yi3dtHotMng3o1gcU4fOtws9nobbxvTDFwgrtUoTPQYpwHq/eJIzF+0JiQTjfU4TzFfU2YSw+EBILwnFNEeqyeo8wFh8KiYWDbt9AEWqBIsxlxRWLaOJYOAn3Caox7Y1Q71u5oonme16f91KxCdWfewnbnCRkTzFZCE+3EJ4eITxThPC8RgjPa4XwrCeEZ30hPBsI4dlQCM9GQng2FsKziRCe1wnh2VQIz2ZCeF4vhGdzITxbCOHZUgjPVkJ4thbCs40Qnm2F8LxBCM92Qni2F8KzgxCeHYXwvFEIz05CeHYWwrOLEJ5dhfDsJoTnTUJ43iyE5y1CeHYXwrOHEJ63CuHZUwjPXkJ4pgrhmSaEZ7oQnl4hPDOE8PQJ4dlbCM8+Qnj2FcLzNiE8+wnh2V8IzwFCeA4UwnOQEJ6DhfAcIoTnUCE8hwnhOVwIzxFCeN4uhOcdQnjeKYTnSCE8RwnheZcQnncL4TlaCM8xQniOFcJznBCe9wjhea8QnvcJ4Xm/EJ7jhfCcIITnRCE8Jwnh+YAQnpOF8HxQCM8pQnhOZeIZnY1nqJ9ZjSNs87QwtdkK7VIPRdP5LzqPjDgnEPpvupDczkPY5oeFtDkvYZtnCGlzPsI2PyKkzfkJ2zxTiG4/SqjbcUJ0uyCh/2YJifNjhHHOIyTOhQn9N1tInOcQxjm/kDgXJfTfXCFxfpwwzoWExLk4of/mCZmTlCBs83whbS5J2OYFQtpcirDNTwjRsIWEGlZUiIaVIfTfIiG5XZawzU8KaXM5wjYvFtLm8oRtXiKkzRUI27xUSJsrErZ5mZA2VyJs83Ih4/NThONzCSHfGbeCsM2lhbT5acI2lxPS5pWEba4oZO5ZjdB/q4To9uWEbV4tpM1XELZ5DWGb9XmAzPeo10Ltv8zvgxj//9f75/EAvb+q9xv1/pvej9L7MwUAev2+EECv7xYB6PW/YgC9PqTXS/T6gX6eLg3Qz1v6+UPPx/X8VM/X9PxFj+eVAYmAKoCqAN0/dL5o/1UH1ADURDwnRGdxvxJwFaA2oA7gakBd7SOAAjh0HAEuQBIgGeAGeAApgGsA1wLqAeoDGgAa+uPWGNAEcB2gKaAZ4HpAc0ALQEtAK0BrQBtAW8ANgHaA9oAOgI6AGwGdAJ0BXQBdAd0ANwFuBtwC6A7oAbgV0BPQC5AKSAOkA/TLvTMAPkBvQB9AX8BtgH6A/oABgIGAQYDBgCGAoYBhgOGAEYDbAXcA7gSMBIwC3AW4GzAaMAYwFjAOcA/gXsB9gPsB47XvARMBkwAPACYDHgRMAUwFTAM8BJgOeBgwA/AIYCbgUcAswGOA2YA5gLmAxwHzAPMBCwBPABYCFgGeBCwGLAEsBSwDLAc8BVgBeBqwErAKsBqwBvAMYC1gHWA9YANgI2ATYDPgWcAWwFbANsB2wA7Ac4CdgF2A5wEvAF4E7AbsAeh3oL8E2Ad4GbAf8ArgAOAg4FXAa4BDgNcBbwAOA44AjgLeBLwFOAZ4G/AO4F3Ae4D3AR8APgR8BPgY8AngU8BngOOAE4DPAV8AvgScBHwF+BrwDeBbwHeAU4DvAT8AfgT8BPgZ8AvgV8BpwBnAb4DfAX8A/gT8BTgL+BugxeAyQDQgBhALiAPEAxIAeQB5AfkA+QEFAAUBhQCFAUUARQHFAMUBJQAlAaUApQFlAGUB5QDlARUAFQGVAJUBiYAqgKqAaoDLAVcAqgNqAGoCagGuBFwFqA2oA7gaUBegRU4BHAAnwAVIAiQD3AAPIAVwDeBaQD1AfUADQENAI0BjQBPAdYCmgGaA6wHNAS0ALQGtAK0BbQBtATcA2gHaAzoAOgJuBHQCdAZ0AXQFdAPcBLgZcAugO6AH4FZAT0AvQCogDZAO8AIyAD5Ab0AfQF/AbYB+gP6AAYCBgEGAwYAhgKGAYYDhgBGA2wF3AO4EjASMAtwFuBswGjAGMBYwDnAP4F7AfYD7AeMBEwATAZMADwAmAx4ETAFMBUwDPASYDngYMAPwCGAm4FHALMBjgNmAOYC5gMcB8wDzAQsATwAWAhYBngQsBiwBLAUsAywHPAVYAXgasBKwCrAasAbwDGAtYB1gPWADYCNgE2Az4FnAFsBWwDbAdsAOwHOAnYBdgOcBLwBeBOwG7AHsBbwE2Ad4GbAf8ArgAOAg4FXAa4BDgNcBbwAOA44AjgLeBLwFOAZ4G/AO4F3Ae4D3AR8APgR8BPgY8AngU8BngOOAE4DPAV8AvgScBHwF+BrwDeBbwHeAU4DvAT8AfgT8BPgZ8AvgV8BpwBnAb4DfAX8A/gT8BTgL+BugJwKXAaIBMYBYQBwgHpAAyAPIC8gHyA8oACgIKAQoDCgCKAooBigOKAEoCSgFKA0oAygLKAcoD6gAqAioBKgMSARUAVQFVANcDrgCUB1QA1ATUAtwJeAqQG1AHYD+vnr9XfD6e9b1947r73fR3yuiv2dDf++E/k4H/X0J+rsI9Hv+9Tv09fvp9bvf9XvV9TvLz70PHKDfY63fEa3fv6zfbazfG6zfyavfd6vfJavf06rfgarfL6rf3anfi6nfOanf56jflajfQ6jf8affn6ffTaff+6bfqabfV6bfBabfs6XfYaXfD6XfvaTfa6TfGaTfx9MLoN8jo9/Rot9/ot8tot/bod+Jod83od/loN+ToN9BoD/frz87rz+Xrj/zrT9PrT+rrD8HrD9jqz+/qj8bqj93qT/TqD8vqD+Lpz/npj9Dpj+fpT/7pD9XpD+zoz8PMw6gP8ehPyOhP3+gz/brc/N67qXPe+uz1Pqcsj4DrM/X6rOr+lyoPiepzyDqc3T6XJk+Z6XPHelzOPqMiz6noc9A6H18vUeu93n1HqreB9T7YnqfSO+b6D0Jva6u15n1uqteh9TrcnqdSq/b6DURvUagn5n1M6R+DtLPBXqenEdPXP1XpSzz3JxTX6nDh2cMGDw8cfigxFSvN/GOvsP7JA66PWOor/8gPTWKSgzinhronnr+nzcOHzQ0tXdG4rD+g4YnWokD4b+p/eHfZ3ivTsT/b1jigBHDhicOG546dHiib+igAYlKT2PPzVsD5dEU3VPe/zMd/uq5G4YNyxg6vOeA1Dt7pvUd3nNY31F6RnluShvgLe0Cv6VD4Ld0CvyWLoHf0jPwW1IDv6V34Lf0DfyWAYHfMijwW+4M/JZRgd8yOvBbxgZ+y6TAb5kc+C3TA79lRuC3zAv8lgWB37I88FtWBH7LqsBvWRP4Lc8GfsvWwG/ZFfgtLwR+y97Ab9kX+C2vB37L4cBveTPwW44FfsvHgd/yaeC3fBn4LV8Ffsuv6Jba/p/tR6T175ue6E0dnpo4fGhGRmLfgd6MOxO9gzKGDawxPHFA6vD0PnoGMTBjmF4iOrcuEGodZwjq0M8OmdcVmXUMHXR734G9Ewefr+v21P4jdD3p/UcM6ztoYKIvtW//jHNfgLcR3Xy5/2fLgfDv+3ozb+6XMXJYYp++A2GyNWionkYN9f/hTSHcuzmEe7ehe3M70TuI7slljrwW+C3HAr/lncBveT/wWz4M/JYvAr/lZOC3nAr8lh8Cv+WXwG85Hfgt53YCArslOvBb4gK/JSHwW4oEfkuxwG8pE/gt5QK/5fLAb6ke+C11A79FBX6LK/BbkgO/pWHgtzQO/Jbmgd/SMvBb2gZ+S7vAb+kW+C03B35Lj8Bv6Rn4LX0Cv+W2wG8ZHPgtQwO/ZQy6JdgJ1liCOsYR1DErNquOgCd67rismwOdcHlCuDclhHvro3tzO9FLC+KekeieKv+8Z8CI/sP7Du4/8p833hXsjaODYDk22D92T7A33hcEy/HB/rGJwd74QBAsHwz2j00N9saHgmD5cLB/7JFgb3w0CJaPBfvH5gR74+NBsJwf7B97ItgbFwXBcnGwf2xpsDcuD4LlimD/2Mpgb1wdBMtngv1j64K9cUMQLDcF+8eeDfbGrUGw3B7sH3su2Bt3BcHyhWD/2O5gb9wbBMt9wf6x/cHeeCAIlifRPZkT1utSB+pdWZho94X526iMxMGD9KwtdTjMOH19B/YdPhKm4YlpI4dnDDu3I1stPquOXM7Xrwj8lhqB31Ir8FvqBH5L3cBv8QR+yzWB39Iw8FsaB35Ls8BvaR74Le0Dv6Vj4Ld0CvyWLoHf0i3wW24O/Jaegd+SGvgtGeiWXM8r0D0BCdyqYG9cEwTLdcH+sQ3B3rgpCJZbgv1j24K9cUcQLHcF+8deCPbG3UGwfCnYP/ZysDe+EgTLV4P9Y4eCvfGNIFgeDfaPvRXsjW8HwfK9YP/YB8He+FEQLD8N9o8dD/bGz4NgeTLYP/Z1sDd+GwTL74P9Yz8Ge+PPQbA8Hewf+y3YG/8IguXZYP/Yuc9OBXNjdELgLOOC/WMJwd6YNwiWBYL9Y4WCvbFIECyLB/vHSgZ7Y+kgWJYL9o9VCPbGSkGwrBLsH6sW7I1XBMGyZrB/7Mpgb6wdBMu6wf4xFeyNziBYJgf7xzzB3nhNECzrB/vHGgZ7Y+MgWDYN9o9dH+yNLYJg2TrYP9Y22BvbBcGyY7B/rFOwN3YJguVNwf6xW4K9sUcQLHsF+8fSgr3RGwTL3sH+sb7B3tgvCJYDg/1jg4O9cWgQLEcE+8fuCPbGkUGwvDvYPzYm2BvHBcHyvmD/2Phgb5wYBMuX0D3B7pmce3WE/8rtIdLAb4kN/Jb4wG/JF/gtBQK/pWTgt5QO/JYKgd9SKfBbqgZ+y+WB31In8FvqBn6LCvwWZ+C3JAV+izvwW+oFfkuDwG9pgm7Jrebchu4JSOAGBHvjoCBYDg32jw0P9sbbg2A5Mtg/dlewN44OguW4YP/YvcHeeH8QLCcG+8ceCPbGB4NgOS3YPzY92BtnBMHy0WD/2GPB3jgnCJbzgv1jC4K9cWEQLBcH+8eWBnvj8iBYPh3sH1sV7I1rgmC5Ltg/tiHYGzcFwXJLsH9sW7A37giC5a7/a+9KwKuqru5LCJkICSSCgCjgDDgkIYRgHMIgyCBFREGjaCYQQdAQHKnWoVZFaq2otVqcrbVSa21tS2tbbevQSrXV2ha1tmIdcMZZUX9fsjbsHNZLsvfNld8P3/fley9rnXX2Pvvuc++599x7rtfYvV7h7x1e3u819qBX+CeHl6u9xh7xCv/q8PJxr7EnvMJ/Orx80mvsaa/wGYeXz3qNPecVPu/w8iWvsZe9wlcdXr7hNbbeK3zb4eV7XmMfeIUfObz8xGusefVQjzA9x+5lV6+xLK8wx+FlntdYvlfYw+FlkddYL69wW4eX/bzG+nuFOzi8HOQ1tpNXuIvDy929xoZ4hXs4vNzba6zEKxzm8LLca6zCK9zH4eV+XmMHeIWjHF6O9Rob5xUe5PCyb+4mjXfO5FBVRwcvtR5ml8ywS46wS462S46xS46zS463SxbaJSfZJYvtklPskq/ZJefYJefZJefbJRfYJRfZJZfYJZfaJZcrSUf3OfcojWkH9zuv8D6Hl3/0GnvAK3zI4eXDXmN/8QofdXj5mNfY373Cfzi8XOM19pRX+G+Hl//1GlvrFf7P4eWLXmPrvMJXHF6+7jX2plf4lsPLd73G3vcKP3R4+bHX2KdeYVo3u5cZ3ZzGMr3CbIeX3bzGunuFBQ4vC73GtvEKezu87Os1tp1XuL3Dy4FeYzt6hTs7vNzNa2ywVzjU4eVeXmPFXmGpw8vhXmMjvMKRDi/39Rrb3yuscng5xmvsQK9wvMPLiV5jk73CKQ4vD/EaO9QrPMzh5UyvsSO9wqMcXh7jNVbjFdY5vJztNXacV3i8w8sTvMYWeoUnObxs8ho72Ss81eHlGV5jX/UKz3J4eY7X2Hle4fkOLy/0GlvqFS5zePktr7Fve4XLHV5e6TV2lVd4tcPLa5Wmg5dJr7NLbrZLvm+XVOZtknjnfxbnmc2eYpecZpecYZecZZecbZdcZJdcbJdcapdcZpdcaZdcZZfcYJfcZJfcYpfcapfcZpfcbpfcaZfcZZf8XEk6uv98RmlMO+tnvcLnHF6+4DX2klf4ssPL17zG3vAK1zu8fMdr7D2v8AOHlxu8xj7xCptfSm70skt3p7GuXmGWw8tcr7E8rzDf4WVPr7Eir7CXw8s+XmP9vML+Di8HeI0N8gp3cni5q9fY7l7hEIeXe3qN7e0Vlji8LPMaK/cKKxxeVnqN7ecVHuDwcrTX2FivcJzDywleY5O8woMdXk71GpvmFU53eDnDa+wIr7Da4eUsr7FjvcJah5cNXmNzvMK5Di/ne40t8ApPdHi5yGtssVd4isPL073GlniFZzq8PNtr7Fyv8OsOLy/wGrvIK7zY4eUlXmOXeoWXOby8wmvsO17hdx1efs9r7Fqv8HqHlzd5jd3iFd7q8PKHXmMrvcI7HF7+xGvsp17h3Q4vf+k19iuv8B6Hl+8ojXfOZO/8TXV0dEEnu2SYXTLcLhlpl1TaJWPtknF2ySS75GC75BC75FC75Ci7ZJZdcqxdUmuX1Nsls+2SeXbJCXbJSUrS0X3OVUpj2sFd4xWucHh5vdfYjV7hzQ4vb/Uau80rvN3h5R1eY3d6hXc5vLzba+wXXuEqh5f3eI391iu81+HlH7zG7vcKH3R4+WevsdVe4SMOL//mNfa4V/iEw8t/eY096RU+7fDyP15jz3qFzzm8fMFr7CWv8GWHl695jb3hFa53ePmO19h7XuEHDi83eI194hUmCuxedilwGuvqFWY5vMz1GsvzCvMdXvb0GivyCns5vOzjNdbPK+zv8HKA19ggr3Anh5e7eo3t7hUOcXi5p9fY3l5hicPLMq+xcq+wwuFlpdfYfl7hAQ4vR3uNjfUKxzm8nOA1NskrPNjh5VSvsWle4XSHlzO8xo7wCqsdXs7yGjvWK6x1eNngNTbHK5zr8HK+19gCr/BEh5eLvMYWe4WnOLw83ahJ+4wfiXI7b5Im+uJ7VGNjzWmfza3UN5w6cOHipoELZw+sXbh4Qf0iLRzqFZZ6hSO9wjFe4ZkJf2DP8Rq9wCu83OHtASg3TGlJvi5aXNvUWFPXlLqCClVBEb4ncH9FUmltqAhH2W2N9do6PGEPqvhX3HE/RTLM6qcIqyL4Odbu53ivnzMcfk5CueFKa0pSqWCfjjdUJPtZGyrCMXZb47y2ZibsQZ2GcoYkFYk5SUVYFcFPQ5KKxJykIvQkaTXKuZNUKjAkqUjMSSpCQ5KKxJykIvQkaW3UoNbag1rrDWqtPai13qDWRgjq8Shn6PkiMfd8EVZF8NPQ80Vi7vki9PT8JpRzJ6lUYEhSkZiTVISGJBWJOUlF6EnSM1DOkKQiMSepCKsi+GlIUpGYk1SEniQ9D+XcSSoVGJJUJOYkFaEhSUViTlIRepJ0adSgLrUHdak3qEvtQV3qDerSCEG9EuXcp6RSgeGUVCTmU1IRjrLbMp+SitBzSnoVyhl2pyIx705FWBXBT8PuVCTm3akIPbvTG1HO3fOlAkPPF4m554vQ0PNFYu75IvT0/NtQzpCkIjEnqQirIvhpSFKRmJNUhJ4kvQvl3EkqFRiSVCTmJBWhIUlFYk5SEXqSdFXUoK6yB3WVN6ir7EFd5Q3qqghBvQ/lDD1fJOaeL8KqCH4aer5IzD1fhJ6e/zDKuZNUKjAkqUjMSSpCQ5KKxJykIvQk6WMoZ0hSkZiTVIRVEfw0JKlIzEkqQk+SPoVy7iSVCgxJKhJzkorQkKQiMSepCD1JujZqUNfag7rWG9S19qCu9QZ1bYSg9kpvKfes1agIX/IK3/AKP/QK09KcwmyvsNAr7OsVDvQKh3iFJV5hhVc4yyus9wpPUsKO9qx7oTXfhiLCoV5hqVc40isc4xV6bkMRrfk2FBFe4BV6bkN5AFr3NT+pwHDNTyTma34iHGW3Zb7mJ0LPNb+HoDWMVx8i26FDfoqwKoKfhvGqSMzjVRF6xquPQeseWkkFhqGVSMxDq8fITqeDtsxDKxF6hlZr7Em6xpukayIk6Rp7kq7xJumaCEm6NmqSrrUn6Vpvkq61J+lab5KujZCk66IGdZ09qOu8QV1nD+o6b1DXRQjqenvPX+/t+esj9Pz19p6/3tvz10fo+RuiJukGe5Ju8CbpBnuSbvAm6YYISdqlS0s5Q5KKxJykIqyK4KchSUViTlIRepI0D1p3kkoFhiQViTlJRWhIUpGYk1SEniQtihrUIntQi7xBLbIHtcgb1KIIQR1AurEpqFKB4ZRUJOZTUhGOstsyn5KK0HNKOsi+Ox3k3Z0OirA7HWTfnQ7y7k4HRdidDo3a84fae/5Qb88fau/5Q709f2iEnl9qT9JSb5KWRkjSUnuSlnqTtDRCklZGTdJKe5JWepO00p6kld4krYyQpKOjBnW0PaijvUEdbQ/qaG9QR0cI6kR7z5/o7fkTI/T8ifaeP9Hb8ydG6PnToybpdHuSTvcm6XR7kk73Jun0CElabU/Sam+SVkdI0mp7klZ7k7Q6QpLWR03SenuS1nuTtN6epPXeJK2PkKTzogZ1nj2o87xBnWcP6jxvUOdFCOrVGS3lnrUaFeFLXuEbXuGHXqH5NhQRZnuFhV5hX69woFc4xCss8QorvMJZXmG9V+i5DWVc15ZyhmOqSMzHVBFWJfx+Go6pIjEfU0XoOaY2QtvLalSE/b3CnbzCPa3C1facWe3NmdURcma1PWdWe3NmdYScGZi5eXAGba5NPWSQCgwXXEVivuAqwlF2W+YLriL0XHAdAq0hSYeQ7dAhP0VYFcFPQ5KKxJykIvQkaRm07nGtVGAY14rEPK4VoWFcKxLzuFaEnnFtZdSgVtqDWukNaqU9qJXeoFZGCOpoe88f7e35oyP0/NH2nj/a2/NHR+j5k6Mm6WR7kk72Julke5JO9ibp5AhJWh01qNX2oFZ7g1ptD2q1N6jVEYL6cVZLOfdASiowDKREYh5IiXCU3ZZ5ICVCz0AqK7ulnGF3KhLz7lSEVRH8NOxORWLenYrQszvtCa2750sFhp4vEnPPF6Gh54vE3PNF6On5faIGtY89qH28Qe1jD2ofb1D7RAjqAHvPH+Dt+QMi9PwB9p4/wNvzB0To+YOjJulge5IO9ibpYHuSDvYm6eAISVoRNagV9qBWeINaYQ9qhTeoFRGCOjW3pZx7ICUVGAZSIjEPpEQ4ym7LPJASoWcgdSS0ht3pkWQ7dMhPEVZF8NOwOxWJeXcqQtf0NbT+6WtUYJm+hsQ+fQ2hZfoaEvv0NYSu6euoQZ1nD+o8b1Dn2YM6zxvUeRGC2mjv+Y3ent8Yoec32nt+o7fnN0bo+UuiJukSe5Iu8SbpEnuSLvEm6ZIISbo0alCX2oO61BvUpfagLvUGdWmEoK7o1lLO0PNFYu75IqyK4Keh54vE3PNF6On5N0DrTlKpwJCkIjEnqQgNSSoSc5KK0HV4ymsp5x7tSwWG0b5IzKN9EY6y2zKP9kXoGe0vgdbQ85eQ7dCx3T6EVRH8NPR8kZh7vgg9Pf98aN09Xyow9HyRmHu+CA09XyTmni9CT89fFjWoy+xBXeYN6jJ7UJd5g7osQlCX23v+cm/PXx6h5y+39/zl3p6/PELPXxE1SVfYk3SFN0lX2JN0hTdJV0RI0pVRg7rSHtSV3qCutAd1pTeoKyMEdQ+8Adw9kJIKDAMpkZgHUiIcZbdlHkiJ0DOQKofWsDstJ9uhQ36KsCqCn4bdqUjMu1MRenanVdC6e75UYOj5IjH3fBEaer5IzD1fhJ6ePz5qUMfbgzreG9Tx9qCO9wZ1fISgTrH3/Cnenj8lQs+fYu/5U7w9f0qEnj8zapLOtCfpTG+SzrQn6Uxvks6MkKRzogZ1jj2oc7xBnWMP6hxvUOd4g9odhQ7Gd3IeGwtZJZIVJ592qsL/xdE+JdnKuU6tu6K8PHkj4xgY0A/nJNAe4eQ7DXjyb6zc0kK4A4EdSLhxcrcA4cbLPS+EOwjYQYSbAGwC4SYCm0i4ScAmEW4ysMmEOxjYwYSbAmwK4b4C7CuEmwpsKuEOAXYI4aYBm0a4Q4EdSrjpwKYT7jBghxHucGCHE26G3HpEuJlyswfhjgB2BOGOBHYk4aqBVRPuKGBHEe5oYEcTbhawWYQ7BtgxhDsW2LGEqwFWQ7haYLWEqwNWR7h6YPUBl/wXzzF38v6ibFg26uv0urGf6xqL3+XDk3VnxuR38mQc9y5vjHue+p2lMPndVWFdg3LJ773xu/Czv9n6ACB1Z7euJ9mmrsAy8CftleNS87bLjicGSZ/3Uf6Jy5nZm2znJuKxnbSXg7oylL2smOzFmUvdVOzqG2oXz5m8cE4i+Oi+Lb93VLze7lJXDtGmKY3sO3YMsAzgumzykwtOcm5f4Ml83B+/k9tFtr/O18mE1zb1J0P/Vts2O548Lk7Wl6N8zVC2tP1cZT+t8+yXaPtSt9jKUf1bfk9SccvNbh03ibn4nxzrykMB2v9QlxnoClSZLKXLDnTyv+xvkvEbpX7Ldk/mzh34/cUcN48o1ePm9ETrT6pxc9K+Pi4Il5fYlOcylk7uu/olNvEyjtbHl3EqHwQbHxwXkpiMlzMVNkHZSX5i2z9XlDUPebrFUXdxafP9w91jqbtlX4Dzw437ArHVTcWtQNnv7H1BflC32BI8Q/3uq8pKOSkjfaG70mMSoZX/oS430BWoMnlK1z3Qyf96XyC65JhG8lnWdYhvfFBa33ycSbT+tHWcyVU+xTWGSOZPH9Q1p6Fp6uLa+XPrxtY01UxvbGiYMbdpQcOiRWnKtvi/Z+B/GmmLlNH7pS6krelBPDKC/7MCTVagi+0847NPnPmQrE/6r/RraUeuaq+U2QXfPRObf3RdopNtJXXmJzbFVu834hoPJ+vOizF23YPYSTvyVAykzB7txK57itjlqthJzLqr2MXTvuLS7ETrfW5nx64giF2eaqfEQMoMayd2BSlip+vU+22JXTztK26+NtAjxtj1DGIn7eihYiBl9mkndj1TxC5ffRcEdaQrWwVBO9NVuR6q7nRSj2jii1dxWbLuwljqbtkWckFetoW0o1DFVMqMDdqvP7ou0WUGccxXWikbX/uKS/MCn8RGIvAzEbQ56VOvWHwqrchTdjriUy/l0zax+NRynNFLiHVSvc3H/t4xxTFN1S0x6x1sx2Sstw2wpE7Ga5LzUqa3irUeg3f2uUCfoG6x1Ue1RX7LhFaB8lPnpmCJoC16vH6IqqOIxEjaXaTqTRXbdFWXYNuouuR8tYuyPwu/YzyuNOdDobKZoXzRxxUpc7IqW4vf+YovUm3KJ/ERTOrND+KTn2i93xNdj0DXI9DpfVYG8aGbwmR80F1hMt7qqTDZPvp8T3KI5UEPhcl21PHICNqlt3ue+g7HgPq6uc4ZOaftpTC5ztlb1RH39olxPDqc+RTGrPkaHn5nBmX0uFLKnIVvdjxOtiUnlra0jBtkm4VjuI3X71WZc9vwU9clOjaG0+fyMbevQl+PD/clun1S5sI22qfnePQxKJzjCfcD8c3xlFYk++A1yj+Js57jyY4lti3Hv/Aahr42l/wUJDY/j49xnFjC9svii7aZqm/q44uUuQLfLCf0cVjvQ0VbRGyG9evjcNg38ohv+jis53tWKP46pWfzPT8ifEL5mgh83fj7y/mejTGR3ytV3P4/zvfcqH7Ldk/m2RH4/cWc7ykrb2u+xzKno/taOKejr4unqXjFM9dcWhzf/rql7niOs63vt0gkWsdLPno/Im1M7tN6qXgnRVLPQF1RTlCR/B//he+WwHWLse6YBqol+kCkY5lqo3QLNkqGEuWyjZIXVJRHNkpMM4Elujdrn1I1rnsKnzrxyFFcoGxqewUxxiA/0fEYFKjv/M/Pz2I9itFX23eM3XZpMZsdCX3RsyNDVNld8TsZqy6qbPKj84/dYSacnO3qWV5ps76C0tkjmHAGXGx1V/5Jmb1Vm6cp/+LZJiWz9TZJC3zRd8+Jz+EoXW83KVOG71Rnpnr0rLd3pmqvPkPo7O3RU/ms/dFX56XMyHba0jNFW7JJXft2sC7RydFX52uPoI62fNAHYX31S2vYjMTowEboZ1EKe91IXQd2sC7RhXdUsNkNnbMyuxTGJbyy39k5VBTUvU3gt47BZHzrq8bhbCdrgz6G6RnKuO6o0ceiAuLz57NPaolvOPMd7m/a2ifpbSBlZgSx1Z88otXHxCNVm7/oZ2dppO3h2Vl4JjaW3F13oDr7Tn4KVTk95ozljnUM1rNirDuuK3XWu62kjezsTOoZqCsKL/vK/3qjxHnqqS9Dio1UjcshPiUSnXsS0IXYiucM0n+Wpy83aj/jPBvtZvAzj/iUSHTugacbsRXXrav6hEHv8AfGHvuSlkuqymZGovWJjMReygxVZXfG7/zE5o8s6BMjPTUY5pWeGmQnS1qboeIhHLOtL0CEbeqq6ghv163C/8XRPiXhgFD7o6f4pEwJvtu77S5sSxapq72TnVS38Onp3nDKOT3Revo5Qcrq/lvQjk77kBNo9D5SD7rlt54Giee40dInwtv1MgJ/9TbNDMrok1ApMwrfqbZLmK9tnfS2lVNSpr0TnR4p7GWRug7qYF2ik5zSt7+Lr3oKNLw1PSyrc6o9nd5e3QONPp5pnwoCO/rCS/JThe/iKJ+S4mLtk/Zf+8dum/08T2jC3G0rv/W+TcrILUypTmjaOr7VqDZ/Od3U8emm5CdTxTO8wKj7YrUqp/M9npOWkuI4989x3o6vxyMJZUN/2DkDOyHSU1kbK2pvrj++6aqS4jgHknHP6HhOENh0lZ7K2lhRew9EhaPFLTldlZ/Cp04cwbaarko1LdHZMShIdDwG+shZ8Pn5Wawvl+gR1C6x2y6hDziGvmSoMnuosoNVjNh0VVs39OYnNr8Mm2ynvuTf2WdP4fRXT+WL+C5lSpTP05V/MeXAbL0d0gJf9M0fPRWWaltJmXJ8d3RaR+zrB4LDKYCqzmlv8/bQ0zLaHz2NI2Uq22lLYYq25JC69u9gXaKTI66+qTScWmrLB33g3UbVqzW6zVJmbDt+bpPCXh6pa3wH6xKdHNB0m8VXPeWk+45+ACrVAzGdnUPh9FevwG8dgyn4TsbrUKXT+1zWBn3c6qHaFdd0uj7+9CA+f077pFYPn0ssw/1NW/skvQ2kjNwEmOqMLtSGx8EMZbczY66PV/qq3izlW3i1L9XtF1embfL3i3fmObykvYUt2KJvGQnbWal+iCPuhS2S2ER1I69gsuCbvmosC73pK8SywJu+ej9FtU++ZUE3fXVyqroRN/nRZ9z6ipTYm9PQNOa4mrkLJtTrkaoeAbT1CWo6vKFx0dyFC7Qqq4M1xXg2XGo9G47/6mzrWS3xLSfR+sS6s2x15IRdX13sovyKaZvEeV9oaQ/4rfue3q76ylH3zo93sY6hvlKV6qpoZ57zhmOkNOWLPu+J5wGVYXXJWOurz2JDf3Rf0+O2nrH41NLXxI74lhPEIL3T7A0fxsb08n967PZHlG1Z++Wzt3D7S7dw+0u2sP0RW9j+8C1rv+WW6C2Yf1u4/5fXbeX9v2zrzr9hxVt3+8sbvsz/rXr7b+nj75be/27t+/+tfPxTvqX7f8PWvf/58vzvy/O/L8//vjz/22Lx//L8L7E1b/8tPv6u38LxH751b/+t/fxva4//lh5/bOnx11Z//aN8Kx9/z966j39b/PrzFt7/lDboexN/jO/w3tJOnPOuzwvaKzYSQQzkoxeEDRc5zgn87NppfrbcGxAuDVIUbJdwiY/OvjdAFgzUC/fKooc6LrLoo/iSvI/o1LT4fWwrRmKzp9pe+6n4hffmia/6nsaqDvpZMry8oaZ2dkVZw7CGmuHF9WXFDcOGDSsuLS2bXVpf2lCRHfjZ4XrLyypmz55dMbtk9oiGupLauvL60ooRw+rqasobRg4fWa/vDbHUG5oJgUSi9cLG+v40+bTHs7I6fzNIuU5qT/hpjlM8C8YX1+v9QkLZ0B+dY3ox+Lie70newyT3MS1qWthYM6dhWkPNxpsGdbfpHricltjcff3wJWuSfk5KL35RSMq29UnabW997fieVWu59dDyzJe+9W7beHyqsy4osq3yKaaUL4mzvWmJ1O8e0LcA9wmwpE7edyCPPPQhMemnyqd1Yky0falbbPVVbZHfj+K7QPmp+6JgiaAt6aqND6k6upEYSbv1Yi/tvddBvw+it6pLbqvOVfafwO8YbwdsdXk0XDFRr2InZWakbSq7Bphe513fpp1N4pMdxCdcPEgv/pGtvmNaLSnGVZ5aYpsZxFbaoRdlkDJr8Z3qMaHMIHbhLdP6XV16pcM438Mbz+pbLbHLCGIXvrs5Q5VZ107sMlLELkvFLlw4Jcb2lcZ4nG2OXbj4SPg4aIYq82Y7sctLETv9jgv9qEjyw04BZL+drsrpY286qUc0McZrWIzPudfpMVf4rkM97pMyH+E71bYIx2/hYwp6sRX9+HRM7SuLcVGT5tilWsmVrQqbntZ27HqkiJ1elCh8p12M7Rv+eR/Xw/fg6eN6TjuxK0wRO/2ofrjKbXpi83fy6X1AYeCPaMJ69D4gpniVx3dJrGVbhI8Ls8etpUxRO9sifFw4fHcUe1w4xvaNCB8z7uzY9Q5iJ+3opWIgZfq1E7veKWKn3+siMdOXEmJqX0Xc53rhO/OkHduqGEiZQe3Erk+K2OnHviVm+nwqPN/R+4DwHFI0YT16HxBTvEYm6+4bT911+nw1fH+hPn+VMkPb2Rb91P96W0id+Sp2UjbG9jW/Y367GGPXP4idtGM7FQMpU9pO7PqniF1fFTuJWX8Vu5jaV5use/sYY7dDEDtpx/YqBlJmZDux2yFF7LZTsZOYSdl0Va6/qkv2AXK+rx/LTVdlcwJNnqpbX2+Q9ujH0QcoXwUbqH7L9yDlv2A74reentkJvwsVtjN+68fqZdkEfY1H3jDRR2G74Xc/he2O3/0VJuP7HRQmbdpeYXJONkBh4SrO+v09gxQm1xF2VJjEfieFyXbaWWHhu9rzEpviu6vCZKy9m8Ik5tLu8J2Rehv3CDA2rg/fyaeXjPkcxvX0He1tvYXkmHb6XLiUmX47grQvfONHjI+UN+9TclO0Ty9/I2Ua2mifngbV4/3wPYv6HeDSvnjes1hcl+wb56Vt8m/j20PUMhZxLuQZLk+gcymRaL08gc7nuB4ZZ30svEaszxHbes+ilGlsIyfY4qn6toJuxGZYv77eXqh+S13sPYv6entWPLnVfNtBtlpKJUPZ6qryK3wnYSfZL9H2pW6xla36nPw+N21T2Zzs1rGWfpulllmRPqL9D3UZga5AlclUuqxAlxUsi5OM32nwLxdlJIbnq3mKC1RfZu/HvILw8klr/e/GY25CtaN5fiLGfPkivR/zcpUv/x/fj7lU5cUVKndkDJWtyscxX5KIo+5g2agwZ9nSUMljXJFqcyzzHBVlzdeH43l/ZsttJ3HNCzbnfWJTrui5Oz23ppcE6vR+F9QdvmghQ/3WY6dw/KDvo0h+mvsdfue2oesa6PS4Q88ptjen21VhST9lKTI9Vo1pO9Zbl+LVc84xzf013z4k53FzGpqmLq6dP7duUsNpi0YtqJ9a09g0t2b+qPr6xoZFi9ICD3TUNBe2KCyT/HQhWPKjz/z0WbLOfsHCTNLR1Wfxemb6i7c3LSvTe9Pwk8x8fYVByull3cM9cXKLy1nuZ1t8Ws2C+oUnjJvbML++I1so/Oiot/c2Sr2P/wJuiVq9JcJ3DifbI8sNTgjGX+yYx5ZDjPHYNzzGY1+rdzAfpNon22KCwlhPlt/CJevS50cTSVZPJFkt528LFjbNnX3amMaGmqaG+ikLmxp0EusDmf50Vb/1jQD6hoGuhNeJkE3q0h+2e+ySopwkjtSv16bsEthOdq6RyocvYOca2VlvudAX6DpzPdHCxOavAWw+OY4jHsXFZbpjJJQN/dGDBX2jWlwdPRlbmdT57NDx2TDh8Jr5c+trmuYuXDCt4aTFDYua9EggXEa3rVGClNGbvks7vP6kJTa/Jy0z0GQnYrtvJ8533Jexa5zhi/70NU65zp/qGm6qsbW+b0cftyV2cS25mqw7ppcUlskcjY6dtEO/wVfKbN9O7PJSxC5HxU4vGSyxi6l9zffuxXU/VVpi8/vFwmuhGarMzu3ELj9F7PQS8+H9YumJzV/ypufrwrfJiyasRzQxxmtYjNfiy/R1747cf7YXvjt6/1n4RmB2/5me89KHT7Gv876n+i3fhapuwboQGxlBu/ShUNerD81ivwA7+y/kMKimbHirYVBwsEtX3JjgHCPJseXY0/EnQ5cDCSdDonGEk6HReMLJEOkgwrFzIeFk7D6RcLIU+yTCyZLskwknS7MfTDhZon0K4WSp9q8QTpZsn0q4Q4AdQrhpwKYR7lBghxJuOrDphDsM2GGEOxzY4YSbAWwG4WYCm0m4I4AdQbgjgR1JuGpg1YQ7CthRhDsa2NGEmwVsFuGOAXYM4Y4FdizhaoDVEK4WWC3h6oDVEa4eWD3hGoA1EG42sNmEmwNsDuGOA3Yc4eYCm0u444EdT7h5wOYRbj6w+YQ7AdgJhFsAbAHhFgJbSLgTgZ1IuJOAnUS4RmCNhFsEbBHhmoA1EW4xsMWEOxnYyYQ7BdgphDsV2KmEOw3YaYQ7HdjphDsD2BmEWwJsCeG+CuyrhDsT2JmEOwvYWYT7GrCvEe5sYGcT7hxg5xDuXGDnEu48YOcR7uvAvk6484GdT7hvAPsG4S4AdgHhLgR2IeEuAnYR4ZYCW0q4i4FdTLhlwJYR7pvAvkm4S4BdQrhvAfsW4S4Fdinhvg3s24S7DNhlhFsObDnhLgd2OeGuAHYF4a4EdiXhvgPsO4S7CthVhPsusO8S7mpgVxPuGmDXEO57wL5HuBXAVhDuWmDXEu46YNcR7npg1xPuBmA3EO5GYDcS7iZgNxHuZmA3E+4WYLcQ7vvAvk+4W4HdSrgfAPsB4W4Ddhvhfgjsh4S7HdjthFsJbCXhfgTsR4S7A9gdhPsxsB8T7k5gdxLuJ8B+Qri7gN1FuJ8C+ynhfgbsZ4S7G9jdhPs5sJ8T7hfAfkG4XwL7JeFWAVtFuF8B+xXhfg3s14S7B9g9hPsNsN8Q7rfAfku43wH7HeHuBXYv4e4Ddh/hfg/s94T7A7A/EO6PwP5IuPuB3U+4B4A9QLgHgT1IuIeAPUS4PwH7E+H+DOzPhHsY2MOEWw1sNeH+AuwvhHsE2COEexTYo4T7K7C/Eu5vwP5GuMeAPUa4x4E9Tri/A/s74Z4A9gTh/gHsH4T7J7B/Eu5fwP5FuDXA1hDuSWBPEu4pYE8R7mlgTxPu38D+TbhngD1DuP8A+w/h/gvsv4R7FtizhFsLbC3hngP2HOH+B+x/hHse2POEewHYC4R7EdiLhHsJ2EuEWwdsHeFeBvYy4V4B9grhXgX2KuFeA/Ya4V4H9jrh3gD2BuHeBPYm4dYDW0+4t4C9Rbi3gb1NuHeAvUO4d4G9S7j3gL1HuPeBvU+4D4B9QLgPgX1IuI+AfUS4DcA2EO5jYB8T7hNgnxDuU2CfEm7jpEjO5lyaYIRLB5ZOuC7AuhAuA1gG4boC60q4TGCZhMsClkW4bGDZhMsBlkO4XGC5hOsGrBvh8oDlEa47sO6EyweWT7gCYAWE6wGsB+F6AutJuEJghYQrAlZEuG2AbUO4XsB6Ea43sN6E2xbYtoTrA6wP4foC60u4fsD6EW47YNsRrj+w/oTbHtj2hNsB2A6EGwBsAOEGAhtIuEHABhFuR2A7Em4nYDsRbmdgOxNuF2C7EG5XYLsSbjdguxFud2C7E24wsMGEGwJsCOGGAhtKuD2A7UG4PYHtSbi9gO1FuL2B7U24YmDFhCsBVkK4UmClhBsGbBjhyoCVEW44sOGEKwdWTrgRwEYQrgJYBeFGAhtJuH2A7UO4SmCVhNsX2L6E2w/YfoTbH9j+hDsA2AGEqwJWRbhRwEYRbjSw0YQbA2wM4cYCG0u4A4EdSLhxwMYRbjyw8YQ7CNhBhJsAbALhJgKbSLhJwCYRbjKwyYQ7GNjBhJsCbArhvgLsK4SbCmwq4Q4BdgjhpgGbRrhDgR1KuOnAphPuMGCHEe5wYIcTbgawGYSbCWwm4Y4AdgThjgR2JOGqgVUT7ihgRxHuaGBHE24WsFmEOwbYMYQ7FtixhKsBVkO4WmC1hKsDVke4emD1hGsA1kC42cBmE24OsDmEOw7YcYSbC2wu4Y4Hdjzh5gGbR7j5wOYT7gRgJxBuAbAFhFsIbCHhTgR2IuFOAnYS4RqBNRJuEbBFhGsC1kS4xcAWE+5kYCcT7hRgpxDuVGCnEu40YKcR7nRgpxPuDGBnEG4JsCWE+yqwrxLuTGBnEu4sYGcR7mvAvka4s4GdTbhzgJ1DuHOBnUu484CdR7ivA/s64c4Hdj7hvgHsG4S7ANgFhLsQ2IWEuwjYRYRbCmwp4S4GdjHhlgFbRrhvAvsm4S4BdgnhvgXsW4S7FNilhPs2sG8T7jJglxFuObDlhLsc2OWEuwLYFYS7EtiVhPsOsO8Q7ipgVxHuu8C+S7irgV1NuGuAXUO47wH7HuFWAFtBuGuBXUu464BdR7jrgV1PuBuA3UC4G4HdSLibgN1EuJuB3Uy4W4DdQrjvA/s+4W4FdivhfgDsB4S7DdhthPshsB8S7nZgtxNuJbCVhPsRsB8R7g5gdxDux8B+TLg7gd1JuJ8A+wnh7gJ2F+F+CuynhPsZsJ8R7m5gdxPu58B+TrhfAPsF4X4J7JeEWwVsFeF+BexXhPs1sF8T7h5g9xDuN8B+Q7jfAvst4X4H7HeEuxfYvYS7D9h9hPs9sN8T7g/A/kC4PwL7I+HuB3Y/4R4A9gDhHgT2IOEeAvYQ4f4E7E+E+zOwPxPuYWAPE241sNWE+wuwvxDuEWCPEO5RYI8S7q/A/kq4vwH7G+EeA/YY4R4H9jjh/g7s74R7AtgThPsHsH8Q7p/A/km4fwH7F+HWAFtDuCeBPUm4p4A9RbingT1NuH8D+zfhngH2DOH+A+w/hPsvsP8S7llgzxJuLbC1hHsO2HOE+x+w/xHueWDPE+4FYC8Q7kVgLxLuJWAvEW4dsHWEexnYy4R7BdgrhHsV2KuEew3Ya4R7HdjrhHsD2BuEexPYm4RbD2w94d4C9hbh3gb2NuHeAfYO4d4F9i7h3gP2HuHeB/Y+4T4A9gHhPgT2IeE+AvYR4TYA20C4j4F9TLhPgH1CuE+BfUq4jQ+E5G7OpQlGuHRg6YTrAqwL4TKAZRCuK7CuhMsElkm4LGBZhMsGlk24HGA5hMsFlku4bsC6ES4PWB7hugPrTrh8YPmEKwBWQLgewHoQriewnoQrBFZIuCJgRYTbBtg2hOsFrBfhegPrTbhtgW1LuD7A+hCuL7C+hOsHrB/htgO2HeH6A+tPuO2BbU+4HYDtQLgBwAYQbiCwgYQbBGwQ4XYEtiPhdgK2E+F2BrYz4XYBtgvhdgW2K+F2A7Yb4XYHtjvhBgMbTLghwIYQbiiwoYTbA9gehNsT2J6E2wvYXoTbG9jehCsGVky4EmAlhCsFVkq4YcCGEa4MWBnhhgMbTrhyYOWEGwFsBOEqgFUQbiSwkYTbB9g+hKsEVkm4fYHtS7j9gO1HuP2B7U+4A4AdQLgqYFWEGwVsFOFGAxtNuDHAxhBuLLCxiku1/kh2ovVz+Z29zlZc6xXp5z6lnXqZDP1cqvzOUt/d01t+Ny/nAL18ks8hy7q5DSfMbTpwQV3jaSdiDZHJC+ckgk8X8jtN2U2kb+IziUbKpuFP4+mBXsrmqvZkBhr9yW4t76z4F+s26OUpxJZem0CvTZbW+b6UqCqbbYYxKCTxyQy+te+JFO0J69C/01VZxjMsj9gpJNj/AZYaDub34xEA","debug_symbols":"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QLd+tbDPAoBVATQAdAdwLldKQg7jFwA/is4OQIWiI7IrFB0fW6Ho6Mp9iz6kJ0XH5h1e9HnAYFUoOtamQtExFRWKTndeoehG0Y8vOh1phaLTkVYoOh1phaLTkVYoOh3p8UUPdKQVik5HWqHodKQVik5HWqHoRtGPLzodaYWi05FWKDodaYWi05FWKDod6fFFj3SkFYpOR1qh6HSkFYpOR1qh6EbRjy86HWmFotORVig6HWmFotORVig6HenxRR/pSCsUnY60QtHpSCsUnY60QtGNoh9fdDrSCkWnIz38J43zSEdaoeh0pBWKTkd6fNGNjrRC0elIKxSdjrRC0elID73L00fRjaIfX3Q60gpFpyOtUHQ60gpFpyOtUHQ60uOLPtGRVig6HWmFotORVig6HWmFohtFP77odKQVik5HWqHodKQVik5HWqHodKTHFz3RkVYoOh1phaLTkVYoOh1phaIbRT++6HSkFYpOR1qh6HSkFYpOR1qh6HSkxxd9piOtUHQ60gpFpyOtUHQ60gpFN4p+fNHpSCsUnY60QtHpSCsUnY60QtHpSI8veqYjrVB0OtIKRacjrVB0OtIKRTeKfnzR6UgrFJ2OtELR6UgrFJ2OtELR6UiPL3qhI61QdDrSCkWnI61QdDrSCkU3in580elIKxSdjrRC0elIKxSdjrRC0elIDy96HuhIKxSdjrRC0elIKxSdjrRC0Y2iH190OtIKRacjrVB0OtIKRacjrVB0OtLjix7oSCsUnY60QtHpSCsUnY60QtGNoh9fdDrSCkWnI61QdDrSCkWnI61QdDrS44se6UgrFJ2OtELR6UgrFJ2OtELRjaIfX3Q60gpFpyOtUHQ60gpFpyOtUHQ60uOLPtKRVig6HWmFotORVig6HWmFohtFP77odKQVik5HWqHodKQVik5HWqHodKTHF93oSCsUnY60QtHpSCsUnY60QtGNoh9fdDrSCkWnI61QdDrSCkWnI61QdDrS44s+0ZFWKDodaYWi05FWKDodaYWiG0U/vuh0pBWKTkdaoeh0pBWKTkdaoeh0pMcXPdGRVig6HWmFotORVig6HWmFohtFP77odKQVik5HWqHodKQVik5HWqHodKTHF32mI61QdDrSCkWnI61QdDrSCkU3in580elIKxSdjrRC0elIKxSdjrRC0elIjy96piOtUHQ60gpFpyOt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"},{"name":"initialize","is_unconstrained":false,"custom_attributes":["aztec(private)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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UHSj6McXnY60QtHpSCsUnY60QtHpSCsUnY70+KLPdKQVik5HWqHodKQVik5HWqHoRtGPLzodaYWi05FWKDodaYWi05FWKDod6fFFz3SkFYpOR1qh6HSkFYpOR1qh6EbRjy86HWmFotORVig6HWmFotORVig6HenxRS90pBWKTkdaoeh0pBWKTkdaoehG0Y8vOh1phaLTkVYoOh1phaLTkVYoOh3p4UUvAx1phaLTkVYoOh1phaLTkVYoulH044tOR1qh6HSkFYpOR1qh6HSkFYpOR3p80QMdaYWi05FWKDodaYWi05FWKLpR9OOLTkdaoeh0pBWKTkdaoeh0pBWKTkd6fNEjHWmFotORVig6HWmFotORVii6UfTji05HWqHodKQVik5HWqHodKQVik5HenzREx1phaLTkVYoOh1phaLTkVYoulH044tOR1qh6HSkFYpOR1qh6HSkFYpOR3p80Y2OtELR6UgrFJ2OtELR6UgrFN0o+vFFpyOtUHQ60gpFpyOtUHQ60gpFpyM9vugjHWmFotORVig6HWmFotORVii6UfTji05HWqHodKQVik5HWqHodKQVik5HenzRJzrSCkWnI61QdDrSCkWnI61QdKPoxxedjrRC0elIKxSdjrRC0elIKxSdjvT4os90pBWKTkdaoeh0pBWKTkdaoehG0Y8vOh1phaLTkVYoOh1phaLTkVYoOh3p8UXPdKQVik5HWqHodKQVik5HWqHoRtGPLzodaYWi05FWKDodaYWi05FWKDod6fFFL3SkFYpOR1qh6HSkFYpOR1qh6EbRjy86HWmFotORVig6HWmFotORVig6HenRRbdhoCOtUHQ60gpFpyOtUHQ60gpFN4p+fNHpSCsUnY60QtHpSCsUnY60QtHpSI8veqAjrVB0OtIKRacjrVB0OtIKRTeKfnzR6UgrFJ2OtELR6UgrFJ2OtELR6UiPL3qkI61QdDrSCkWnI61QdDrSCkU3in580XvtSG28FT2Xja3LUo4y3aoRLp/7KKJOhznGeSni3Zj/iNw8X3d++e98x9c0Po3oUpPr7tOFzS/bf5RSp2+sXkqdbvC9UqYwxOuo04+/dI+ledqzXesyrBdlHq9Dn+e7v7/x2XGOOYyfG485xe+HmoYzjvzyr3/9j7/+7W9//V///W//+Le//POv//j7f/749PDjfzxvoKd8/Ws+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"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Counter::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Counter::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Counter::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Counter::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::initialize_parameters","fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Counter::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"Counter::increment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::increment_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"outgoing_viewer","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000071421477"},{"kind":"string","value":"ValueNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"counters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}}]}]}},"file_map":{"2":{"source":"use crate::cmp::Ord;\nuse crate::option::Option;\nuse crate::convert::From;\n\nimpl<T, let N: u32> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = unsafe {\n            // Safety: These indices are asserted to be the sorted element indices via `find_index`\n            let sorted_index: [u32; N] = self.get_sorting_index(ordering);\n\n            for i in 0..N {\n                let pos = find_index(sorted_index, i);\n                assert(sorted_index[pos] == i);\n            }\n\n            sorted_index\n        };\n\n        // Sort the array using the indexes\n        let mut result = self;\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u32; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Convert a sequence of bytes as-is into a string.\n    /// This function performs no UTF-8 validation or similar.\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<let N: u32>(a: [u32; N], find: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n","path":"std/array.nr"},"5":{"source":"use crate::{cmp::Eq, convert::From};\n\nstruct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Responds with undefined data for `index` where `self.len < index < self.max_len()`.\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Does not check whether the passed `index` is a valid index within the vector.\n    ///\n    /// Silently writes past the end of the vector for `index` where `self.len < index < self.max_len()`\n    /// Panics if the given index points beyond the maximum length of the vector (`self.max_len()`).\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        \n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen>  {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"22":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\nstruct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint { \n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint { \n        EmbeddedCurvePoint {\n            x: self.x,\n            y: -self.y,\n            is_infinite: self.is_infinite\n        }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite) | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\nstruct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n// This is a hack as returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\nfn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint\n) -> EmbeddedCurvePoint\n// docs:end:embedded_curve_add\n{\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n    EmbeddedCurvePoint { x, y, is_infinite: point_array[2] == 1 }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n","path":"std/embedded_curve_ops.nr"},"23":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\nuse sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"53":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"59":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"62":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            \n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"64":{"source":"\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\ncontract Counter {\n    use dep::aztec::prelude::{AztecAddress, Map, FunctionSelector, EthAddress, PublicMutable, SharedImmutable};\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n    use dep::token::Token;\n    \n    #[aztec(storage)]\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn initialize(headstart: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, outgoing_viewer);\n    }\n\n     // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[aztec(private)]\n    fn increment(owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        dep::aztec::oracle::debug_log::debug_log_format(\"Incrementing counter for owner {0}\", [owner.to_field()]);\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, outgoing_viewer);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        Counter::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n\n}","path":"/home/lima.linux/aztec/aztec-starter/contracts/counter/src/main.nr"},"74":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N, M>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    let serialized_note = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    )\n        == 0\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, N, M>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N, M> {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, N, M>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N, M> {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    assert(notify_nullified_note(nullifier, notification_note_hash, nullifier_counter) == 0);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"75":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\nstruct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting  \n * a change note in a token's transfer function only when there is \"change\" left).\n */\nstruct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"76":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32, let M: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in \n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the \n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the \n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from \n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    // TODO(#7771): inject compute_note_hash(...) func to notes with macros.\n    let note_hash = note.compute_note_hiding_point().x;\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"78":{"source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus, PropertySelector},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note. \n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value = serialized_note[selector.index].to_be_bytes(32);\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32, let M: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let is_equal = value_field == select.value.to_field();\n        let is_lt = value_field.lt(select.value.to_field());\n\n        if (select.comparator == Comparator.EQ) {\n            assert(is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(is_lt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(is_lt | is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!is_lt & !is_equal, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!is_lt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32, let M: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N, M> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    let opt_notes = get_notes_internal(storage_slot, options);\n\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N, M> + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32, let M: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N, M> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, let M: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N, M> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N, M>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N, M> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<Note, let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"93":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_data_tree_index\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"95":{"source":"use crate::keys::public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH};\nuse dep::protocol_types::traits::{Serialize, Deserialize};\n\n// This struct represents how public keys are stored in the key registry. We store not just the keys themselves but also\n// their hash, so that when reading in private we can perform a historical read for the hash and then show that it\n// corresponds to a preimage obtained from an unconstrained hint. We do store the keys keys regardless as they might be\n// needed during public execution, and since we need to broadcast and produce hints in some standardized way.\n// While it might seem odd to create a struct for what is effectively some data and a pure function called on it, state\n// variables rely on serializable structs in order to persist data to storage, so we must use this abstraction.\nstruct StoredKeys {\n    public_keys: PublicKeys,\n    hash: Field,\n}\n\nimpl StoredKeys {\n    // Instances of StoredKeys are expected to only be created by calling this function so that we guarantee that the\n    // hash field does indeed correspond to the hash of the keys. Ideally we'd forbid direct access to the struct, but \n    // Noir doesn't yet support private members.\n    fn new(public_keys: PublicKeys) -> Self {\n        Self { public_keys, hash: public_keys.hash().inner }\n    }\n}\n\n// Our serialization is the concatenation of the public keys serialization plush the hash, so we need one extra field.\nglobal STORED_KEYS_LENGTH: u32 =  PUBLIC_KEYS_LENGTH + 1;\n\nimpl Serialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn serialize(self) -> [Field; STORED_KEYS_LENGTH] {\n        // The code below is equivalent to:\n        // [ ...self.public_keys.serialize(), self.hash ]\n\n        let mut array = [0; STORED_KEYS_LENGTH];\n\n        let serialized_keys = self.public_keys.serialize();\n        for i in 0..serialized_keys.len() {\n            array[i] = serialized_keys[i];\n        }\n\n        array[PUBLIC_KEYS_LENGTH] = self.hash;\n\n        array\n    }\n}\n\nimpl Deserialize<STORED_KEYS_LENGTH> for StoredKeys {\n    fn deserialize(array: [Field; STORED_KEYS_LENGTH]) -> Self {\n        // The code below is equivalent to:\n        // Self { public_keys: PublicKeys::deserialize(array[0 : PUBLIC_KEYS_LENGTH]), hash: array[PUBLIC_KEYS_LENGTH] }\n\n        let mut serialized_keys = [0; PUBLIC_KEYS_LENGTH];\n        for i in 0..serialized_keys.len() {\n            serialized_keys[i] = array[i];\n        }\n\n        let hash = array[PUBLIC_KEYS_LENGTH];\n\n        Self { public_keys: PublicKeys::deserialize(serialized_keys), hash }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/stored_keys.nr"},"96":{"source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nfn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"},"99":{"source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\nuse crate::keys::constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\nstruct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\ntrait ToPoint {\n    fn to_point(self) -> Point;\n}\n\nstruct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nstruct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nstruct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m : NpkM { inner: Point::empty() },\n            ivpk_m : IvpkM { inner: Point::empty() },\n            ovpk_m : OvpkM { inner: Point::empty() },\n            tpk_m : TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        ( self.npk_m.inner == other.npk_m.inner ) &\n        ( self.ivpk_m.inner == other.ivpk_m.inner ) &\n        ( self.ovpk_m.inner == other.ovpk_m.inner ) &\n        ( self.tpk_m.inner == other.tpk_m.inner )\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x:serialized[0], y:serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x:serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x:serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x:serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nfn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nfn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr"},"101":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::{PrivateContext, UnconstrainedContext},\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{\n    public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH}, stored_keys::StoredKeys,\n    constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}\n},\n    state_vars::{\n    shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter,\n    public_mutable::PublicMutable, map::Map\n}\n};\n\nmod test;\n\n// This is the number of blocks that must pass after a key rotation event until the old keys are fully phased out and\n// become invalid.\nglobal KEY_REGISTRY_UPDATE_BLOCKS = 5;\n\nglobal KEY_REGISTRY_STORAGE_SLOT = 1;\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// Returns all current public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_current_public_keys(context: &mut PrivateContext, account: AztecAddress) -> PublicKeys {\n    // We're going to perform historical reads from public storage, and so need to constrain the caller so that they\n    // cannot use very old blocks when constructing proofs, and hence e.g. read very old keys. We are lax and allow\n    // _any_ recent block number to be used, regardless of whether there may have been a recent key rotation. This means\n    // that multiple sets of keys are valid for a while immediately after rotation, until the old keys become phased\n    // out. We *must* be lax to prevent denial of service and transaction fingerprinting attacks by accounts that rotate\n    // their keys frequently.\n    // Note that we constrain the max block number even if the registry ends up being empty: this ensures that proof of\n    // an empty registry is also fresh.\n    let current_header = context.get_header();\n    context.set_tx_max_block_number(current_header.global_variables.block_number as u32 + KEY_REGISTRY_UPDATE_BLOCKS);\n\n    get_historical_public_keys(current_header, account)\n}\n\n// Returns historical public keys for a given account at some block determined by a block header. We read all keys at\n// once since the constraints for reading them all are actually fewer than if we read them one at a time - any read keys\n// that are not required by the caller can simply be discarded.\n// WARNING: if called with a historical header created from a fixed block this function will explicitly ignore key\n// rotation! This means that callers of this may force a user to use old keys, potentially leaking privacy (e.g. if the\n// old keys were leaked). Only call this function with a header from a fixed block if you understand the implications of\n// breaking key rotation very well.\npub fn get_historical_public_keys(historical_header: Header, account: AztecAddress) -> PublicKeys {\n    // TODO: improve this so that we always hint the correct set of keys (either registry or canonical) and hash them\n    // once instead of having two different hints and twice as many constraints due to the double hashing.\n\n    // The key registry is the primary source of information for keys, as that's where accounts store their new keys\n    // when they perform rotation. The key registry conveniently stores a hash of each user's keys, so we can read that\n    // single field and then prove that we know its preimage (i.e. the current set of keys).\n    let key_registry_hash = key_registry_hash_public_historical_read(historical_header, account);\n    if key_registry_hash != 0 {\n        let hinted_registry_public_keys = key_registry_get_stored_keys_hint(\n            account,\n            historical_header.global_variables.block_number as u32\n        );\n        assert_eq(hinted_registry_public_keys.hash().to_field(), key_registry_hash);\n\n        hinted_registry_public_keys\n    } else {\n        // If nothing was written to the registry, we may still be able to produce the correct keys if we happen to know\n        // the canonical set (i.e. the ones that are part of the account's preimage).\n        let (hinted_canonical_public_keys, partial_address) = get_public_keys_and_partial_address(account);\n        assert_eq(\n            account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n        );\n\n        hinted_canonical_public_keys\n    }\n}\n\nfn key_registry_hash_public_historical_read(historical_header: Header, account: AztecAddress) -> Field {\n    // The keys are stored in a Map that is keyed with the address of each account, so we first derive the corresponding\n    // slot for this account.\n    let keys_storage_slot = derive_storage_slot_in_map(KEY_REGISTRY_STORAGE_SLOT, account);\n\n    // The keys are stored as [ ...serialized_keys, hash ], and since arrays get allocated sequential storage slots\n    // (prior to siloing!), we simply add the length to the base slot to get the last element.\n    let hash_storage_slot = keys_storage_slot + PUBLIC_KEYS_LENGTH as Field;\n\n    historical_header.public_storage_historical_read(hash_storage_slot, CANONICAL_KEY_REGISTRY_ADDRESS)\n}\n\nunconstrained fn key_registry_get_stored_keys_hint(account: AztecAddress, block_number: u32) -> PublicKeys {\n    // This is equivalent to the key registry contract having an unconstrained getter that we call from an oracle, but\n    // PXE does not yet support that functionality so we do this manually instad. Note that this would be a *historical*\n    // call!\n\n    // TODO (#7524): call the unconstrained KeyRegistry.get_current_keys() function instead\n\n    let context = UnconstrainedContext::at_historical(CANONICAL_KEY_REGISTRY_ADDRESS, block_number);\n    let keys_storage = Map::new(\n        context,\n        KEY_REGISTRY_STORAGE_SLOT,\n        |context, slot| { PublicMutable::new(context, slot) }\n    );\n\n    let stored_keys: StoredKeys = keys_storage.at(account).read();\n    stored_keys.public_keys\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"102":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash,\n    hash::{\n    pedersen_hash, compute_siloed_nullifier, sha256_to_field, pedersen_commitment,\n    poseidon2_hash_with_separator\n}\n};\n// Note: pedersen_commitment is used only as a re-export here\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = poseidon2_hash_with_separator(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        poseidon2_hash_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x1cce4dbf69f14c44865919991ee1057922e34d7310ba237d71759aa422621ca9);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"111":{"source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"120":{"source":"use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N, M> {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N, M> + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, M, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32, let M: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N, M> {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N, M>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"121":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"122":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once. \n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"125":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"127":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"128":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"131":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"133":{"source":"use dep::protocol_types::{address::AztecAddress, point::Point};\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(_note_hash_counter: u32, _encrypted_note: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(_contract_address: AztecAddress, _randomness: Field, _encrypted_event: [u8; M], _counter: u32) {}\n\nunconstrained pub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedNoteLog)]\nunconstrained fn compute_encrypted_note_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_note_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_note_log_oracle(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n// = 480 + 32 * N bytes\n#[oracle(computeEncryptedEventLog)]\nunconstrained fn compute_encrypted_event_log_oracle<let N: u32, let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _event_type_id: Field,\n    _ovsk_app: Field,\n    _ovpk_m: Point,\n    _ivpk_m: Point,\n    _recipient: AztecAddress,\n    _preimage: [Field; N]\n) -> [u8; M] {}\n\nunconstrained pub fn compute_encrypted_event_log<let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    event_type_id: Field,\n    ovsk_app: Field,\n    ovpk_m: Point,\n    ivpk_m: Point,\n    recipient: AztecAddress,\n    preimage: [Field; N]\n) -> [u8; M] {\n    compute_encrypted_event_log_oracle(\n        contract_address,\n        randomness,\n        event_type_id,\n        ovsk_app,\n        ovpk_m,\n        ivpk_m,\n        recipient,\n        preimage\n    )\n}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_oracle_private<T>(_contract_address: AztecAddress, _message: T, _counter: u32) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log_private_internal<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32\n) -> Field {\n    emit_unencrypted_log_oracle_private(contract_address, message, counter)\n}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n\nunconstrained pub fn emit_contract_class_unencrypted_log_private_internal<let N: u32>(contract_address: AztecAddress, message: [Field; N], counter: u32) -> Field {\n    emit_contract_class_unencrypted_log_private(contract_address, message, counter)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"134":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"135":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage,\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, public_data_tree_index: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"137":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained pub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter)\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle<let N: u32>(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\nunconstrained pub fn notify_nullified_note<let N: u32>(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) -> Field {\n    notify_nullified_note_oracle(nullifier, note_hash, counter)\n}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let NB: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N, NB> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n// Only ever use this in private!\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n// Only ever use this in private!\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"138":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"139":{"source":"#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n\n// Called `unsafe_rand` because we do not constrain in circuit that we are dealing with an actual random value.\n// Instead we just trust our PXE.\nunconstrained pub fn unsafe_rand() -> Field {\n    rand_oracle()\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/unsafe_rand.nr"},"140":{"source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained fn get_public_keys_and_partial_address_oracle_wrapper(address: AztecAddress) -> [Field; 13] {\n    get_public_keys_and_partial_address_oracle(address)\n}\n\npub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle_wrapper(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"144":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"146":{"source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"150":{"source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_current_public_keys, public_keys::{OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_note_log, oracle::logs_traits::LensForEncryptedLog\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field, address::AztecAddress, point::Point, abis::note_hash::NoteHash,\n    constants::MAX_NOTE_HASHES_PER_CALL\n};\n\nunconstrained fn compute_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    )\n}\n\nfn compute<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> ([u8; M], Field) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let encrypted_log: [u8; M] = compute_encrypted_note_log(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n    (encrypted_log, log_hash)\n}\n\nfn emit_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    inner_compute: fn(AztecAddress, Field, Field, OvpkM, IvpkM, AztecAddress, Note) -> ([u8; M], Field)\n) where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n    let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n    let (encrypted_log, log_hash) = inner_compute(\n        contract_address,\n        storage_slot,\n        ovsk_app,\n        ovpk,\n        ivpk,\n        recipient,\n        note\n    );\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ov: AztecAddress,\n    iv: AztecAddress\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        let ovpk = get_current_public_keys(context, ov).ovpk_m;\n        let ivpk = get_current_public_keys(context, iv).ivpk_m;\n        emit_with_keys(context, e.note, ovpk, ivpk, iv, compute_unconstrained);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute);\n    }\n}\n\npub fn encode_and_encrypt_note_with_keys_unconstrained<Note, let N: u32, let NB: u32, let M: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N, NB>, [Field; N]: LensForEncryptedLog<N, M> {\n    | e: NoteEmission<Note> | {\n        emit_with_keys(context, e.note, ovpk, ivpk, recipient, compute_unconstrained);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"151":{"source":"use crate::note::note_interface::NoteInterface;\nuse crate::event::event_interface::EventInterface;\nuse dep::protocol_types::{scalar::Scalar, point::Point};\n\nuse std::aes128::aes128_encrypt;\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::IvpkM};\n\nstruct EncryptedLogIncomingBody<let M: u32> {\n    plaintext: [u8; M]\n}\n\nimpl<let M: u32> EncryptedLogIncomingBody<M> {\n    pub fn from_note<T, let N: u32>(note: T, storage_slot: Field) -> Self where T: NoteInterface<N, M> {\n        let mut plaintext = note.to_be_bytes(storage_slot);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn from_event<T, let MR: u32>(\n        event: T,\n        randomness: Field\n    ) -> Self where T: EventInterface<M, MR> {\n        let mut plaintext = event.private_to_be_bytes(randomness);\n        EncryptedLogIncomingBody { plaintext }\n    }\n\n    pub fn compute_ciphertext(self, eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n        let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(self.plaintext, iv, sym_key)\n    }\n}\n\nmod test {\n    use dep::protocol_types::{\n        address::AztecAddress, scalar::Scalar, point::Point, traits::Serialize,\n        abis::event_selector::EventSelector\n    };\n\n    use crate::{\n        note::{note_header::NoteHeader, note_interface::NoteInterface},\n        encrypted_logs::incoming_body::EncryptedLogIncomingBody, event::event_interface::EventInterface,\n        context::PrivateContext, keys::public_keys::IvpkM\n    };\n\n    struct AddressNote {\n        address: AztecAddress,\n        owner: AztecAddress,\n        randomness: Field,\n        header: NoteHeader,\n    }\n\n    global ADDRESS_NOTE_LEN: Field = 3;\n    global ADDRESS_NOTE_BYTES_LEN = 32 * 3 + 64;\n\n    impl NoteInterface<ADDRESS_NOTE_LEN, ADDRESS_NOTE_BYTES_LEN> for AddressNote {\n        fn compute_note_hiding_point(self) -> Point {\n            crate::generators::Ga1\n        }\n\n        fn get_note_type_id() -> Field {\n            1\n        }\n\n        fn get_header(self) -> NoteHeader { self.header}\n\n        fn set_header(&mut self, header: NoteHeader) {self.header = header; }\n\n        fn compute_nullifier(_self: Self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n            1\n        }\n\n        fn compute_nullifier_without_context(_self: Self) -> Field {\n            1\n        }\n\n        fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN] { [self.address.to_field(), self.owner.to_field(), self.randomness]}\n\n        fn deserialize_content(fields: [Field; ADDRESS_NOTE_LEN]) -> Self {\n            AddressNote { address: AztecAddress::from_field(fields[0]), owner: AztecAddress::from_field(fields[1]), randomness: fields[2], header: NoteHeader::empty() }\n        }\n\n        fn to_be_bytes(self, storage_slot: Field) -> [u8; ADDRESS_NOTE_BYTES_LEN] {\n            let serialized_note = self.serialize_content();\n\n            let mut buffer: [u8; ADDRESS_NOTE_BYTES_LEN] = [0; ADDRESS_NOTE_BYTES_LEN];\n\n            let storage_slot_bytes = storage_slot.to_be_bytes(32);\n            let note_type_id_bytes = AddressNote::get_note_type_id().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = storage_slot_bytes[i];\n                buffer[32 + i] = note_type_id_bytes[i];\n            }\n\n            for i in 0..serialized_note.len() {\n                let bytes = serialized_note[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n            buffer\n        }\n    }\n\n    impl AddressNote {\n        pub fn new(address: AztecAddress, owner: AztecAddress, randomness: Field) -> Self {\n            AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n        }\n    }\n\n    #[test]\n    fn test_encrypted_note_log_incoming_body_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let note = AddressNote::new(\n            AztecAddress::from_field(0x1),\n            AztecAddress::from_field(0x2),\n            3\n        );\n\n        let storage_slot = 2;\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        /// 1. `EncryptedLogIncomingBody::from_note` calls `note.to_be_bytes(storage_slot)` function which serializes\n        /// the note to bytes - note that in the case of `AddressNote` the `to_be_bytes` function was automatically\n        /// implemented by Aztec macros.\n        let body = EncryptedLogIncomingBody::from_note(note, storage_slot);\n\n        /// 2. `body.compute_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    struct TestEvent {\n        value0: Field,\n        value1: Field,\n        value2: Field,\n    }\n\n    impl Serialize<3> for TestEvent {\n        fn serialize(self) -> [Field; 3] {\n            [self.value0, self.value1, self.value2]\n        }\n    }\n\n    global TEST_EVENT_LEN: Field = 3;\n    global TEST_EVENT_BYTES_LEN = 32 * 3 + 64;\n    global TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS = 32 * 3 + 32;\n\n    impl EventInterface<TEST_EVENT_BYTES_LEN, TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS> for TestEvent {\n        fn get_event_type_id() -> EventSelector {\n            EventSelector::from_signature(\"TestEvent(Field,Field,Field)\")\n        }\n\n        fn private_to_be_bytes(self, randomness: Field) -> [u8; TEST_EVENT_BYTES_LEN] {\n            let mut buffer: [u8; TEST_EVENT_BYTES_LEN] = [0; TEST_EVENT_BYTES_LEN];\n\n            let randomness_bytes = randomness.to_be_bytes(32);\n            let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n            for i in 0..32 {\n                buffer[i] = randomness_bytes[i];\n                buffer[32 + i] = event_type_id_bytes[i];\n            }\n\n            let serialized_event = self.serialize();\n\n            for i in 0..serialized_event.len() {\n                let bytes = serialized_event[i].to_be_bytes(32);\n                for j in 0..32 {\n                    buffer[64 + i * 32 + j] = bytes[j];\n                }\n            }\n\n            buffer\n        }\n\n        fn to_be_bytes(self) -> [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] {\n             let mut buffer: [u8; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS] = [0; TEST_EVENT_BYTES_LEN_WITHOUT_RANDOMNESS];\n\n             let event_type_id_bytes = TestEvent::get_event_type_id().to_field().to_be_bytes(32);\n\n             for i in 0..32 {\n                 buffer[i] = event_type_id_bytes[i];\n            }\n\n             let serialized_event = self.serialize();\n\n             for i in 0..serialized_event.len() {\n                 let bytes = serialized_event[i].to_be_bytes(32);\n                 for j in 0..32 {\n                     buffer[32 + i * 32 + j] = bytes[j];\n                }\n            }\n\n             buffer\n        }\n\n        fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n            _emit(self);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_event_incoming_body() {\n        let test_event = TestEvent { value0: 1, value1: 2, value2: 3 };\n\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n\n        let randomness = 2;\n\n        let body = EncryptedLogIncomingBody::from_event(test_event, randomness);\n\n        let ciphertext = body.compute_ciphertext(eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_event_log_incoming_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let event_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 185, 29, 14, 152, 216, 130, 219, 151, 80, 185, 43, 223, 167, 8, 89, 189, 88, 188, 101, 137, 255, 136, 84, 252, 79, 18, 52, 3, 110, 54, 54, 206, 244, 209, 246, 226, 207, 247, 143, 253, 211, 75, 160, 224, 172, 41, 45, 7, 208, 137, 90, 56, 59, 4, 234, 48, 53, 23, 130, 230, 49, 249, 142, 243, 170, 72, 183, 242, 49, 124, 46, 52, 198, 75, 55, 102, 56, 89, 254, 67, 59, 157, 249, 120, 184, 67, 154, 16, 148, 227, 93, 37, 120, 199, 93, 166, 80, 127, 173, 52, 80, 135, 87, 1, 168, 164, 51, 48, 126, 120, 47, 102, 211, 227, 234, 170, 208, 99, 111, 198, 170, 226, 156, 244, 241, 174, 206, 30\n        ];\n\n        assert_eq(event_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..event_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], event_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/incoming_body.nr"},"152":{"source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::aes128::aes128_encrypt;\n\nuse crate::{keys::public_keys::IvpkM, utils::point::point_to_bytes};\n\nstruct EncryptedLogOutgoingBody {\n    eph_sk: Scalar,\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n}\n\nimpl EncryptedLogOutgoingBody {\n    pub fn new(eph_sk: Scalar, recipient: AztecAddress, recipient_ivpk: IvpkM) -> Self {\n        Self { eph_sk, recipient, recipient_ivpk }\n    }\n\n    /// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n    /// be able to derive the key with which the incoming log can be decrypted.\n    pub fn compute_ciphertext(self, ovsk_app: Scalar, eph_pk: Point) -> [u8; 144] {\n        // Again, we could compute `eph_pk` here, but we keep the interface more similar\n        // and also make it easier to optimise it later as we just pass it along\n\n        let mut buffer = [0 as u8; 128];\n\n        let serialized_eph_sk_high = self.eph_sk.hi.to_be_bytes(32);\n        let serialized_eph_sk_low = self.eph_sk.lo.to_be_bytes(32);\n\n        let address_bytes = self.recipient.to_field().to_be_bytes(32);\n        let serialized_recipient_ivpk = point_to_bytes(self.recipient_ivpk.to_point());\n\n        for i in 0..32 {\n            buffer[i] = serialized_eph_sk_high[i];\n            buffer[i + 32] = serialized_eph_sk_low[i];\n            buffer[i + 64] = address_bytes[i];\n        }\n        for i in 0..32 {\n            buffer[i + 96] = serialized_recipient_ivpk[i];\n        }\n\n        // We compute the symmetric key using poseidon.\n        let full_key: [u8; 32] = poseidon2_hash_with_separator(\n            [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n            GENERATOR_INDEX__SYMMETRIC_KEY as Field\n        ).to_be_bytes(32).as_array();\n\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n        aes128_encrypt(buffer, iv, sym_key).as_array()\n    }\n}\n\nmod test {\n    use crate::{encrypted_logs::outgoing_body::EncryptedLogOutgoingBody, keys::public_keys::IvpkM};\n    use dep::protocol_types::{\n        address::AztecAddress, traits::Empty, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        scalar::Scalar, point::Point, hash::poseidon2_hash_with_separator\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n\n    use crate::context::PrivateContext;\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let body = EncryptedLogOutgoingBody::new(eph_sk, recipient, recipient_ivpk);\n\n        let ciphertext = body.compute_ciphertext(sender_ovsk_app, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/outgoing_body.nr"},"153":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\nstruct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nfn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"154":{"source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\nuse std::{\n    embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    event::event_interface::EventInterface, oracle::unsafe_rand::unsafe_rand,\n    utils::point::point_to_bytes, note::note_interface::NoteInterface,\n    encrypted_logs::{\n    header::EncryptedLogHeader, incoming_body::EncryptedLogIncomingBody,\n    outgoing_body::EncryptedLogOutgoingBody\n},\n    keys::public_keys::{OvpkM, IvpkM}\n};\n\npub fn compute_encrypted_event_log<Event, let NB: u32, let MB: u32, let OB: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    event: Event\n) -> [u8; OB] where Event: EventInterface<NB, MB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_event(event, randomness).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; OB] = [0; OB];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = OB - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\npub fn compute_encrypted_note_log<Note, let N: u32, let NB: u32, let M: u32>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    note: Note\n) -> [u8; M] where Note: NoteInterface<N, NB> {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = EncryptedLogIncomingBody::from_note(note, storage_slot).compute_ciphertext(eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = EncryptedLogOutgoingBody::new(eph_sk, recipient, ivpk).compute_ciphertext(fr_to_fq(ovsk_app), eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (N * 32 bytes + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(unsafe_rand());\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::compute_encrypted_note_log, keys::public_keys::{OvpkM, IvpkM},\n        test::mocks::mock_note::MockNoteBuilder\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point};\n    use std::test::OracleMock;\n\n    #[test]\n    fn test_encrypted_note_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let storage_slot = 0x0fe46be583b71f4ab5b70c2657ff1d05cccf1d292a9369628d1a194f944e6599;\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let note_value = 0x301640ceea758391b2e161c92c0513f129020f4125256afdae2646ce31099f5c;\n        let note = MockNoteBuilder::new(note_value).contract_address(contract_address).storage_slot(storage_slot).build();\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_note_log(\n            contract_address,\n            storage_slot,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            note\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_note_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 205, 103, 212, 60, 151, 141, 10, 151, 222, 151, 180, 43, 91, 148, 201, 110, 165, 10, 238, 32, 134, 235, 99, 216, 200, 182, 31, 22, 156, 18, 209, 222, 172, 239, 193, 212, 86, 99, 62, 70, 182, 45, 175, 241, 91, 202, 179, 225, 236, 95, 71, 66, 151, 225, 203, 53, 216, 85, 102, 130, 6, 8, 25, 180, 86, 58, 140, 198, 105, 102, 177, 42, 94, 115, 247, 145, 147, 24, 231, 39, 73, 27, 10, 219, 130, 115, 188, 74, 114, 5, 177, 199, 83, 183, 106, 87, 204, 238, 231, 72, 45, 240, 39, 174, 25, 98, 53, 187, 156, 159, 244, 38\n        ];\n        for i in 0..encrypted_note_log_from_typescript.len() {\n            assert_eq(log[i], encrypted_note_log_from_typescript[i]);\n        }\n        assert_eq(encrypted_note_log_from_typescript.len(), log.len());\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"158":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result = pk.x.to_be_bytes(32);\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result.as_array()\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"159":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"164":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"165":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"168":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::{raw_storage_read, storage_read}\n};\n\nstruct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"173":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"180":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash_with_separator,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"181":{"source":"use crate::{\n    address::{eth_address::EthAddress, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"182":{"source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"183":{"source":"use crate::{\n    address::{\n    eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash,\n    aztec_address::AztecAddress\n},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, FromField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH = 1;\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n       PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"184":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"189":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc, point::Point\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"191":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        assert(false, \"depth should be between 0 and 10\");\n        0\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"208":{"source":"// Utility function to console.log data in the acir simulator\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n\n/// NOTE: call this with a str<N> msg of form\n/// \"some string with {0} and {1} ... {N}\"\n/// and an array of N field which will be formatted\n/// into the string in the simulator.\n/// Example:\n/// debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n/// debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\nunconstrained pub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n/// NOTE: call this with a str<N> msg of length > 1\n/// Example:\n/// `debug_log(\"blah blah this is a debug string\");`\nunconstrained pub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"225":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"253":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"269":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"271":{"source":"use crate::{hash::pedersen_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    pedersen_hash([storage_slot, key.to_field()], 0)\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x2499880e2b1b831785c17286f99a0d5122fee784ce7b1c04e380c4a991da819a;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"273":{"source":"use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: Field = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point {\n            x: 0,\n            y: 0,\n            is_infinite: false\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"283":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"284":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"285":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"307":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"309":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"313":{"source":"use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_with_keys,\n    keys::getters::get_current_public_keys\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl<Context> EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_keys.npk_m.hash());\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_current_public_keys(self.context, owner);\n        let outgoing_viewer_keys = get_current_public_keys(self.context, outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_keys.npk_m.hash());\n        self.set.insert(&mut result_note).emit(\n            encode_and_encrypt_note_with_keys(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr"},"315":{"source":"use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Deserialize, Serialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_nullify},\n    oracle::unsafe_rand::unsafe_rand, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n// VALUE_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal VALUE_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n// docs:start:value-note-def\n#[aztec(note)]\nstruct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN, VALUE_NOTE_BYTES_LEN> for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe_rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    /// The following method needed to be implemented because the note is passed as an argument to a contract function\n    /// --> the serialize method is called by aztec-nr when computing an arguments hash.\n    /// Note that when the note is about to be encrypted and emitted as a log the to_be_bytes function auto-implemented\n    /// by aztec macros is called instead.\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.npk_m_hash, self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/value-note/src/value_note.nr"},"316":{"source":"use dep::aztec::{\n    context::UnconstrainedContext, state_vars::PrivateSet,\n    note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions}\n};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote, UnconstrainedContext>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/aztec-nr/value-note/src/balance_utils.nr"},"331":{"source":"use dep::aztec::{\n    generators::{Ga1 as G_amt, Ga2 as G_npk, Ga3 as G_rnd, G_slot},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{\n    constants::GENERATOR_INDEX__NOTE_NULLIFIER, point::{Point, POINT_LENGTH}, scalar::Scalar,\n    hash::poseidon2_hash_with_separator, traits::Serialize\n},\n    note::utils::compute_note_hash_for_nullify, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\nuse dep::std::{embedded_curve_ops::multi_scalar_mul, hash::from_field_unsafe};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator([note_hash_for_nullify, secret],GENERATOR_INDEX__NOTE_NULLIFIER)\n    }\n\n    fn compute_note_hiding_point(self) -> Point {\n        // We use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        let amount_scalar = from_field_unsafe(self.amount.to_integer());\n        let npk_m_hash_scalar = from_field_unsafe(self.npk_m_hash);\n        let randomness_scalar = from_field_unsafe(self.randomness);\n        let slot_scalar = from_field_unsafe(self.header.storage_slot);\n        // We compute the note hiding point as:\n        //     `G_amt * amount + G_npk * npk_m_hash + G_rnd * randomness + G_slot * slot`\n        // instead of using pedersen or poseidon2 because it allows us to privately add and subtract from amount\n        // in public by leveraging homomorphism.\n        multi_scalar_mul(\n            [G_amt, G_npk, G_rnd, G_slot],\n            [amount_scalar, npk_m_hash_scalar, randomness_scalar, slot_scalar]\n        )\n    }\n}\n\nimpl TokenNote {\n    // TODO: Merge this func with `compute_note_hiding_point`. I (benesjan) didn't do it in the initial PR to not have\n    // to modify macros and all the related funcs in it.\n    fn to_note_hiding_point(self) -> TokenNoteHidingPoint {\n        TokenNoteHidingPoint::new(self.compute_note_hiding_point())\n    }\n}\n\nstruct TokenNoteHidingPoint {\n  inner: Point\n}\n\nimpl TokenNoteHidingPoint {\n    fn new(point: Point) -> Self {\n        Self { inner: point }\n    }\n\n    fn add_amount(&mut self, amount: U128) {\n        self.inner = multi_scalar_mul([G_amt], [from_field_unsafe(amount.to_integer())]) + self.inner;\n    }\n\n    fn add_npk_m_hash(&mut self, npk_m_hash: Field) {\n        self.inner = multi_scalar_mul([G_npk], [from_field_unsafe(npk_m_hash)]) + self.inner;\n    }\n\n    fn add_randomness(&mut self, randomness: Field) {\n        self.inner = multi_scalar_mul([G_rnd], [from_field_unsafe(randomness)]) + self.inner;\n    }\n\n    fn add_slot(&mut self, slot: Field) {\n        self.inner = multi_scalar_mul([G_slot], [from_field_unsafe(slot)]) + self.inner;\n    }\n\n    fn finalize(self) -> Field {\n        self.inner.x\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TokenNoteHidingPoint {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr"},"332":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_nullify},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_nullifier(self, _context: &mut PrivateContext, _note_hash_for_nullify: Field) -> Field {\n        self.compute_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator([\n            note_hash_for_nullify,\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr"},"333":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        prelude::{\n        NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n        FunctionSelector, NoteHeader, Point\n    },\n        encrypted_logs::{\n        encrypted_note_emission::{encode_and_encrypt_note_with_keys, encode_and_encrypt_note_with_keys_unconstrained},\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    },\n        keys::getters::get_current_public_keys\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote,\n        token_note::{TokenNote, TOKEN_NOTE_LEN, TokenNoteHidingPoint}, balances_map::BalancesMap\n    };\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES = 8;\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_current_public_keys(&mut context, caller);\n        storage.balances.add(caller, caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_with_keys(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller)\n        );\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n        storage.balances.add(to, to_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n\n        storage.balances.add(from, from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from)\n        );\n\n        storage.balances.add(to, to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to)\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32\n    ) -> U128 {\n        let subtracted = storage.balances.try_sub(account, amount, max_notes);\n\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128\n    ) -> PrivateCallInterface<25, U128, (AztecAddress, Field)> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[aztec(internal)]\n    #[aztec(private)]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        let to_keys = get_current_public_keys(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, from_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, to_keys.npk_m, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_current_public_keys(&mut context, from);\n        storage.balances.sub(from, from_keys.npk_m, U128::from_integer(amount)).emit(encode_and_encrypt_note_with_keys(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness) - G_npk * fee_payer_npk =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness) - G_rnd * randomness =\n    ///                          = G_npk * user_npk\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payer npk values of these known contracts is a feasible attack.\n    ///\n    /// `fee_payer_point` and `user_point` above are public information because they are passed as args to the public\n    /// `complete_refund(...)` function.\n    #[aztec(private)]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        user_randomness: Field, // A randomness to mix in with the generated refund note for the sponsored user.\n        fee_payer_randomness: Field // A randomness to mix in with the generated fee note for the fee payer.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_npk_m_hash = get_current_public_keys(&mut context, fee_payer).npk_m.hash();\n        let user_keys = get_current_public_keys(&mut context, user);\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded \n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES\n        );\n        storage.balances.add(user, user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_with_keys_unconstrained(&mut context, user_keys.ovpk_m, user_keys.ivpk_m, user)\n        );\n\n        // 4. We create the partial notes for the fee payer and the user.\n        // --> Called \"partial\" because they don't have the amount set yet (that will be done in `complete_refund(...)`).\n        let fee_payer_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(fee_payer).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: fee_payer_npk_m_hash,\n            randomness: fee_payer_randomness\n        };\n        let user_partial_note = TokenNote {\n            header: NoteHeader {\n                contract_address: AztecAddress::zero(),\n                nonce: 0,\n                storage_slot: storage.balances.map.at(user).storage_slot,\n                note_hash_counter: 0\n            },\n            amount: U128::zero(),\n            npk_m_hash: user_npk_m_hash,\n            randomness: user_randomness\n        };\n\n        // 5. Now we get the note hiding points.\n        let mut fee_payer_point = fee_payer_partial_note.to_note_hiding_point();\n        let mut user_point = user_partial_note.to_note_hiding_point();\n\n        // 6. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"complete_refund(((Field,Field,bool)),((Field,Field,bool)),Field)\"),\n            [\n            fee_payer_point.inner.x, fee_payer_point.inner.y, fee_payer_point.inner.is_infinite as Field, user_point.inner.x, user_point.inner.y, user_point.inner.is_infinite as Field, funded_amount\n        ]\n        );\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn complete_refund(\n        // TODO(#7771): the following makes macros crash --> try getting it work once we migrate to metaprogramming\n        // mut fee_payer_point: TokenNoteHidingPoint,\n        // mut user_point: TokenNoteHidingPoint,\n        fee_payer_point_immutable: TokenNoteHidingPoint,\n        user_point_immutable: TokenNoteHidingPoint,\n        funded_amount: Field\n    ) {\n        // TODO(#7771): nuke the following 2 lines once we have mutable args\n        let mut fee_payer_point = fee_payer_point_immutable;\n        let mut user_point = user_point_immutable;\n\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We add fee to the fee payer point and refund amount to the user point.\n        fee_payer_point.add_amount(tx_fee);\n        user_point.add_amount(refund_amount);\n\n        // 4. We finalize the hiding points to get the note hashes.\n        let fee_payer_note_hash = fee_payer_point.finalize();\n        let user_note_hash = user_point.finalize();\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_note_hash);\n        context.push_note_hash(user_note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"347":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.51.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}